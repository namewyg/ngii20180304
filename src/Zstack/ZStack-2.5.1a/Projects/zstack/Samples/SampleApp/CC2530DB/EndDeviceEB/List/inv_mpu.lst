###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         03/Jul/2019  09:48:54 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\Source\MPU6050\e #
#                          MPL\inv_mpu.c                                      #
#    Command line       =  -f H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5. #
#                          1a\Projects\zstack\Samples\SampleApp\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ       #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f          #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\Tools\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO        #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 H:\项目\2019.5\旺旺（lwk474 #
#                          153686）\ZStack-2.5.1a\Projects\zstack\Samples\Sam #
#                          pleApp\Source\MPU6050\eMPL\inv_mpu.c -D            #
#                          NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D            #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -lC H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5 #
#                          .1a\Projects\zstack\Samples\SampleApp\CC2530DB\End #
#                          DeviceEB\List\ -lA H:\项目\2019.5\旺旺（lwk4741536 #
#                          86）\ZStack-2.5.1a\Projects\zstack\Samples\SampleA #
#                          pp\CC2530DB\EndDeviceEB\List\ --diag_suppress      #
#                          Pe001,Pa010 -o H:\项目\2019.5\旺旺（lwk474153686） #
#                          \ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\C #
#                          C2530DB\EndDeviceEB\Obj\ -e --no_code_motion       #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5. #
#                          1a\Projects\zstack\Samples\SampleApp\CC2530DB\ -I  #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\Sour #
#                          ce\ -I H:\项目\2019.5\旺旺（lwk474153686）\ZStack- #
#                          2.5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          ..\Source\MPU6050\ -I H:\项目\2019.5\旺旺（lwk4741 #
#                          53686）\ZStack-2.5.1a\Projects\zstack\Samples\Samp #
#                          leApp\CC2530DB\..\Source\MPU6050\eMPL\ -I          #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\ZMain\TI2530DB\ -I H:\项目\2019.5\旺旺（lwk47415 #
#                          3686）\ZStack-2.5.1a\Projects\zstack\Samples\Sampl #
#                          eApp\CC2530DB\..\..\..\..\..\Components\hal\includ #
#                          e\ -I H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2 #
#                          .5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\. #
#                          .\..\..\..\..\Components\hal\target\CC2530EB\ -I   #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\mac\include\ -I                 #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\mac\high_level\ -I              #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\ -I         #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\mac\low_level\srf04\single_chip #
#                          \ -I H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2. #
#                          5.1a\Projects\zstack\Samples\SampleApp\CC2530DB\.. #
#                          \..\..\..\..\Components\mt\ -I                     #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\osal\include\ -I                #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\services\saddr\ -I              #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I              #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\af\ -I                    #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\nwk\ -I                   #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\sapi\ -I                  #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\sec\ -I                   #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\sys\ -I                   #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\stack\zdo\ -I                   #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\zmac\ -I                        #
#                          H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\..\..\. #
#                          .\..\..\Components\zmac\f8w\ -Ohz                  #
#    List file          =  H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\EndDevi #
#                          ceEB\List\inv_mpu.lst                              #
#    Object file        =  H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\ #
#                          Projects\zstack\Samples\SampleApp\CC2530DB\EndDevi #
#                          ceEB\Obj\inv_mpu.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

H:\项目\2019.5\旺旺（lwk474153686）\ZStack-2.5.1a\Projects\zstack\Samples\SampleApp\Source\MPU6050\eMPL\inv_mpu.c
      1          /*
      2           $License:
      3              Copyright (C) 2011-2012 InvenSense Corporation, All Rights Reserved.
      4              See included License.txt for License information.
      5           $
      6           */
      7          /**
      8           *  @addtogroup  DRIVERS Sensor Driver Layer
      9           *  @brief       Hardware drivers to communicate with sensors via I2C.
     10           *
     11           *  @{
     12           *      @file       inv_mpu.c
     13           *      @brief      An I2C-based driver for Invensense gyroscopes.
     14           *      @details    This driver currently works for the following devices:
     15           *                  MPU6050
     16           *                  MPU6500
     17           *                  MPU9150 (or MPU6050 w/ AK8975 on the auxiliary bus)
     18           *                  MPU9250 (or MPU6500 w/ AK8963 on the auxiliary bus)
     19           */
     20          #include <stdio.h>
     21          //#include <stdint.h>
     22          #include <stdlib.h>
     23          #include <string.h>
     24          #include <math.h>
     25          #include "inv_mpu.h"
     26          #include "inv_mpu_dmp_motion_driver.h"
     27          #include "mpu6050.h"
     28          #include "delay.h"
     29          //#include "usart.h"
     30          
     31          
     32          #define MPU6050							//定义我们使用的传感器为MPU6050
     33          #define MOTION_DRIVER_TARGET_MSP430		//定义驱动部分,采用MSP430的驱动(移植到STM32F1)
     34          
     35          /* The following functions must be defined for this platform:
     36           * i2c_write(unsigned char slave_addr, unsigned char reg_addr,
     37           *      unsigned char length, unsigned char const *data)
     38           * i2c_read(unsigned char slave_addr, unsigned char reg_addr,
     39           *      unsigned char length, unsigned char *data)
     40           * delay_ms(unsigned long num_ms)
     41           * get_ms(unsigned long *count)
     42           * reg_int_cb(void (*cb)(void), unsigned char port, unsigned char pin)
     43           * labs(long x)
     44           * fabsf(float x)
     45           * min(int a, int b)
     46           */
     47          
     48          
     49          #if defined MOTION_DRIVER_TARGET_MSP430
     50          //#include "msp430.h"
     51          //#include "msp430_i2c.h"
     52          //#include "msp430_clock.h"
     53          //#include "msp430_interrupt.h"
     54          
     55          #define i2c_write   MPU_Write_Len
     56          #define i2c_read    MPU_Read_Len
     57          #define delay_ms    delay_ms
     58          #define get_ms      mget_ms
     59          //static inline int reg_int_cb(struct int_param_s *int_param)
     60          //{
     61          //    return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     62          //        int_param->active_low);
     63          //}
     64          #define log_i 	printf	//打印信息
     65          #define log_e  	printf	//打印信息
     66          /* labs is already defined by TI's toolchain. */
     67          /* fabs is for doubles. fabsf is for floats. */
     68          #define fabs        fabsf
     69          //#define fabs        fabs
     70          #define min(a,b) ((a<b)?a:b)
     71          #elif defined EMPL_TARGET_MSP430
     72          #include "msp430.h"
     73          #include "msp430_i2c.h"
     74          #include "msp430_clock.h"
     75          #include "msp430_interrupt.h"
     76          #include "log.h"
     77          #define i2c_write   msp430_i2c_write
     78          #define i2c_read    msp430_i2c_read
     79          #define delay_ms    msp430_delay_ms
     80          #define get_ms      msp430_get_clock_ms
     81          static inline int reg_int_cb(struct int_param_s *int_param)
     82          {
     83              return msp430_reg_int_cb(int_param->cb, int_param->pin, int_param->lp_exit,
     84                  int_param->active_low);
     85          }
     86          #define log_i       MPL_LOGI
     87          #define log_e       MPL_LOGE
     88          /* labs is already defined by TI's toolchain. */
     89          /* fabs is for doubles. fabsf is for floats. */
     90          #define fabs        fabsf
     91          #define min(a,b) ((a<b)?a:b)
     92          #elif defined EMPL_TARGET_UC3L0
     93          /* Instead of using the standard TWI driver from the ASF library, we're using
     94           * a TWI driver that follows the slave address + register address convention.
     95           */
     96          #include "twi.h"
     97          #include "delay.h"
     98          #include "sysclk.h"
     99          #include "log.h"
    100          #include "sensors_xplained.h"
    101          #include "uc3l0_clock.h"
    102          #define i2c_write(a, b, c, d)   twi_write(a, b, d, c)
    103          #define i2c_read(a, b, c, d)    twi_read(a, b, d, c)
    104          /* delay_ms is a function already defined in ASF. */
    105          #define get_ms  uc3l0_get_clock_ms
    106          static inline int reg_int_cb(struct int_param_s *int_param)
    107          {
    108              sensor_board_irq_connect(int_param->pin, int_param->cb, int_param->arg);
    109              return 0;
    110          }
    111          #define log_i       MPL_LOGI
    112          #define log_e       MPL_LOGE
    113          /* UC3 is a 32-bit processor, so abs and labs are equivalent. */
    114          #define labs        abs
    115          #define fabs(x)     (((x)>0)?(x):-(x))
    116          #else
    117          #error  Gyro driver is missing the system layer implementations.
    118          #endif
    119          
    120          #if !defined MPU6050 && !defined MPU9150 && !defined MPU6500 && !defined MPU9250
    121          #error  Which gyro are you using? Define MPUxxxx in your compiler options.
    122          #endif
    123          
    124          /* Time for some messy macro work. =]
    125           * #define MPU9150
    126           * is equivalent to..
    127           * #define MPU6050
    128           * #define AK8975_SECONDARY
    129           *
    130           * #define MPU9250
    131           * is equivalent to..
    132           * #define MPU6500
    133           * #define AK8963_SECONDARY
    134           */
    135          #if defined MPU9150
    136          #ifndef MPU6050
    137          #define MPU6050
    138          #endif                          /* #ifndef MPU6050 */
    139          #if defined AK8963_SECONDARY
    140          #error "MPU9150 and AK8963_SECONDARY cannot both be defined."
    141          #elif !defined AK8975_SECONDARY /* #if defined AK8963_SECONDARY */
    142          #define AK8975_SECONDARY
    143          #endif                          /* #if defined AK8963_SECONDARY */
    144          #elif defined MPU9250           /* #if defined MPU9150 */
    145          #ifndef MPU6500
    146          #define MPU6500
    147          #endif                          /* #ifndef MPU6500 */
    148          #if defined AK8975_SECONDARY
    149          #error "MPU9250 and AK8975_SECONDARY cannot both be defined."
    150          #elif !defined AK8963_SECONDARY /* #if defined AK8975_SECONDARY */
    151          #define AK8963_SECONDARY
    152          #endif                          /* #if defined AK8975_SECONDARY */
    153          #endif                          /* #if defined MPU9150 */
    154          
    155          #if defined AK8975_SECONDARY || defined AK8963_SECONDARY
    156          #define AK89xx_SECONDARY
    157          #else
    158          /* #warning "No compass = less profit for Invensense. Lame." */
    159          #endif
    160          
    161          static int set_int_enable(unsigned char enable);
    162          
    163          /* Hardware registers needed by driver. */
    164          struct gyro_reg_s {
    165              unsigned char who_am_i;
    166              unsigned char rate_div;
    167              unsigned char lpf;
    168              unsigned char prod_id;
    169              unsigned char user_ctrl;
    170              unsigned char fifo_en;
    171              unsigned char gyro_cfg;
    172              unsigned char accel_cfg;
    173          //    unsigned char accel_cfg2;
    174          //    unsigned char lp_accel_odr;
    175              unsigned char motion_thr;
    176              unsigned char motion_dur;
    177              unsigned char fifo_count_h;
    178              unsigned char fifo_r_w;
    179              unsigned char raw_gyro;
    180              unsigned char raw_accel;
    181              unsigned char temp;
    182              unsigned char int_enable;
    183              unsigned char dmp_int_status;
    184              unsigned char int_status;
    185          //    unsigned char accel_intel;
    186              unsigned char pwr_mgmt_1;
    187              unsigned char pwr_mgmt_2;
    188              unsigned char int_pin_cfg;
    189              unsigned char mem_r_w;
    190              unsigned char accel_offs;
    191              unsigned char i2c_mst;
    192              unsigned char bank_sel;
    193              unsigned char mem_start_addr;
    194              unsigned char prgm_start_h;
    195          #if defined AK89xx_SECONDARY
    196              unsigned char s0_addr;
    197              unsigned char s0_reg;
    198              unsigned char s0_ctrl;
    199              unsigned char s1_addr;
    200              unsigned char s1_reg;
    201              unsigned char s1_ctrl;
    202              unsigned char s4_ctrl;
    203              unsigned char s0_do;
    204              unsigned char s1_do;
    205              unsigned char i2c_delay_ctrl;
    206              unsigned char raw_compass;
    207              /* The I2C_MST_VDDIO bit is in this register. */
    208              unsigned char yg_offs_tc;
    209          #endif
    210          };
    211          
    212          /* Information specific to a particular device. */
    213          struct hw_s {
    214              unsigned char addr;
    215              unsigned short max_fifo;
    216              unsigned char num_reg;
    217              unsigned short temp_sens;
    218              short temp_offset;
    219              unsigned short bank_size;
    220          #if defined AK89xx_SECONDARY
    221              unsigned short compass_fsr;
    222          #endif
    223          };
    224          
    225          /* When entering motion interrupt mode, the driver keeps track of the
    226           * previous state so that it can be restored at a later time.
    227           * TODO: This is tacky. Fix it.
    228           */
    229          struct motion_int_cache_s {
    230              unsigned short gyro_fsr;
    231              unsigned char accel_fsr;
    232              unsigned short lpf;
    233              unsigned short sample_rate;
    234              unsigned char sensors_on;
    235              unsigned char fifo_sensors;
    236              unsigned char dmp_on;
    237          };
    238          
    239          /* Cached chip configuration data.
    240           * TODO: A lot of these can be handled with a bitmask.
    241           */
    242          struct chip_cfg_s {
    243              /* Matches gyro_cfg >> 3 & 0x03 */
    244              unsigned char gyro_fsr;
    245              /* Matches accel_cfg >> 3 & 0x03 */
    246              unsigned char accel_fsr;
    247              /* Enabled sensors. Uses same masks as fifo_en, NOT pwr_mgmt_2. */
    248              unsigned char sensors;
    249              /* Matches config register. */
    250              unsigned char lpf;
    251              unsigned char clk_src;
    252              /* Sample rate, NOT rate divider. */
    253              unsigned short sample_rate;
    254              /* Matches fifo_en register. */
    255              unsigned char fifo_enable;
    256              /* Matches int enable register. */
    257              unsigned char int_enable;
    258              /* 1 if devices on auxiliary I2C bus appear on the primary. */
    259              unsigned char bypass_mode;
    260              /* 1 if half-sensitivity.
    261               * NOTE: This doesn't belong here, but everything else in hw_s is const,
    262               * and this allows us to save some precious RAM.
    263               */
    264              unsigned char accel_half;
    265              /* 1 if device in low-power accel-only mode. */
    266              unsigned char lp_accel_mode;
    267              /* 1 if interrupts are only triggered on motion events. */
    268              unsigned char int_motion_only;
    269              struct motion_int_cache_s cache;
    270              /* 1 for active low interrupts. */
    271              unsigned char active_low_int;
    272              /* 1 for latched interrupts. */
    273              unsigned char latched_int;
    274              /* 1 if DMP is enabled. */
    275              unsigned char dmp_on;
    276              /* Ensures that DMP will only be loaded once. */
    277              unsigned char dmp_loaded;
    278              /* Sampling rate used when DMP is enabled. */
    279              unsigned short dmp_sample_rate;
    280          #ifdef AK89xx_SECONDARY
    281              /* Compass sample rate. */
    282              unsigned short compass_sample_rate;
    283              unsigned char compass_addr;
    284              short mag_sens_adj[3];
    285          #endif
    286          };
    287          
    288          /* Information for self-test. */
    289          struct test_s {
    290              unsigned long gyro_sens;
    291              unsigned long accel_sens;
    292              unsigned char reg_rate_div;
    293              unsigned char reg_lpf;
    294              unsigned char reg_gyro_fsr;
    295              unsigned char reg_accel_fsr;
    296              unsigned short wait_ms;
    297              unsigned char packet_thresh;
    298              float min_dps;
    299              float max_dps;
    300              float max_gyro_var;
    301              float min_g;
    302              float max_g;
    303              float max_accel_var;
    304          };
    305          
    306          /* Gyro driver state variables. */
    307          struct gyro_state_s {
    308              const struct gyro_reg_s *reg;
    309              const struct hw_s *hw;
    310              struct chip_cfg_s chip_cfg;
    311              const struct test_s *test;
    312          };
    313          
    314          /* Filter configurations. */
    315          enum lpf_e {
    316              INV_FILTER_256HZ_NOLPF2 = 0,
    317              INV_FILTER_188HZ,
    318              INV_FILTER_98HZ,
    319              INV_FILTER_42HZ,
    320              INV_FILTER_20HZ,
    321              INV_FILTER_10HZ,
    322              INV_FILTER_5HZ,
    323              INV_FILTER_2100HZ_NOLPF,
    324              NUM_FILTER
    325          };
    326          
    327          /* Full scale ranges. */
    328          enum gyro_fsr_e {
    329              INV_FSR_250DPS = 0,
    330              INV_FSR_500DPS,
    331              INV_FSR_1000DPS,
    332              INV_FSR_2000DPS,
    333              NUM_GYRO_FSR
    334          };
    335          
    336          /* Full scale ranges. */
    337          enum accel_fsr_e {
    338              INV_FSR_2G = 0,
    339              INV_FSR_4G,
    340              INV_FSR_8G,
    341              INV_FSR_16G,
    342              NUM_ACCEL_FSR
    343          };
    344          
    345          /* Clock sources. */
    346          enum clock_sel_e {
    347              INV_CLK_INTERNAL = 0,
    348              INV_CLK_PLL,
    349              NUM_CLK
    350          };
    351          
    352          /* Low-power accel wakeup rates. */
    353          enum lp_accel_rate_e {
    354          #if defined MPU6050
    355              INV_LPA_1_25HZ,
    356              INV_LPA_5HZ,
    357              INV_LPA_20HZ,
    358              INV_LPA_40HZ
    359          #elif defined MPU6500
    360              INV_LPA_0_3125HZ,
    361              INV_LPA_0_625HZ,
    362              INV_LPA_1_25HZ,
    363              INV_LPA_2_5HZ,
    364              INV_LPA_5HZ,
    365              INV_LPA_10HZ,
    366              INV_LPA_20HZ,
    367              INV_LPA_40HZ,
    368              INV_LPA_80HZ,
    369              INV_LPA_160HZ,
    370              INV_LPA_320HZ,
    371              INV_LPA_640HZ
    372          #endif
    373          };
    374          
    375          #define BIT_I2C_MST_VDDIO   (0x80)
    376          #define BIT_FIFO_EN         (0x40)
    377          #define BIT_DMP_EN          (0x80)
    378          #define BIT_FIFO_RST        (0x04)
    379          #define BIT_DMP_RST         (0x08)
    380          #define BIT_FIFO_OVERFLOW   (0x10)
    381          #define BIT_DATA_RDY_EN     (0x01)
    382          #define BIT_DMP_INT_EN      (0x02)
    383          #define BIT_MOT_INT_EN      (0x40)
    384          #define BITS_FSR            (0x18)
    385          #define BITS_LPF            (0x07)
    386          #define BITS_HPF            (0x07)
    387          #define BITS_CLK            (0x07)
    388          #define BIT_FIFO_SIZE_1024  (0x40)
    389          #define BIT_FIFO_SIZE_2048  (0x80)
    390          #define BIT_FIFO_SIZE_4096  (0xC0)
    391          #define BIT_RESET           (0x80)
    392          #define BIT_SLEEP           (0x40)
    393          #define BIT_S0_DELAY_EN     (0x01)
    394          #define BIT_S2_DELAY_EN     (0x04)
    395          #define BITS_SLAVE_LENGTH   (0x0F)
    396          #define BIT_SLAVE_BYTE_SW   (0x40)
    397          #define BIT_SLAVE_GROUP     (0x10)
    398          #define BIT_SLAVE_EN        (0x80)
    399          #define BIT_I2C_READ        (0x80)
    400          #define BITS_I2C_MASTER_DLY (0x1F)
    401          #define BIT_AUX_IF_EN       (0x20)
    402          #define BIT_ACTL            (0x80)
    403          #define BIT_LATCH_EN        (0x20)
    404          #define BIT_ANY_RD_CLR      (0x10)
    405          #define BIT_BYPASS_EN       (0x02)
    406          #define BITS_WOM_EN         (0xC0)
    407          #define BIT_LPA_CYCLE       (0x20)
    408          #define BIT_STBY_XA         (0x20)
    409          #define BIT_STBY_YA         (0x10)
    410          #define BIT_STBY_ZA         (0x08)
    411          #define BIT_STBY_XG         (0x04)
    412          #define BIT_STBY_YG         (0x02)
    413          #define BIT_STBY_ZG         (0x01)
    414          #define BIT_STBY_XYZA       (BIT_STBY_XA | BIT_STBY_YA | BIT_STBY_ZA)
    415          #define BIT_STBY_XYZG       (BIT_STBY_XG | BIT_STBY_YG | BIT_STBY_ZG)
    416          
    417          #if defined AK8975_SECONDARY
    418          #define SUPPORTS_AK89xx_HIGH_SENS   (0x00)
    419          #define AK89xx_FSR                  (9830)
    420          #elif defined AK8963_SECONDARY
    421          #define SUPPORTS_AK89xx_HIGH_SENS   (0x10)
    422          #define AK89xx_FSR                  (4915)
    423          #endif
    424          
    425          #ifdef AK89xx_SECONDARY
    426          #define AKM_REG_WHOAMI      (0x00)
    427          
    428          #define AKM_REG_ST1         (0x02)
    429          #define AKM_REG_HXL         (0x03)
    430          #define AKM_REG_ST2         (0x09)
    431          
    432          #define AKM_REG_CNTL        (0x0A)
    433          #define AKM_REG_ASTC        (0x0C)
    434          #define AKM_REG_ASAX        (0x10)
    435          #define AKM_REG_ASAY        (0x11)
    436          #define AKM_REG_ASAZ        (0x12)
    437          
    438          #define AKM_DATA_READY      (0x01)
    439          #define AKM_DATA_OVERRUN    (0x02)
    440          #define AKM_OVERFLOW        (0x80)
    441          #define AKM_DATA_ERROR      (0x40)
    442          
    443          #define AKM_BIT_SELF_TEST   (0x40)
    444          
    445          #define AKM_POWER_DOWN          (0x00 | SUPPORTS_AK89xx_HIGH_SENS)
    446          #define AKM_SINGLE_MEASUREMENT  (0x01 | SUPPORTS_AK89xx_HIGH_SENS)
    447          #define AKM_FUSE_ROM_ACCESS     (0x0F | SUPPORTS_AK89xx_HIGH_SENS)
    448          #define AKM_MODE_SELF_TEST      (0x08 | SUPPORTS_AK89xx_HIGH_SENS)
    449          
    450          #define AKM_WHOAMI      (0x48)
    451          #endif
    452          
    453          #if defined MPU6050
    454          //const struct gyro_reg_s reg = {
    455          //    .who_am_i       = 0x75,
    456          //    .rate_div       = 0x19,
    457          //    .lpf            = 0x1A,
    458          //    .prod_id        = 0x0C,
    459          //    .user_ctrl      = 0x6A,
    460          //    .fifo_en        = 0x23,
    461          //    .gyro_cfg       = 0x1B,
    462          //    .accel_cfg      = 0x1C,
    463          //    .motion_thr     = 0x1F,
    464          //    .motion_dur     = 0x20,
    465          //    .fifo_count_h   = 0x72,
    466          //    .fifo_r_w       = 0x74,
    467          //    .raw_gyro       = 0x43,
    468          //    .raw_accel      = 0x3B,
    469          //    .temp           = 0x41,
    470          //    .int_enable     = 0x38,
    471          //    .dmp_int_status = 0x39,
    472          //    .int_status     = 0x3A,
    473          //    .pwr_mgmt_1     = 0x6B,
    474          //    .pwr_mgmt_2     = 0x6C,
    475          //    .int_pin_cfg    = 0x37,
    476          //    .mem_r_w        = 0x6F,
    477          //    .accel_offs     = 0x06,
    478          //    .i2c_mst        = 0x24,
    479          //    .bank_sel       = 0x6D,
    480          //    .mem_start_addr = 0x6E,
    481          //    .prgm_start_h   = 0x70
    482          //#ifdef AK89xx_SECONDARY
    483          //    ,.raw_compass   = 0x49,
    484          //    .yg_offs_tc     = 0x01,
    485          //    .s0_addr        = 0x25,
    486          //    .s0_reg         = 0x26,
    487          //    .s0_ctrl        = 0x27,
    488          //    .s1_addr        = 0x28,
    489          //    .s1_reg         = 0x29,
    490          //    .s1_ctrl        = 0x2A,
    491          //    .s4_ctrl        = 0x34,
    492          //    .s0_do          = 0x63,
    493          //    .s1_do          = 0x64,
    494          //    .i2c_delay_ctrl = 0x67
    495          //#endif
    496          //};

   \                                 In  segment XDATA_ROM_C, align 1
    497          const struct gyro_reg_s reg = {
   \                     reg:
   \   000000   75           DB 117
   \   000001   19           DB 25
   \   000002   1A           DB 26
   \   000003   0C           DB 12
   \   000004   6A           DB 106
   \   000005   23           DB 35
   \   000006   1B           DB 27
   \   000007   1C           DB 28
   \   000008   1F           DB 31
   \   000009   20           DB 32
   \   00000A   72           DB 114
   \   00000B   74           DB 116
   \   00000C   43           DB 67
   \   00000D   3B           DB 59
   \   00000E   41           DB 65
   \   00000F   38           DB 56
   \   000010   39           DB 57
   \   000011   3A           DB 58
   \   000012   6B           DB 107
   \   000013   6C           DB 108
   \   000014   37           DB 55
   \   000015   6F           DB 111
   \   000016   06           DB 6
   \   000017   24           DB 36
   \   000018   6D           DB 109
   \   000019   6E           DB 110
   \   00001A   70           DB 112
    498          0x75,  //who_am_i
    499          0x19,  //rate_div
    500          0x1A,  //lpf
    501          0x0C,  //prod_id
    502          0x6A,  //user_ctrl
    503          0x23,  //fifo_en
    504          0x1B,  //gyro_cfg
    505          0x1C,  //accel_cfg
    506          0x1F,  // motion_thr
    507          0x20,  // motion_dur
    508          0x72,  // fifo_count_h
    509          0x74,  // fifo_r_w
    510          0x43,  // raw_gyro
    511          0x3B,  // raw_accel
    512          0x41,  // temp
    513          0x38,  // int_enable
    514          0x39,  //  dmp_int_status
    515          0x3A,  //  int_status
    516          0x6B,  // pwr_mgmt_1
    517          0x6C,  // pwr_mgmt_2
    518          0x37,  // int_pin_cfg
    519          0x6F,  // mem_r_w
    520          0x06,  // accel_offs
    521          0x24,  // i2c_mst
    522          0x6D,  // bank_sel
    523          0x6E,  // mem_start_addr
    524          0x70   // prgm_start_h
    525          };
    526          
    527          //const struct hw_s hw = {
    528          //    .addr           = 0x68,
    529          //    .max_fifo       = 1024,
    530          //    .num_reg        = 118,
    531          //    .temp_sens      = 340,
    532          //    .temp_offset    = -521,
    533          //    .bank_size      = 256
    534          //#if defined AK89xx_SECONDARY
    535          //    ,.compass_fsr    = AK89xx_FSR
    536          //#endif
    537          //};

   \                                 In  segment XDATA_ROM_C, align 1
    538          const struct hw_s hw={
   \                     hw:
   \   000000   68           DB 104
   \   000001   0004         DW 1024
   \   000003   76           DB 118
   \   000004   5401         DW 340
   \   000006   F7FD         DW -521
   \   000008   0001         DW 256
    539            0x68,	 //addr
    540            1024,	 //max_fifo
    541            118,	 //num_reg
    542            340,	 //temp_sens
    543            -521,	 //temp_offset
    544            256	 //bank_size
    545          };
    546          
    547          //const struct test_s test = {
    548          //    .gyro_sens      = 32768/250,
    549          //    .accel_sens     = 32768/16,
    550          //    .reg_rate_div   = 0,    /* 1kHz. */
    551          //    .reg_lpf        = 1,    /* 188Hz. */
    552          //    .reg_gyro_fsr   = 0,    /* 250dps. */
    553          //    .reg_accel_fsr  = 0x18, /* 16g. */
    554          //    .wait_ms        = 50,
    555          //    .packet_thresh  = 5,    /* 5% */
    556          //    .min_dps        = 10.f,
    557          //    .max_dps        = 105.f,
    558          //    .max_gyro_var   = 0.14f,
    559          //    .min_g          = 0.3f,
    560          //    .max_g          = 0.95f,
    561          //    .max_accel_var  = 0.14f
    562          //};

   \                                 In  segment XDATA_ROM_C, align 1
    563          const struct test_s test={
   \                     test:
   \   000000   83000000     DD 131
   \   000004   00080000     DD 2048
   \   000008   00           DB 0
   \   000009   01           DB 1
   \   00000A   00           DB 0
   \   00000B   18           DB 24
   \   00000C   3200         DW 50
   \   00000E   05           DB 5
   \   00000F   00002041     DD 41200000H
   \   000013   0000D242     DD 42D20000H
   \   000017   295C0F3E     DD 3E0F5C29H
   \   00001B   9A99993E     DD 3E99999AH
   \   00001F   3333733F     DD 3F733333H
   \   000023   295C0F3E     DD 3E0F5C29H
    564          32768/250,		 //gyro_sens
    565          32768/16,		 //	accel_sens
    566          0,				 //	reg_rate_div
    567          1,				//	reg_lpf
    568          0,				 //	reg_gyro_fsr
    569          0x18,			//	reg_accel_fsr
    570          50,				//	wait_ms
    571          5,				//	packet_thresh
    572          10.0f,			 //	min_dps
    573          105.0f,			 //	max_dps
    574          0.14f,			//	max_gyro_var
    575          0.3f,		   //	min_g
    576          0.95f,		   //	max_g
    577          0.14f		   //	max_accel_var
    578          };
    579          
    580          //static struct gyro_state_s st = {
    581          //    .reg = &reg,
    582          //    .hw = &hw,
    583          //    .test = &test
    584          //};

   \                                 In  segment XDATA_I, align 1, keep-with-next
    585          static struct gyro_state_s st={
   \                     st:
   \   000000                DS 35
   \   000023                REQUIRE `?<Initializer for st>`
   \   000023                REQUIRE __INIT_XDATA_I
    586            &reg,
    587            &hw,
    588            {0},
    589            &test
    590          };
    591          
    592          
    593          #elif defined MPU6500
    594          const struct gyro_reg_s reg = {
    595              .who_am_i       = 0x75,
    596              .rate_div       = 0x19,
    597              .lpf            = 0x1A,
    598              .prod_id        = 0x0C,
    599              .user_ctrl      = 0x6A,
    600              .fifo_en        = 0x23,
    601              .gyro_cfg       = 0x1B,
    602              .accel_cfg      = 0x1C,
    603              .accel_cfg2     = 0x1D,
    604              .lp_accel_odr   = 0x1E,
    605              .motion_thr     = 0x1F,
    606              .motion_dur     = 0x20,
    607              .fifo_count_h   = 0x72,
    608              .fifo_r_w       = 0x74,
    609              .raw_gyro       = 0x43,
    610              .raw_accel      = 0x3B,
    611              .temp           = 0x41,
    612              .int_enable     = 0x38,
    613              .dmp_int_status = 0x39,
    614              .int_status     = 0x3A,
    615              .accel_intel    = 0x69,
    616              .pwr_mgmt_1     = 0x6B,
    617              .pwr_mgmt_2     = 0x6C,
    618              .int_pin_cfg    = 0x37,
    619              .mem_r_w        = 0x6F,
    620              .accel_offs     = 0x77,
    621              .i2c_mst        = 0x24,
    622              .bank_sel       = 0x6D,
    623              .mem_start_addr = 0x6E,
    624              .prgm_start_h   = 0x70
    625          #ifdef AK89xx_SECONDARY
    626              ,.raw_compass   = 0x49,
    627              .s0_addr        = 0x25,
    628              .s0_reg         = 0x26,
    629              .s0_ctrl        = 0x27,
    630              .s1_addr        = 0x28,
    631              .s1_reg         = 0x29,
    632              .s1_ctrl        = 0x2A,
    633              .s4_ctrl        = 0x34,
    634              .s0_do          = 0x63,
    635              .s1_do          = 0x64,
    636              .i2c_delay_ctrl = 0x67
    637          #endif
    638          };
    639          const struct hw_s hw = {
    640              .addr           = 0x68,
    641              .max_fifo       = 1024,
    642              .num_reg        = 128,
    643              .temp_sens      = 321,
    644              .temp_offset    = 0,
    645              .bank_size      = 256
    646          #if defined AK89xx_SECONDARY
    647              ,.compass_fsr    = AK89xx_FSR
    648          #endif
    649          };
    650          
    651          const struct test_s test = {
    652              .gyro_sens      = 32768/250,
    653              .accel_sens     = 32768/16,
    654              .reg_rate_div   = 0,    /* 1kHz. */
    655              .reg_lpf        = 1,    /* 188Hz. */
    656              .reg_gyro_fsr   = 0,    /* 250dps. */
    657              .reg_accel_fsr  = 0x18, /* 16g. */
    658              .wait_ms        = 50,
    659              .packet_thresh  = 5,    /* 5% */
    660              .min_dps        = 10.f,
    661              .max_dps        = 105.f,
    662              .max_gyro_var   = 0.14f,
    663              .min_g          = 0.3f,
    664              .max_g          = 0.95f,
    665              .max_accel_var  = 0.14f
    666          };
    667          
    668          static struct gyro_state_s st = {
    669              .reg = &reg,
    670              .hw = &hw,
    671              .test = &test
    672          };
    673          #endif
    674          
    675          #define MAX_PACKET_LENGTH (12)
    676          
    677          #ifdef AK89xx_SECONDARY
    678          static int setup_compass(void);
    679          #define MAX_COMPASS_SAMPLE_RATE (100)
    680          #endif
    681          
    682          /**
    683           *  @brief      Enable/disable data ready interrupt.
    684           *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
    685           *  interrupt is used.
    686           *  @param[in]  enable      1 to enable interrupt.
    687           *  @return     0 if successful.
    688           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    689          static int set_int_enable(unsigned char enable)
   \                     set_int_enable:
    690          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    691              unsigned char tmp;
    692          
    693              if (st.chip_cfg.dmp_on) {
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   601D         JZ      ??set_int_enable_0
    694                  if (enable)
   \   000012   EE           MOV     A,R6
   \   000013   85..82       MOV     DPL,?XSP + 0
   \   000016   85..83       MOV     DPH,?XSP + 1
   \   000019   6004         JZ      ??set_int_enable_1
    695                      tmp = BIT_DMP_INT_EN;
   \   00001B   7402         MOV     A,#0x2
   \   00001D   8001         SJMP    ??set_int_enable_2
    696                  else
    697                      tmp = 0x00;
   \                     ??set_int_enable_1:
   \   00001F   E4           CLR     A
   \                     ??set_int_enable_2:
   \   000020   12....       LCALL   ??Subroutine138_0 & 0xFFFF
    698                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
   \                     ??CrossCallReturnLabel_303:
   \   000023   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000026   6035         JZ      ??set_int_enable_3
    699                      return -1;
   \                     ??set_int_enable_4:
   \   000028   7AFF         MOV     R2,#-0x1
   \   00002A   7BFF         MOV     R3,#-0x1
   \                     ??set_int_enable_5:
   \   00002C   02....       LJMP    ?Subroutine0 & 0xFFFF
    700                  st.chip_cfg.int_enable = tmp;
    701              } else {
    702                  if (!st.chip_cfg.sensors)
   \                     ??set_int_enable_0:
   \   00002F   90....       MOV     DPTR,#st + 6
   \   000032   E0           MOVX    A,@DPTR
   \   000033   60F3         JZ      ??set_int_enable_4
    703                      return -1;
    704                  if (enable && st.chip_cfg.int_enable)
   \   000035   EE           MOV     A,R6
   \   000036   6016         JZ      ??set_int_enable_6
   \   000038   90....       MOV     DPTR,#st + 12
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   6006         JZ      ??set_int_enable_7
    705                      return 0;
   \                     ??set_int_enable_8:
   \   00003E   7A00         MOV     R2,#0x0
   \   000040   7B00         MOV     R3,#0x0
   \   000042   80E8         SJMP    ??set_int_enable_5
    706                  if (enable)
    707                      tmp = BIT_DATA_RDY_EN;
   \                     ??set_int_enable_7:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   7401         MOV     A,#0x1
   \   00004C   8007         SJMP    ??set_int_enable_9
    708                  else
    709                      tmp = 0x00;
   \                     ??set_int_enable_6:
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   E4           CLR     A
    710                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
    711                      return -1;
    712                  st.chip_cfg.int_enable = tmp;
    713              }
   \                     ??set_int_enable_9:
   \   000055   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_304:
   \   000058   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00005B   70CB         JNZ     ??set_int_enable_4
   \                     ??set_int_enable_3:
   \   00005D   85..82       MOV     DPL,?XSP + 0
   \   000060   85..83       MOV     DPH,?XSP + 1
   \   000063   E0           MOVX    A,@DPTR
   \   000064   90....       MOV     DPTR,#st + 12
   \   000067   F0           MOVX    @DPTR,A
   \   000068   80D4         SJMP    ??set_int_enable_8
    714              return 0;
    715          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_194:
   \   000003                REQUIRE ??Subroutine109_0
   \   000003                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000003   12....       LCALL   ??MPU_Write_Len?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine111_0
   \   000002                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine112_0
   \   000003                ; // Fall through to label ??Subroutine112_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine112_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine89:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_197:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine101:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   8882         MOV     DPL,R0
   \   000008   8983         MOV     DPH,R1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_263:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine93:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001   AC82         MOV     R4,DPL
   \   000003   AD83         MOV     R5,DPH
   \   000005   7B01         MOV     R3,#0x1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine99:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_334:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine138_0:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_310:
   \   000003   90....       MOV     DPTR,#st
   \   000006   E0           MOVX    A,@DPTR
   \   000007   240F         ADD     A,#0xf
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine104:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_337:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine105:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    716          
    717          /**
    718           *  @brief      Register dump for testing.
    719           *  @return     0 if successful.
    720           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    721          int mpu_reg_dump(void)
   \                     mpu_reg_dump:
    722          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    723              unsigned char ii;
    724              unsigned char data;
    725          
    726              for (ii = 0; ii < st.hw->num_reg; ii++) {
   \   00000A   7E00         MOV     R6,#0x0
   \   00000C   8025         SJMP    ??mpu_reg_dump_0
    727                  if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
    728                      continue;
    729                  if (i2c_read(st.hw->addr, ii, 1, &data))
    730                      return -1;
    731                  log_i("%#5x: %#5x\r\n", ii, data);
   \                     ??mpu_reg_dump_1:
   \   00000E                ; Setup parameters for call to function printf
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F5..         MOV     ?V0 + 0,A
   \   000017   75..00       MOV     ?V0 + 1,#0x0
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   8E..         MOV     ?V0 + 0,R6
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7A..         MOV     R2,#`?<Constant "%#5x: %#5x\\r\\n">` & 0xff
   \   000028   7B..         MOV     R3,#(`?<Constant "%#5x: %#5x\\r\\n">` >> 8) & 0xff
   \   00002A   12....       LCALL   ??printf?relay
   \   00002D   7404         MOV     A,#0x4
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   \                     ??mpu_reg_dump_2:
   \   000032   0E           INC     R6
   \                     ??mpu_reg_dump_0:
   \   000033   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000036   5029         JNC     ??mpu_reg_dump_3
   \   000038   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_190:
   \   00003B   60F5         JZ      ??mpu_reg_dump_2
   \   00003D   90....       MOV     DPTR,#st
   \   000040   E0           MOVX    A,@DPTR
   \   000041   2415         ADD     A,#0x15
   \   000043   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_188:
   \   000046   60EA         JZ      ??mpu_reg_dump_2
   \   000048                ; Setup parameters for call to function MPU_Read_Len
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   AC82         MOV     R4,DPL
   \   000050   AD83         MOV     R5,DPH
   \   000052   7B01         MOV     R3,#0x1
   \   000054   EE           MOV     A,R6
   \   000055   FA           MOV     R2,A
   \   000056   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_258:
   \   000059   60B3         JZ      ??mpu_reg_dump_1
   \   00005B   7AFF         MOV     R2,#-0x1
   \   00005D   7BFF         MOV     R3,#-0x1
   \   00005F   8004         SJMP    ??mpu_reg_dump_4
    732              }
    733              return 0;
   \                     ??mpu_reg_dump_3:
   \   000061   7A00         MOV     R2,#0x0
   \   000063   7B00         MOV     R3,#0x0
   \                     ??mpu_reg_dump_4:
   \   000065   02....       LJMP    ?Subroutine1 & 0xFFFF
    734          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_232:
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F8           MOV     R0,A
   \   000008   EE           MOV     A,R6
   \   000009   C3           CLR     C
   \   00000A   98           SUBB    A,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   240B         ADD     A,#0xb
   \   000006                REQUIRE ??Subroutine110_0
   \   000006                ; // Fall through to label ??Subroutine110_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_193:
   \   000003   6E           XRL     A,R6
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_279:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine98:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_294:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine103:
   \   000000   12....       LCALL   ?Subroutine105 & 0xFFFF
   \                     ??CrossCallReturnLabel_336:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine125_0:
   \   000000   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_262:
   \   000003   12....       LCALL   ??MPU_Read_Len?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine83:
   \   000000   12....       LCALL   ?Subroutine101 & 0xFFFF
   \                     ??CrossCallReturnLabel_196:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7401         MOV     A,#0x1
   \   000002                REQUIRE ??Subroutine135_0
   \   000002                ; // Fall through to label ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine135_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine136_0
   \   000003                ; // Fall through to label ??Subroutine136_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine136_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   12....       LCALL   ?Subroutine99 & 0xFFFF
   \                     ??CrossCallReturnLabel_264:
   \   000003   22           RET
    735          
    736          /**
    737           *  @brief      Read from a single register.
    738           *  NOTE: The memory and FIFO read/write registers cannot be accessed.
    739           *  @param[in]  reg     Register address.
    740           *  @param[out] data    Register data.
    741           *  @return     0 if successful.
    742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    743          int mpu_read_reg(unsigned char reg, unsigned char *data)
   \                     mpu_read_reg:
    744          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    745              if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
   \   000007   12....       LCALL   ?Subroutine16 & 0xFFFF
   \                     ??CrossCallReturnLabel_191:
   \   00000A   600B         JZ      ??mpu_read_reg_0
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2415         ADD     A,#0x15
   \   000012   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_189:
   \   000015   7006         JNZ     ??mpu_read_reg_1
    746                  return -1;
   \                     ??mpu_read_reg_0:
   \   000017   7AFF         MOV     R2,#-0x1
   \   000019   7BFF         MOV     R3,#-0x1
   \   00001B   801B         SJMP    ??mpu_read_reg_2
    747              if (reg >= st.hw->num_reg)
   \                     ??mpu_read_reg_1:
   \   00001D   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000020   50F5         JNC     ??mpu_read_reg_0
    748                  return -1;
    749              return i2c_read(st.hw->addr, reg, 1, data);
   \   000022                ; Setup parameters for call to function MPU_Read_Len
   \   000022   EA           MOV     A,R2
   \   000023   FC           MOV     R4,A
   \   000024   EB           MOV     A,R3
   \   000025   FD           MOV     R5,A
   \   000026   7B01         MOV     R3,#0x1
   \   000028   EE           MOV     A,R6
   \   000029   FA           MOV     R2,A
   \   00002A   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_330:
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F9           MOV     R1,A
   \   00002F   12....       LCALL   ??MPU_Read_Len?relay
   \   000032   89..         MOV     ?V0 + 0,R1
   \   000034   AA..         MOV     R2,?V0 + 0
   \   000036   7B00         MOV     R3,#0x0
   \                     ??mpu_read_reg_2:
   \   000038   02....       LJMP    ??Subroutine112_0 & 0xFFFF
    750          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003                REQUIRE ??Subroutine141_0
   \   000003                ; // Fall through to label ??Subroutine141_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine141_0:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_333:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine100:
   \   000000   12....       LCALL   ?Subroutine104 & 0xFFFF
   \                     ??CrossCallReturnLabel_335:
   \   000003   22           RET
    751          
    752          /**
    753           *  @brief      Initialize hardware.
    754           *  Initial configuration:\n
    755           *  Gyro FSR: +/- 2000DPS\n
    756           *  Accel FSR +/- 2G\n
    757           *  DLPF: 42Hz\n
    758           *  FIFO rate: 50Hz\n
    759           *  Clock source: Gyro PLL\n
    760           *  FIFO: Disabled.\n
    761           *  Data ready interrupt: Disabled, active low, unlatched.
    762           *  @param[in]  int_param   Platform-specific parameters to interrupt API.
    763           *  @return     0 if successful.
    764           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   90....       MOV     DPTR,#st
   \   000003   E0           MOVX    A,@DPTR
   \   000004   2412         ADD     A,#0x12
   \   000006                REQUIRE ??Subroutine108_0
   \   000006                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    765          int mpu_init(void)
   \                     mpu_init:
    766          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    767              unsigned char data[6], rev;
    768          
    769              /* Reset device. */
    770              data[0] = BIT_RESET;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7480         MOV     A,#-0x80
   \   000012   12....       LCALL   ?Subroutine50 & 0xFFFF
    771              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \                     ??CrossCallReturnLabel_64:
   \   000015   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000018   6007         JZ      ??mpu_init_0
    772                  return -1;
   \                     ??mpu_init_1:
   \   00001A   7AFF         MOV     R2,#-0x1
   \   00001C   7BFF         MOV     R3,#-0x1
   \   00001E   02....       LJMP    ??mpu_init_2 & 0xFFFF
    773              delay_ms(100);
   \                     ??mpu_init_0:
   \   000021                ; Setup parameters for call to function delay_ms
   \   000021   7A64         MOV     R2,#0x64
   \   000023   12....       LCALL   ?Subroutine60 & 0xFFFF
    774          
    775              /* Wake up chip. */
    776              data[0] = 0x00;
   \                     ??CrossCallReturnLabel_80:
   \   000026   E4           CLR     A
   \   000027   12....       LCALL   ?Subroutine50 & 0xFFFF
    777              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \                     ??CrossCallReturnLabel_65:
   \   00002A   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   00002D   70EB         JNZ     ??mpu_init_1
    778                  return -1;
    779          
    780          #if defined MPU6050
    781              /* Check product revision. */
    782              if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
   \   00002F                ; Setup parameters for call to function MPU_Read_Len
   \   00002F   85..82       MOV     DPL,?XSP + 0
   \   000032   85..83       MOV     DPH,?XSP + 1
   \   000035   AC82         MOV     R4,DPL
   \   000037   AD83         MOV     R5,DPH
   \   000039   7B06         MOV     R3,#0x6
   \   00003B   90....       MOV     DPTR,#st
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   2416         ADD     A,#0x16
   \   000041   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_200:
   \   000044   70D4         JNZ     ??mpu_init_1
    783                  return -1;
    784              rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
    785                  (data[1] & 0x01);
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   E4           CLR     A
   \   00004F   33           RLC     A
   \   000050   F9           MOV     R1,A
   \   000051   7403         MOV     A,#0x3
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E0           MOVX    A,@DPTR
   \   000057   A2E0         MOV     C,0xE0 /* A   */.0
   \   000059   E4           CLR     A
   \   00005A   33           RLC     A
   \   00005B   33           RLC     A
   \   00005C   F8           MOV     R0,A
   \   00005D   7405         MOV     A,#0x5
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   A2E0         MOV     C,0xE0 /* A   */.0
   \   000065   E4           CLR     A
   \   000066   33           RLC     A
   \   000067   33           RLC     A
   \   000068   33           RLC     A
   \   000069   48           ORL     A,R0
   \   00006A   49           ORL     A,R1
   \   00006B   F5..         MOV     ?V0 + 0,A
    786          
    787              if (rev) {
   \   00006D   6028         JZ      ??mpu_init_3
    788                  /* Congrats, these parts are better. */
    789                  if (rev == 1)
   \   00006F   7401         MOV     A,#0x1
   \   000071   65..         XRL     A,?V0 + 0
   \   000073   6058         JZ      ??mpu_init_4
    790                      st.chip_cfg.accel_half = 1;
    791                  else if (rev == 2)
   \   000075   7402         MOV     A,#0x2
   \   000077   65..         XRL     A,?V0 + 0
   \   000079   7006         JNZ     ??mpu_init_5
    792                      st.chip_cfg.accel_half = 0;
   \                     ??mpu_init_6:
   \   00007B   90....       MOV     DPTR,#st + 14
   \   00007E   E4           CLR     A
   \   00007F   8051         SJMP    ??mpu_init_7
    793                  else {
    794                      log_e("Unsupported software product rev %d.\n", rev);
   \                     ??mpu_init_5:
   \   000081                ; Setup parameters for call to function printf
   \   000081   75..00       MOV     ?V0 + 1,#0x0
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   7A..         MOV     R2,#`?<Constant "Unsupported software ...">` & 0xff
   \   00008B   7B..         MOV     R3,#(`?<Constant "Unsupported software ...">` >> 8) & 0xff
   \   00008D   12....       LCALL   ??printf?relay
   \   000090   7402         MOV     A,#0x2
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
   \   000095   8083         SJMP    ??mpu_init_1
    795                      return -1;
    796                  }
    797              } else {
    798                  if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
   \                     ??mpu_init_3:
   \   000097                ; Setup parameters for call to function MPU_Read_Len
   \   000097   85..82       MOV     DPL,?XSP + 0
   \   00009A   85..83       MOV     DPH,?XSP + 1
   \   00009D   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   0000A0   A3           INC     DPTR
   \   0000A1   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   0000A4   6003         JZ      $+5
   \   0000A6   02....       LJMP    ??mpu_init_1 & 0xFFFF
    799                      return -1;
    800                  rev = data[0] & 0x0F;
   \   0000A9   85..82       MOV     DPL,?XSP + 0
   \   0000AC   85..83       MOV     DPH,?XSP + 1
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   540F         ANL     A,#0xf
   \   0000B2   F5..         MOV     ?V0 + 0,A
    801                  if (!rev) {
   \   0000B4   700A         JNZ     ??mpu_init_8
    802                      log_e("Product ID read as 0 indicates device is either "
    803                          "incompatible or an MPU3050.\n");
   \   0000B6                ; Setup parameters for call to function printf
   \   0000B6   7A..         MOV     R2,#`?<Constant "Product ID read as 0 ...">` & 0xff
   \   0000B8   7B..         MOV     R3,#(`?<Constant "Product ID read as 0 ...">` >> 8) & 0xff
   \   0000BA   12....       LCALL   ??printf?relay
   \   0000BD   02....       LJMP    ??mpu_init_1 & 0xFFFF
    804                      return -1;
    805                  } else if (rev == 4) {
   \                     ??mpu_init_8:
   \   0000C0   7404         MOV     A,#0x4
   \   0000C2   65..         XRL     A,?V0 + 0
   \   0000C4   70B5         JNZ     ??mpu_init_6
    806                      log_i("Half sensitivity part found.\n");
   \   0000C6                ; Setup parameters for call to function printf
   \   0000C6   7A..         MOV     R2,#`?<Constant "Half sensitivity part...">` & 0xff
   \   0000C8   7B..         MOV     R3,#(`?<Constant "Half sensitivity part...">` >> 8) & 0xff
   \   0000CA   12....       LCALL   ??printf?relay
    807                      st.chip_cfg.accel_half = 1;
   \                     ??mpu_init_4:
   \   0000CD   90....       MOV     DPTR,#st + 14
   \   0000D0   7401         MOV     A,#0x1
   \                     ??mpu_init_7:
   \   0000D2   F0           MOVX    @DPTR,A
    808                  } else
    809                      st.chip_cfg.accel_half = 0;
    810              }
    811          #elif defined MPU6500
    812          #define MPU6500_MEM_REV_ADDR    (0x17)
    813              if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
    814                  return -1;
    815              if (rev == 0x1)
    816                  st.chip_cfg.accel_half = 0;
    817              else {
    818                  log_e("Unsupported software product rev %d.\n", rev);
    819                  return -1;
    820              }
    821          
    822              /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
    823               * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
    824               */
    825              data[0] = BIT_FIFO_SIZE_1024 | 0x8;
    826              if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
    827                  return -1;
    828          #endif
    829          
    830              /* Set to invalid values to ensure no I2C writes are skipped. */
    831              st.chip_cfg.sensors = 0xFF;
   \   0000D3   90....       MOV     DPTR,#st + 6
   \   0000D6   74FF         MOV     A,#-0x1
   \   0000D8   F0           MOVX    @DPTR,A
    832              st.chip_cfg.gyro_fsr = 0xFF;
   \   0000D9   90....       MOV     DPTR,#st + 4
   \   0000DC   12....       LCALL   ?Subroutine91 & 0xFFFF
    833              st.chip_cfg.accel_fsr = 0xFF;
    834              st.chip_cfg.lpf = 0xFF;
    835              st.chip_cfg.sample_rate = 0xFFFF;
    836              st.chip_cfg.fifo_enable = 0xFF;
   \                     ??CrossCallReturnLabel_129:
   \   0000DF   A3           INC     DPTR
   \   0000E0   F0           MOVX    @DPTR,A
    837              st.chip_cfg.bypass_mode = 0xFF;
   \   0000E1   90....       MOV     DPTR,#st + 13
   \   0000E4   F0           MOVX    @DPTR,A
    838          #ifdef AK89xx_SECONDARY
    839              st.chip_cfg.compass_sample_rate = 0xFFFF;
    840          #endif
    841              /* mpu_set_sensors always preserves this setting. */
    842              st.chip_cfg.clk_src = INV_CLK_PLL;
   \   0000E5   90....       MOV     DPTR,#st + 8
   \   0000E8   7401         MOV     A,#0x1
   \   0000EA   F0           MOVX    @DPTR,A
    843              /* Handled in next call to mpu_set_bypass. */
    844              st.chip_cfg.active_low_int = 1;
   \   0000EB   90....       MOV     DPTR,#st + 27
   \   0000EE   F0           MOVX    @DPTR,A
    845              st.chip_cfg.latched_int = 0;
   \   0000EF   A3           INC     DPTR
   \   0000F0   E4           CLR     A
   \   0000F1   F0           MOVX    @DPTR,A
    846              st.chip_cfg.int_motion_only = 0;
   \   0000F2   90....       MOV     DPTR,#st + 16
   \   0000F5   F0           MOVX    @DPTR,A
    847              st.chip_cfg.lp_accel_mode = 0;
   \   0000F6   90....       MOV     DPTR,#st + 15
   \   0000F9   F0           MOVX    @DPTR,A
    848              memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
   \   0000FA                ; Setup parameters for call to function memset
   \   0000FA   75..0A       MOV     ?V0 + 0,#0xa
   \   0000FD   F5..         MOV     ?V0 + 1,A
   \   0000FF   78..         MOV     R0,#?V0 + 0
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000104   7C00         MOV     R4,#0x0
   \   000106   7D00         MOV     R5,#0x0
   \   000108   7A..         MOV     R2,#(st + 17) & 0xff
   \   00010A   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00010C   12....       LCALL   ??memset?relay
   \   00010F   7402         MOV     A,#0x2
   \   000111   12....       LCALL   ?DEALLOC_XSTACK8
    849              st.chip_cfg.dmp_on = 0;
   \   000114   90....       MOV     DPTR,#st + 29
   \   000117   E4           CLR     A
   \   000118   F0           MOVX    @DPTR,A
    850              st.chip_cfg.dmp_loaded = 0;
   \   000119   A3           INC     DPTR
   \   00011A   F0           MOVX    @DPTR,A
    851              st.chip_cfg.dmp_sample_rate = 0;
   \   00011B   A3           INC     DPTR
   \   00011C   F0           MOVX    @DPTR,A
   \   00011D   A3           INC     DPTR
   \   00011E   F0           MOVX    @DPTR,A
    852          
    853              if (mpu_set_gyro_fsr(2000))
   \   00011F                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   00011F   7AD0         MOV     R2,#-0x30
   \   000121   7B07         MOV     R3,#0x7
   \   000123   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   000126   8B..         MOV     ?V0 + 1,R3
   \   000128   EA           MOV     A,R2
   \   000129   45..         ORL     A,?V0 + 1
   \   00012B   6003         JZ      $+5
   \   00012D   02....       LJMP    ??mpu_init_1 & 0xFFFF
    854                  return -1;
    855              if (mpu_set_accel_fsr(2))
   \   000130                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000130   7902         MOV     R1,#0x2
   \   000132   12....       LCALL   ??mpu_set_accel_fsr?relay
   \   000135   8B..         MOV     ?V0 + 1,R3
   \   000137   EA           MOV     A,R2
   \   000138   45..         ORL     A,?V0 + 1
   \   00013A   6003         JZ      $+5
   \   00013C   02....       LJMP    ??mpu_init_1 & 0xFFFF
    856                  return -1;
    857              if (mpu_set_lpf(42))
   \   00013F                ; Setup parameters for call to function mpu_set_lpf
   \   00013F   7A2A         MOV     R2,#0x2a
   \   000141   7B00         MOV     R3,#0x0
   \   000143   12....       LCALL   ??mpu_set_lpf?relay
   \   000146   8B..         MOV     ?V0 + 1,R3
   \   000148   EA           MOV     A,R2
   \   000149   45..         ORL     A,?V0 + 1
   \   00014B   6003         JZ      $+5
   \   00014D   02....       LJMP    ??mpu_init_1 & 0xFFFF
    858                  return -1;
    859              if (mpu_set_sample_rate(50))
   \   000150                ; Setup parameters for call to function mpu_set_sample_rate
   \   000150   7A32         MOV     R2,#0x32
   \   000152   7B00         MOV     R3,#0x0
   \   000154   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000157   8B..         MOV     ?V0 + 1,R3
   \   000159   EA           MOV     A,R2
   \   00015A   45..         ORL     A,?V0 + 1
   \   00015C   6003         JZ      $+5
   \   00015E   02....       LJMP    ??mpu_init_1 & 0xFFFF
    860                  return -1;
    861              if (mpu_configure_fifo(0))
   \   000161                ; Setup parameters for call to function mpu_configure_fifo
   \   000161   7900         MOV     R1,#0x0
   \   000163   12....       LCALL   ??mpu_configure_fifo?relay
   \   000166   8B..         MOV     ?V0 + 1,R3
   \   000168   EA           MOV     A,R2
   \   000169   45..         ORL     A,?V0 + 1
   \   00016B   6003         JZ      $+5
   \   00016D   02....       LJMP    ??mpu_init_1 & 0xFFFF
    862                  return -1;
    863          
    864          //    if (int_param)
    865          //        reg_int_cb(int_param);
    866          
    867          #ifdef AK89xx_SECONDARY
    868              setup_compass();
    869              if (mpu_set_compass_sample_rate(10))
    870                  return -1;
    871          #else
    872              /* Already disabled by setup_compass. */
    873              if (mpu_set_bypass(0))
   \   000170                ; Setup parameters for call to function mpu_set_bypass
   \   000170   7900         MOV     R1,#0x0
   \   000172   12....       LCALL   ??mpu_set_bypass?relay
   \   000175   8B..         MOV     ?V0 + 1,R3
   \   000177   EA           MOV     A,R2
   \   000178   45..         ORL     A,?V0 + 1
   \   00017A   6003         JZ      $+5
   \   00017C   02....       LJMP    ??mpu_init_1 & 0xFFFF
    874                  return -1;
    875          #endif
    876          
    877              mpu_set_sensors(0);
   \   00017F                ; Setup parameters for call to function mpu_set_sensors
   \   00017F   7900         MOV     R1,#0x0
   \   000181   12....       LCALL   ??mpu_set_sensors?relay
    878              return 0;
   \   000184   7A00         MOV     R2,#0x0
   \   000186   7B00         MOV     R3,#0x0
   \                     ??mpu_init_2:
   \   000188   7406         MOV     A,#0x6
   \   00018A   02....       LJMP    ??Subroutine135_0 & 0xFFFF
    879          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine113_0:
   \   000000   12....       LCALL   ?Subroutine89 & 0xFFFF
   \                     ??CrossCallReturnLabel_195:
   \   000003                REQUIRE ??Subroutine114_0
   \   000003                ; // Fall through to label ??Subroutine114_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine114_0:
   \   000000   12....       LCALL   ?Subroutine75 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000003   12....       LCALL   ??MPU_Read_Len?relay
   \   000006   E9           MOV     A,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   7B00         MOV     R3,#0x0
   \   000002   12....       LCALL   ??delay_ms?relay
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_286:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_308:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009                REQUIRE ??Subroutine132_0
   \   000009                ; // Fall through to label ??Subroutine132_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine132_0:
   \   000000   12....       LCALL   ?Subroutine100 & 0xFFFF
   \                     ??CrossCallReturnLabel_332:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine91:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   F0           MOVX    @DPTR,A
   \   000003   90....       MOV     DPTR,#st + 7
   \   000006   F0           MOVX    @DPTR,A
   \   000007   90....       MOV     DPTR,#st + 9
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   F0           MOVX    @DPTR,A
   \   00000D   22           RET
    880          
    881          /**
    882           *  @brief      Enter low-power accel-only mode.
    883           *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
    884           *  the accelerometer at one of the following frequencies:
    885           *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
    886           *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
    887           *  \n If the requested rate is not one listed above, the device will be set to
    888           *  the next highest rate. Requesting a rate above the maximum supported
    889           *  frequency will result in an error.
    890           *  \n To select a fractional wake-up frequency, round down the value passed to
    891           *  @e rate.
    892           *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
    893           *                          accel mode.
    894           *  @return     0 if successful.
    895           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   33           RLC     A
   \   000003   33           RLC     A
   \   000004   54C0         ANL     A,#0xc0
   \   000006   4407         ORL     A,#0x7
   \   000008                REQUIRE ??Subroutine106_0
   \   000008                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000003                REQUIRE ??Subroutine107_0
   \   000003                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    896          int mpu_lp_accel_mode(unsigned char rate)
   \                     mpu_lp_accel_mode:
    897          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    898              unsigned char tmp[2];
    899          
    900              if (rate > 40)
   \   00000C   C3           CLR     C
   \   00000D   9429         SUBB    A,#0x29
   \   00000F   4007         JC      ??mpu_lp_accel_mode_0
    901                  return -1;
   \                     ??mpu_lp_accel_mode_1:
   \   000011   7AFF         MOV     R2,#-0x1
   \   000013   7BFF         MOV     R3,#-0x1
   \   000015   02....       LJMP    ??mpu_lp_accel_mode_2 & 0xFFFF
    902          
    903              if (!rate) {
   \                     ??mpu_lp_accel_mode_0:
   \   000018   EE           MOV     A,R6
   \   000019   701B         JNZ     ??mpu_lp_accel_mode_3
    904                  mpu_set_int_latched(0);
   \   00001B                ; Setup parameters for call to function mpu_set_int_latched
   \   00001B   7900         MOV     R1,#0x0
   \   00001D   12....       LCALL   ?Subroutine65 & 0xFFFF
    905                  tmp[0] = 0;
   \                     ??CrossCallReturnLabel_92:
   \   000020   E4           CLR     A
   \   000021   F0           MOVX    @DPTR,A
    906                  tmp[1] = BIT_STBY_XYZG;
   \   000022   04           INC     A
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   7407         MOV     A,#0x7
   \   000028   12....       LCALL   ??Subroutine106_0 & 0xFFFF
    907                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_139:
   \   00002B   70E4         JNZ     ??mpu_lp_accel_mode_1
    908                      return -1;
    909                  st.chip_cfg.lp_accel_mode = 0;
   \   00002D   90....       MOV     DPTR,#st + 15
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
    910                  return 0;
   \   000032   FA           MOV     R2,A
   \   000033   FB           MOV     R3,A
   \   000034   806D         SJMP    ??mpu_lp_accel_mode_2
    911              }
    912              /* For LP accel, we automatically configure the hardware to produce latched
    913               * interrupts. In LP accel mode, the hardware cycles into sleep mode before
    914               * it gets a chance to deassert the interrupt pin; therefore, we shift this
    915               * responsibility over to the MCU.
    916               *
    917               * Any register read will clear the interrupt.
    918               */
    919              mpu_set_int_latched(1);
   \                     ??mpu_lp_accel_mode_3:
   \   000036                ; Setup parameters for call to function mpu_set_int_latched
   \   000036   7901         MOV     R1,#0x1
   \   000038   12....       LCALL   ?Subroutine65 & 0xFFFF
    920          #if defined MPU6050
    921              tmp[0] = BIT_LPA_CYCLE;
   \                     ??CrossCallReturnLabel_93:
   \   00003B   7420         MOV     A,#0x20
   \   00003D   F0           MOVX    @DPTR,A
    922              if (rate == 1) {
   \   00003E   7401         MOV     A,#0x1
   \   000040   6E           XRL     A,R6
   \   000041   700C         JNZ     ??mpu_lp_accel_mode_4
    923                  tmp[1] = INV_LPA_1_25HZ;
   \   000043   7401         MOV     A,#0x1
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
    924                  mpu_set_lpf(5);
   \   00004A                ; Setup parameters for call to function mpu_set_lpf
   \   00004A   7A05         MOV     R2,#0x5
   \   00004C   FB           MOV     R3,A
   \   00004D   802E         SJMP    ??mpu_lp_accel_mode_5
    925              } else if (rate <= 5) {
   \                     ??mpu_lp_accel_mode_4:
   \   00004F   EE           MOV     A,R6
   \   000050   C3           CLR     C
   \   000051   9406         SUBB    A,#0x6
   \   000053   500C         JNC     ??mpu_lp_accel_mode_6
    926                  tmp[1] = INV_LPA_5HZ;
   \   000055   7401         MOV     A,#0x1
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7401         MOV     A,#0x1
   \   00005C   F0           MOVX    @DPTR,A
    927                  mpu_set_lpf(5);
   \   00005D                ; Setup parameters for call to function mpu_set_lpf
   \   00005D   7A05         MOV     R2,#0x5
   \   00005F   801A         SJMP    ??mpu_lp_accel_mode_7
    928              } else if (rate <= 20) {
   \                     ??mpu_lp_accel_mode_6:
   \   000061   EE           MOV     A,R6
   \   000062   C3           CLR     C
   \   000063   9415         SUBB    A,#0x15
   \   000065   7401         MOV     A,#0x1
   \   000067   500A         JNC     ??mpu_lp_accel_mode_8
    929                  tmp[1] = INV_LPA_20HZ;
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   7402         MOV     A,#0x2
   \   00006E   F0           MOVX    @DPTR,A
    930                  mpu_set_lpf(10);
   \   00006F                ; Setup parameters for call to function mpu_set_lpf
   \   00006F   7A0A         MOV     R2,#0xa
   \   000071   8008         SJMP    ??mpu_lp_accel_mode_7
    931              } else {
    932                  tmp[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_accel_mode_8:
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   7403         MOV     A,#0x3
   \   000078   F0           MOVX    @DPTR,A
    933                  mpu_set_lpf(20);
   \   000079                ; Setup parameters for call to function mpu_set_lpf
   \   000079   7A14         MOV     R2,#0x14
   \                     ??mpu_lp_accel_mode_7:
   \   00007B   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_5:
   \   00007D   12....       LCALL   ??mpu_set_lpf?relay
    934              }
    935              tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
   \   000080   7401         MOV     A,#0x1
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   12....       LCALL   ?Subroutine11 & 0xFFFF
    936              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
   \                     ??CrossCallReturnLabel_137:
   \   000088   7087         JNZ     ??mpu_lp_accel_mode_1
    937                  return -1;
    938          #elif defined MPU6500
    939              /* Set wake frequency. */
    940              if (rate == 1)
    941                  tmp[0] = INV_LPA_1_25HZ;
    942              else if (rate == 2)
    943                  tmp[0] = INV_LPA_2_5HZ;
    944              else if (rate <= 5)
    945                  tmp[0] = INV_LPA_5HZ;
    946              else if (rate <= 10)
    947                  tmp[0] = INV_LPA_10HZ;
    948              else if (rate <= 20)
    949                  tmp[0] = INV_LPA_20HZ;
    950              else if (rate <= 40)
    951                  tmp[0] = INV_LPA_40HZ;
    952              else if (rate <= 80)
    953                  tmp[0] = INV_LPA_80HZ;
    954              else if (rate <= 160)
    955                  tmp[0] = INV_LPA_160HZ;
    956              else if (rate <= 320)
    957                  tmp[0] = INV_LPA_320HZ;
    958              else
    959                  tmp[0] = INV_LPA_640HZ;
    960              if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
    961                  return -1;
    962              tmp[0] = BIT_LPA_CYCLE;
    963              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
    964                  return -1;
    965          #endif
    966              st.chip_cfg.sensors = INV_XYZ_ACCEL;
   \   00008A   90....       MOV     DPTR,#st + 6
   \   00008D   7408         MOV     A,#0x8
   \   00008F   F0           MOVX    @DPTR,A
    967              st.chip_cfg.clk_src = 0;
   \   000090   90....       MOV     DPTR,#st + 8
   \   000093   E4           CLR     A
   \   000094   F0           MOVX    @DPTR,A
    968              st.chip_cfg.lp_accel_mode = 1;
   \   000095   90....       MOV     DPTR,#st + 15
   \   000098   04           INC     A
   \   000099   F0           MOVX    @DPTR,A
    969              mpu_configure_fifo(0);
   \   00009A                ; Setup parameters for call to function mpu_configure_fifo
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   ??mpu_configure_fifo?relay
    970          
    971              return 0;
   \   00009F   7A00         MOV     R2,#0x0
   \   0000A1   7B00         MOV     R3,#0x0
   \                     ??mpu_lp_accel_mode_2:
   \   0000A3                REQUIRE ?Subroutine8
   \   0000A3                ; // Fall through to label ?Subroutine8
    972          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7402         MOV     A,#0x2
   \   000002   80..         SJMP    ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   12....       LCALL   ??mpu_set_int_latched?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine90:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000003   7B02         MOV     R3,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine102:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Read_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   AC82         MOV     R4,DPL
   \   000009   AD83         MOV     R5,DPH
   \   00000B   22           RET
    973          
    974          /**
    975           *  @brief      Read raw gyro data directly from the registers.
    976           *  @param[out] data        Raw data in hardware units.
    977           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
    978           *  @return     0 if successful.
    979           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    980          int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_gyro_reg:
    981          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    982              unsigned char tmp[6];
    983          
    984              if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   5470         ANL     A,#0x70
   \   000014   7006         JNZ     ??mpu_get_gyro_reg_0
    985                  return -1;
   \                     ??mpu_get_gyro_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_14
    986          
    987              if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
   \                     ??mpu_get_gyro_reg_0:
   \   00001C                ; Setup parameters for call to function MPU_Read_Len
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240C         ADD     A,#0xc
   \   00002E   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_201:
   \   000031   70E3         JNZ     ??mpu_get_gyro_reg_1
    988                  return -1;
    989              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine41 & 0xFFFF
    990              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_50:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine36 & 0xFFFF
    991              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_31:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine24 & 0xFFFF
    992              if (timestamp)
    993                  get_ms(timestamp);
    994              return 0;
   \                     ??CrossCallReturnLabel_14:
   \   000056                REQUIRE ?Subroutine9
   \   000056                ; // Fall through to label ?Subroutine9
    995          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   7406         MOV     A,#0x6
   \   000002   80..         SJMP    ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_246:
   \   000006   7402         MOV     A,#0x2
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_248:
   \   000006   7404         MOV     A,#0x4
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   12....       LCALL   ?Subroutine92 & 0xFFFF
   \                     ??CrossCallReturnLabel_247:
   \   000008   7A00         MOV     R2,#0x0
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine86:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F9           MOV     R1,A
   \   000008   7401         MOV     A,#0x1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine92:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine119_0
   \   000002                ; // Fall through to label ??Subroutine119_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine119_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   22           RET
    996          
    997          /**
    998           *  @brief      Read raw accel data directly from the registers.
    999           *  @param[out] data        Raw data in hardware units.
   1000           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1001           *  @return     0 if successful.
   1002           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1003          int mpu_get_accel_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_accel_reg:
   1004          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV     A,#-0x6
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1005              unsigned char tmp[6];
   1006          
   1007              if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   A2E3         MOV     C,0xE0 /* A   */.3
   \   000014   4006         JC      ??mpu_get_accel_reg_0
   1008                  return -1;
   \                     ??mpu_get_accel_reg_1:
   \   000016   7AFF         MOV     R2,#-0x1
   \   000018   7BFF         MOV     R3,#-0x1
   \   00001A   803A         SJMP    ??CrossCallReturnLabel_15
   1009          
   1010              if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
   \                     ??mpu_get_accel_reg_0:
   \   00001C                ; Setup parameters for call to function MPU_Read_Len
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   AC82         MOV     R4,DPL
   \   000024   AD83         MOV     R5,DPH
   \   000026   7B06         MOV     R3,#0x6
   \   000028   90....       MOV     DPTR,#st
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   240D         ADD     A,#0xd
   \   00002E   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   000031   70E3         JNZ     ??mpu_get_accel_reg_1
   1011                  return -1;
   1012              data[0] = (tmp[0] << 8) | tmp[1];
   \   000033   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine41 & 0xFFFF
   1013              data[1] = (tmp[2] << 8) | tmp[3];
   \                     ??CrossCallReturnLabel_51:
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   7403         MOV     A,#0x3
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   12....       LCALL   ?Subroutine36 & 0xFFFF
   1014              data[2] = (tmp[4] << 8) | tmp[5];
   \                     ??CrossCallReturnLabel_32:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   F9           MOV     R1,A
   \   00004E   7405         MOV     A,#0x5
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   12....       LCALL   ?Subroutine24 & 0xFFFF
   1015              if (timestamp)
   1016                  get_ms(timestamp);
   1017              return 0;
   \                     ??CrossCallReturnLabel_15:
   \   000056   02....       LJMP    ?Subroutine9 & 0xFFFF
   1018          }
   1019          
   1020          /**
   1021           *  @brief      Read temperature data directly from the registers.
   1022           *  @param[out] data        Data in q16 format.
   1023           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   1024           *  @return     0 if successful.
   1025           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1026          int mpu_get_temperature(long *data, unsigned long *timestamp)
   \                     mpu_get_temperature:
   1027          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1028              unsigned char tmp[2];
   1029              short raw;
   1030          
   1031              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_get_temperature_0
   1032                  return -1;
   \                     ??mpu_get_temperature_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_get_temperature_2 & 0xFFFF
   1033          
   1034              if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
   \                     ??mpu_get_temperature_0:
   \   00001B                ; Setup parameters for call to function MPU_Read_Len
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   AC82         MOV     R4,DPL
   \   000023   AD83         MOV     R5,DPH
   \   000025   7B02         MOV     R3,#0x2
   \   000027   90....       MOV     DPTR,#st
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   240E         ADD     A,#0xe
   \   00002D   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000030   70E2         JNZ     ??mpu_get_temperature_1
   1035                  return -1;
   1036              raw = (tmp[0] << 8) | tmp[1];
   1037              if (timestamp)
   1038                  get_ms(timestamp);
   1039          
   1040              data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
   \   000032   90....       MOV     DPTR,#st + 2
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F8           MOV     R0,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   FA           MOV     R2,A
   \   00003C   E9           MOV     A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0 + 0,A
   \   000047   E9           MOV     A,R1
   \   000048   F5..         MOV     ?V0 + 1,A
   \   00004A   33           RLC     A
   \   00004B   95E0         SUBB    A,0xE0 /* A   */
   \   00004D   F5..         MOV     ?V0 + 2,A
   \   00004F   F5..         MOV     ?V0 + 3,A
   \   000051   78..         MOV     R0,#?V0 + 0
   \   000053   12....       LCALL   ?L_TO_FLT
   \   000056   8A82         MOV     DPL,R2
   \   000058   8B83         MOV     DPH,R3
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000063   78..         MOV     R0,#?V0 + 4
   \   000065   12....       LCALL   ?L_TO_FLT
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   79..         MOV     R1,#?V0 + 4
   \   00006C   12....       LCALL   ?FLT_SUB
   \   00006F   8A82         MOV     DPL,R2
   \   000071   8B83         MOV     DPH,R3
   \   000073   A3           INC     DPTR
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00007A   E4           CLR     A
   \   00007B   F5..         MOV     ?V0 + 6,A
   \   00007D   F5..         MOV     ?V0 + 7,A
   \   00007F   78..         MOV     R0,#?V0 + 4
   \   000081   12....       LCALL   ?UL_TO_FLT
   \   000084   78..         MOV     R0,#?V0 + 0
   \   000086   79..         MOV     R1,#?V0 + 4
   \   000088   12....       LCALL   ?FLT_DIV
   \   00008B   90....       MOV     DPTR,#__Constant_420c0000
   \   00008E   78..         MOV     R0,#?V0 + 4
   \   000090   12....       LCALL   ?L_MOV_X
   \   000093   78..         MOV     R0,#?V0 + 0
   \   000095   79..         MOV     R1,#?V0 + 4
   \   000097   12....       LCALL   ?FLT_ADD
   \   00009A   90....       MOV     DPTR,#__Constant_47800000
   \   00009D   78..         MOV     R0,#?V0 + 4
   \   00009F   12....       LCALL   ?L_MOV_X
   \   0000A2   78..         MOV     R0,#?V0 + 0
   \   0000A4   79..         MOV     R1,#?V0 + 4
   \   0000A6   12....       LCALL   ?FLT_MUL
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   12....       LCALL   ?FLT_TO_L
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   78..         MOV     R0,#?V0 + 0
   \   0000B4   12....       LCALL   ?L_MOV_TO_X
   1041              return 0;
   \   0000B7   7A00         MOV     R2,#0x0
   \   0000B9   7B00         MOV     R3,#0x0
   \                     ??mpu_get_temperature_2:
   \   0000BB   7402         MOV     A,#0x2
   \   0000BD   02....       LJMP    ?Subroutine2 & 0xFFFF
   1042          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F5..         MOV     ?V0 + 4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine126_0:
   \   000000   33           RLC     A
   \   000001   95E0         SUBB    A,0xE0 /* A   */
   \   000003   F5..         MOV     ?V0 + 6,A
   \   000005   F5..         MOV     ?V0 + 7,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   000003   12....       LCALL   ??Subroutine126_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_265:
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   1043          
   1044          /**
   1045           *  @brief      Push biases to the accel bias registers.
   1046           *  This function expects biases relative to the current sensor output, and
   1047           *  these biases will be added to the factory-supplied values.
   1048           *  @param[in]  accel_bias  New biases.
   1049           *  @return     0 if successful.
   1050           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1051          int mpu_set_accel_bias(const long *accel_bias)
   \                     mpu_set_accel_bias:
   1052          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1053              unsigned char data[6];
   1054              short accel_hw[3];
   1055              short got_accel[3];
   1056              short fg[3];
   1057          
   1058              if (!accel_bias)
   \   00000E   EE           MOV     A,R6
   \   00000F   4F           ORL     A,R7
   \   000010   7009         JNZ     ??mpu_set_accel_bias_0
   1059                  return -1;
   \                     ??mpu_set_accel_bias_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \                     ??mpu_set_accel_bias_2:
   \   000016   7418         MOV     A,#0x18
   \   000018   02....       LJMP    ?Subroutine2 & 0xFFFF
   1060              if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
   \                     ??mpu_set_accel_bias_0:
   \   00001B   8E82         MOV     DPL,R6
   \   00001D   8F83         MOV     DPH,R7
   \   00001F   78..         MOV     R0,#?V0 + 0
   \   000021   12....       LCALL   ?L_MOV_X
   \   000024   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000027   702E         JNZ     ??mpu_set_accel_bias_3
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?L_MOV_X
   \   000036   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_84:
   \   000039   701C         JNZ     ??mpu_set_accel_bias_3
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?L_MOV_X
   \   00004C   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00004F   7006         JNZ     ??mpu_set_accel_bias_3
   1061                  return 0;
   \                     ??mpu_set_accel_bias_4:
   \   000051   7A00         MOV     R2,#0x0
   \   000053   7B00         MOV     R3,#0x0
   \   000055   80BF         SJMP    ??mpu_set_accel_bias_2
   1062          
   1063              if (i2c_read(st.hw->addr, 3, 3, data))
   \                     ??mpu_set_accel_bias_3:
   \   000057                ; Setup parameters for call to function MPU_Read_Len
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   AC82         MOV     R4,DPL
   \   00005F   AD83         MOV     R5,DPH
   \   000061   7B03         MOV     R3,#0x3
   \   000063   7A03         MOV     R2,#0x3
   \   000065   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_259:
   \   000068   70A8         JNZ     ??mpu_set_accel_bias_1
   1064                  return -1;
   1065              fg[0] = ((data[0] >> 4) + 8) & 0xf;
   \   00006A   85..82       MOV     DPL,?XSP + 0
   \   00006D   85..83       MOV     DPH,?XSP + 1
   \   000070   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000073   F8           MOV     R0,A
   \   000074   740C         MOV     A,#0xc
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E4           CLR     A
   \   00007D   F0           MOVX    @DPTR,A
   1066              fg[1] = ((data[1] >> 4) + 8) & 0xf;
   \   00007E   04           INC     A
   \   00007F   12....       LCALL   ?XSTACK_DISP0_8
   \   000082   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000085   FC           MOV     R4,A
   \   000086   740E         MOV     A,#0xe
   \   000088   12....       LCALL   ?XSTACK_DISP0_8
   \   00008B   EC           MOV     A,R4
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   E4           CLR     A
   \   00008F   F0           MOVX    @DPTR,A
   1067              fg[2] = ((data[2] >> 4) + 8) & 0xf;
   \   000090   7402         MOV     A,#0x2
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000098   FA           MOV     R2,A
   \   000099   7410         MOV     A,#0x10
   \   00009B   12....       LCALL   ?XSTACK_DISP0_8
   \   00009E   EA           MOV     A,R2
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   E4           CLR     A
   \   0000A2   F0           MOVX    @DPTR,A
   1068          
   1069              accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
   \   0000A3   8E82         MOV     DPL,R6
   \   0000A5   8F83         MOV     DPH,R7
   \   0000A7   78..         MOV     R0,#?V0 + 4
   \   0000A9   12....       LCALL   ?L_MOV_X
   \   0000AC   7401         MOV     A,#0x1
   \   0000AE   78..         MOV     R0,#?V0 + 4
   \   0000B0   12....       LCALL   ?L_SHL
   \   0000B3   740C         MOV     A,#0xc
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   2440         ADD     A,#0x40
   \   0000BB   F5..         MOV     ?V0 + 0,A
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   3400         ADDC    A,#0x0
   \   0000C1   F5..         MOV     ?V0 + 1,A
   \   0000C3   33           RLC     A
   \   0000C4   95E0         SUBB    A,0xE0 /* A   */
   \   0000C6   F5..         MOV     ?V0 + 2,A
   \   0000C8   F5..         MOV     ?V0 + 3,A
   \   0000CA   78..         MOV     R0,#?V0 + 4
   \   0000CC   79..         MOV     R1,#?V0 + 0
   \   0000CE   12....       LCALL   ?L_DIV_MOD
   \   0000D1   7406         MOV     A,#0x6
   \   0000D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D6   E5..         MOV     A,?V0 + 4
   \   0000D8   F0           MOVX    @DPTR,A
   \   0000D9   A3           INC     DPTR
   \   0000DA   E5..         MOV     A,?V0 + 5
   \   0000DC   12....       LCALL   ?Subroutine55 & 0xFFFF
   1070              accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
   \                     ??CrossCallReturnLabel_72:
   \   0000DF   78..         MOV     R0,#?V0 + 0
   \   0000E1   12....       LCALL   ?L_MOV_X
   \   0000E4   7401         MOV     A,#0x1
   \   0000E6   78..         MOV     R0,#?V0 + 0
   \   0000E8   12....       LCALL   ?L_SHL
   \   0000EB   EC           MOV     A,R4
   \   0000EC   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   0000EF   12....       LCALL   ?L_DIV_MOD
   \   0000F2   7408         MOV     A,#0x8
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E5..         MOV     A,?V0 + 0
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   A3           INC     DPTR
   \   0000FB   E5..         MOV     A,?V0 + 1
   \   0000FD   12....       LCALL   ?Subroutine55 & 0xFFFF
   1071              accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
   \                     ??CrossCallReturnLabel_73:
   \   000100   A3           INC     DPTR
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   78..         MOV     R0,#?V0 + 0
   \   000106   12....       LCALL   ?L_MOV_X
   \   000109   7401         MOV     A,#0x1
   \   00010B   78..         MOV     R0,#?V0 + 0
   \   00010D   12....       LCALL   ?L_SHL
   \   000110   EA           MOV     A,R2
   \   000111   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_89:
   \   000114   12....       LCALL   ?L_DIV_MOD
   \   000117   740A         MOV     A,#0xa
   \   000119   12....       LCALL   ?XSTACK_DISP0_8
   \   00011C   E5..         MOV     A,?V0 + 0
   \   00011E   F0           MOVX    @DPTR,A
   \   00011F   A3           INC     DPTR
   \   000120   E5..         MOV     A,?V0 + 1
   \   000122   12....       LCALL   ?Subroutine51 & 0xFFFF
   1072          
   1073              if (i2c_read(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_68:
   \   000125   12....       LCALL   ??Subroutine125_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_260:
   \   000128   6003         JZ      $+5
   \   00012A   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   1074                  return -1;
   1075          
   1076              got_accel[0] = ((short)data[0] << 8) | data[1];
   \   00012D   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   E0           MOVX    A,@DPTR
   \   000134   F8           MOV     R0,A
   \   000135   7412         MOV     A,#0x12
   \   000137   12....       LCALL   ?XSTACK_DISP0_8
   \   00013A   12....       LCALL   ?Subroutine54 & 0xFFFF
   1077              got_accel[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_217:
   \   00013D   12....       LCALL   ?XSTACK_DISP0_8
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F9           MOV     R1,A
   \   000142   7403         MOV     A,#0x3
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   E0           MOVX    A,@DPTR
   \   000148   FA           MOV     R2,A
   \   000149   E9           MOV     A,R1
   \   00014A   FB           MOV     R3,A
   \   00014B   7414         MOV     A,#0x14
   \   00014D   12....       LCALL   ?XSTACK_DISP0_8
   \   000150   EA           MOV     A,R2
   \   000151   F0           MOVX    @DPTR,A
   \   000152   A3           INC     DPTR
   \   000153   EB           MOV     A,R3
   \   000154   F0           MOVX    @DPTR,A
   1078              got_accel[2] = ((short)data[4] << 8) | data[5];
   \   000155   7404         MOV     A,#0x4
   \   000157   12....       LCALL   ?XSTACK_DISP0_8
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   F9           MOV     R1,A
   \   00015C   7405         MOV     A,#0x5
   \   00015E   12....       LCALL   ?XSTACK_DISP0_8
   \   000161   E0           MOVX    A,@DPTR
   \   000162   F8           MOV     R0,A
   \   000163   7416         MOV     A,#0x16
   \   000165   12....       LCALL   ?XSTACK_DISP0_8
   \   000168   E8           MOV     A,R0
   \   000169   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   1079          
   1080              accel_hw[0] += got_accel[0];
   \                     ??CrossCallReturnLabel_241:
   \   00016C   7412         MOV     A,#0x12
   \   00016E   12....       LCALL   ?XSTACK_DISP0_8
   \   000171   E0           MOVX    A,@DPTR
   \   000172   FC           MOV     R4,A
   \   000173   A3           INC     DPTR
   \   000174   E0           MOVX    A,@DPTR
   \   000175   FD           MOV     R5,A
   \   000176   7406         MOV     A,#0x6
   \   000178   12....       LCALL   ?XSTACK_DISP0_8
   \   00017B   E0           MOVX    A,@DPTR
   \   00017C   2C           ADD     A,R4
   \   00017D   F0           MOVX    @DPTR,A
   \   00017E   A3           INC     DPTR
   \   00017F   E0           MOVX    A,@DPTR
   \   000180   3D           ADDC    A,R5
   \   000181   F0           MOVX    @DPTR,A
   1081              accel_hw[1] += got_accel[1];
   \   000182   7408         MOV     A,#0x8
   \   000184   12....       LCALL   ?XSTACK_DISP0_8
   \   000187   E0           MOVX    A,@DPTR
   \   000188   2A           ADD     A,R2
   \   000189   F0           MOVX    @DPTR,A
   \   00018A   A3           INC     DPTR
   \   00018B   E0           MOVX    A,@DPTR
   \   00018C   3B           ADDC    A,R3
   \   00018D   F0           MOVX    @DPTR,A
   1082              accel_hw[2] += got_accel[2];
   \   00018E   740A         MOV     A,#0xa
   \   000190   12....       LCALL   ?XSTACK_DISP0_8
   \   000193   E0           MOVX    A,@DPTR
   \   000194   28           ADD     A,R0
   \   000195   F0           MOVX    @DPTR,A
   \   000196   A3           INC     DPTR
   \   000197   E0           MOVX    A,@DPTR
   \   000198   39           ADDC    A,R1
   \   000199   F0           MOVX    @DPTR,A
   1083          
   1084              data[0] = (accel_hw[0] >> 8) & 0xff;
   \   00019A   7406         MOV     A,#0x6
   \   00019C   12....       LCALL   ?XSTACK_DISP0_8
   \   00019F   E0           MOVX    A,@DPTR
   \   0001A0   F5..         MOV     ?V0 + 0,A
   \   0001A2   A3           INC     DPTR
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F5..         MOV     ?V0 + 1,A
   \   0001A6   7408         MOV     A,#0x8
   \   0001A8   78..         MOV     R0,#?V0 + 0
   \   0001AA   12....       LCALL   ?SS_SHR
   \   0001AD   85..82       MOV     DPL,?XSP + 0
   \   0001B0   85..83       MOV     DPH,?XSP + 1
   \   0001B3   E5..         MOV     A,?V0 + 0
   \   0001B5   F0           MOVX    @DPTR,A
   1085              data[1] = (accel_hw[0]) & 0xff;
   \   0001B6   7406         MOV     A,#0x6
   \   0001B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   C0E0         PUSH    A
   \   0001BE   7401         MOV     A,#0x1
   \   0001C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C3   D0E0         POP     A
   \   0001C5   F0           MOVX    @DPTR,A
   1086              data[2] = (accel_hw[1] >> 8) & 0xff;
   \   0001C6   7408         MOV     A,#0x8
   \   0001C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0001CB   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   0001CE   12....       LCALL   ?SS_SHR
   \   0001D1   7402         MOV     A,#0x2
   \   0001D3   12....       LCALL   ?XSTACK_DISP0_8
   \   0001D6   E5..         MOV     A,?V0 + 0
   \   0001D8   F0           MOVX    @DPTR,A
   1087              data[3] = (accel_hw[1]) & 0xff;
   \   0001D9   7403         MOV     A,#0x3
   \   0001DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DE   EA           MOV     A,R2
   \   0001DF   F0           MOVX    @DPTR,A
   1088              data[4] = (accel_hw[2] >> 8) & 0xff;
   \   0001E0   740A         MOV     A,#0xa
   \   0001E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E5   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   0001E8   12....       LCALL   ?SS_SHR
   \   0001EB   7404         MOV     A,#0x4
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   E5..         MOV     A,?V0 + 0
   \   0001F2   F0           MOVX    @DPTR,A
   1089              data[5] = (accel_hw[2]) & 0xff;
   \   0001F3   7405         MOV     A,#0x5
   \   0001F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F8   EA           MOV     A,R2
   \   0001F9   12....       LCALL   ?Subroutine51 & 0xFFFF
   1090          
   1091              if (i2c_write(st.hw->addr, 0x06, 6, data))
   \                     ??CrossCallReturnLabel_69:
   \   0001FC   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_331:
   \   0001FF   E0           MOVX    A,@DPTR
   \   000200   F9           MOV     R1,A
   \   000201   12....       LCALL   ??MPU_Write_Len?relay
   \   000204   E9           MOV     A,R1
   \   000205   6003         JZ      $+5
   \   000207   02....       LJMP    ??mpu_set_accel_bias_1 & 0xFFFF
   \   00020A   02....       LJMP    ??mpu_set_accel_bias_4 & 0xFFFF
   1092                  return -1;
   1093              return 0;
   1094          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   2440         ADD     A,#0x40
   \   000002   F5..         MOV     ?V0 + 4,A
   \   000004   E4           CLR     A
   \   000005   F5..         MOV     ?V0 + 5,A
   \   000007   F5..         MOV     ?V0 + 6,A
   \   000009   F5..         MOV     ?V0 + 7,A
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   79..         MOV     R1,#?V0 + 4
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 1
   \   000004   45..         ORL     A,?V0 + 2
   \   000006   45..         ORL     A,?V0 + 3
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E8           MOV     A,R0
   \   000001                REQUIRE ??Subroutine115_0
   \   000001                ; // Fall through to label ??Subroutine115_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine115_0:
   \   000000   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_249:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   12....       LCALL   ?Subroutine102 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   000003   7B06         MOV     R3,#0x6
   \   000005   7A06         MOV     R2,#0x6
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   7408         MOV     A,#0x8
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C4           SWAP    A
   \   000002   540F         ANL     A,#0xf
   \   000004   2408         ADD     A,#0x8
   \   000006   540F         ANL     A,#0xf
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine87:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
   1095          
   1096          /**
   1097           *  @brief  Reset FIFO read/write pointers.
   1098           *  @return 0 if successful.
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          int mpu_reset_fifo(void)
   \                     mpu_reset_fifo:
   1101          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1102              unsigned char data;
   1103          
   1104              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_reset_fifo_0
   1105                  return -1;
   \                     ??mpu_reset_fifo_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_reset_fifo_2 & 0xFFFF
   1106          
   1107              data = 0;
   \                     ??mpu_reset_fifo_0:
   \   000016   12....       LCALL   ?Subroutine46 & 0xFFFF
   1108              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_301:
   \   000019   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   00001C   70F1         JNZ     ??mpu_reset_fifo_1
   1109                  return -1;
   1110              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   \   00001E                ; Setup parameters for call to function MPU_Write_Len
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_275:
   \   000027   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_161:
   \   00002A   70E3         JNZ     ??mpu_reset_fifo_1
   1111                  return -1;
   1112              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   00002C                ; Setup parameters for call to function MPU_Write_Len
   \   00002C   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   00002F   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_162:
   \   000032   70DB         JNZ     ??mpu_reset_fifo_1
   1113                  return -1;
   1114          
   1115              if (st.chip_cfg.dmp_on) {
   \   000034   90....       MOV     DPTR,#st + 29
   \   000037   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_251:
   \   00003A   6048         JZ      ??mpu_reset_fifo_3
   1116                  data = BIT_FIFO_RST | BIT_DMP_RST;
   \   00003C   740C         MOV     A,#0xc
   \   00003E   F0           MOVX    @DPTR,A
   1117                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   00003F                ; Setup parameters for call to function MPU_Write_Len
   \   00003F   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   000042   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000045   70C8         JNZ     ??mpu_reset_fifo_1
   1118                      return -1;
   1119                  delay_ms(50);
   \   000047                ; Setup parameters for call to function delay_ms
   \   000047   7A32         MOV     R2,#0x32
   \   000049   12....       LCALL   ?Subroutine60 & 0xFFFF
   1120                  data = BIT_DMP_EN | BIT_FIFO_EN;
   \                     ??CrossCallReturnLabel_81:
   \   00004C   74C0         MOV     A,#-0x40
   \   00004E   F0           MOVX    @DPTR,A
   1121                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   00004F   90....       MOV     DPTR,#st + 6
   \   000052   E0           MOVX    A,@DPTR
   \   000053   A2E0         MOV     C,0xE0 /* A   */.0
   \   000055   5009         JNC     ??mpu_reset_fifo_4
   1122                      data |= BIT_AUX_IF_EN;
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   74E0         MOV     A,#-0x20
   \   00005F   F0           MOVX    @DPTR,A
   1123                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \                     ??mpu_reset_fifo_4:
   \   000060                ; Setup parameters for call to function MPU_Write_Len
   \   000060   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_230:
   \   000063   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000066   70A7         JNZ     ??mpu_reset_fifo_1
   1124                      return -1;
   1125                  if (st.chip_cfg.int_enable)
   \   000068   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_254:
   \   00006B   6004         JZ      ??mpu_reset_fifo_5
   1126                      data = BIT_DMP_INT_EN;
   \   00006D   7402         MOV     A,#0x2
   \   00006F   8001         SJMP    ??mpu_reset_fifo_6
   1127                  else
   1128                      data = 0;
   \                     ??mpu_reset_fifo_5:
   \   000071   E4           CLR     A
   \                     ??mpu_reset_fifo_6:
   \   000072   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   1129                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_305:
   \   000075   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000078   7095         JNZ     ??mpu_reset_fifo_1
   1130                      return -1;
   1131                  data = 0;
   \   00007A   12....       LCALL   ?Subroutine31 & 0xFFFF
   1132                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
   1133                      return -1;
   1134              } else {
   \                     ??CrossCallReturnLabel_271:
   \   00007D   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000080   708D         JNZ     ??mpu_reset_fifo_1
   \   000082   8062         SJMP    ??mpu_reset_fifo_7
   1135                  data = BIT_FIFO_RST;
   \                     ??mpu_reset_fifo_3:
   \   000084   7404         MOV     A,#0x4
   \   000086   F0           MOVX    @DPTR,A
   1136                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   000087                ; Setup parameters for call to function MPU_Write_Len
   \   000087   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00008A   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_166:
   \   00008D   7080         JNZ     ??mpu_reset_fifo_1
   1137                      return -1;
   1138                  if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   \   00008F   90....       MOV     DPTR,#st + 13
   \   000092   E0           MOVX    A,@DPTR
   \   000093   7008         JNZ     ??mpu_reset_fifo_8
   \   000095   90....       MOV     DPTR,#st + 6
   \   000098   E0           MOVX    A,@DPTR
   \   000099   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009B   400A         JC      ??mpu_reset_fifo_9
   1139                      data = BIT_FIFO_EN;
   \                     ??mpu_reset_fifo_8:
   \   00009D   85..82       MOV     DPL,?XSP + 0
   \   0000A0   85..83       MOV     DPH,?XSP + 1
   \   0000A3   7440         MOV     A,#0x40
   \   0000A5   8008         SJMP    ??mpu_reset_fifo_10
   1140                  else
   1141                      data = BIT_FIFO_EN | BIT_AUX_IF_EN;
   \                     ??mpu_reset_fifo_9:
   \   0000A7   85..82       MOV     DPL,?XSP + 0
   \   0000AA   85..83       MOV     DPH,?XSP + 1
   \   0000AD   7460         MOV     A,#0x60
   \                     ??mpu_reset_fifo_10:
   \   0000AF   F0           MOVX    @DPTR,A
   1142                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
   \   0000B0                ; Setup parameters for call to function MPU_Write_Len
   \   0000B0   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   0000B3   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_167:
   \   0000B6   6003         JZ      $+5
   \   0000B8   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1143                      return -1;
   1144                  delay_ms(50);
   \   0000BB                ; Setup parameters for call to function delay_ms
   \   0000BB   7A32         MOV     R2,#0x32
   \   0000BD   7B00         MOV     R3,#0x0
   \   0000BF   12....       LCALL   ??delay_ms?relay
   1145                  if (st.chip_cfg.int_enable)
   \   0000C2   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_255:
   \   0000C5   6004         JZ      ??mpu_reset_fifo_11
   1146                      data = BIT_DATA_RDY_EN;
   \   0000C7   7401         MOV     A,#0x1
   \   0000C9   8001         SJMP    ??mpu_reset_fifo_12
   1147                  else
   1148                      data = 0;
   \                     ??mpu_reset_fifo_11:
   \   0000CB   E4           CLR     A
   \                     ??mpu_reset_fifo_12:
   \   0000CC   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   1149                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
   \                     ??CrossCallReturnLabel_306:
   \   0000CF   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   0000D2   6003         JZ      $+5
   \   0000D4   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1150                      return -1;
   1151                  if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
   \   0000D7                ; Setup parameters for call to function MPU_Write_Len
   \   0000D7   7C..         MOV     R4,#(st + 11) & 0xff
   \   0000D9   7D..         MOV     R5,#((st + 11) >> 8) & 0xff
   \   0000DB   12....       LCALL   ??Subroutine130_0 & 0xFFFF
   1152                      return -1;
   1153              }
   \                     ??CrossCallReturnLabel_274:
   \   0000DE   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_168:
   \   0000E1   6003         JZ      $+5
   \   0000E3   02....       LJMP    ??mpu_reset_fifo_1 & 0xFFFF
   1154              return 0;
   \                     ??mpu_reset_fifo_7:
   \   0000E6   7A00         MOV     R2,#0x0
   \   0000E8   7B00         MOV     R3,#0x0
   \                     ??mpu_reset_fifo_2:
   \   0000EA                REQUIRE ?Subroutine10
   \   0000EA                ; // Fall through to label ?Subroutine10
   1155          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   7401         MOV     A,#0x1
   \   000002   12....       LCALL   ?DEALLOC_XSTACK8
   \   000005   02....       LJMP    ??Subroutine124_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine116_0
   \   000006                ; // Fall through to label ??Subroutine116_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine116_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009                REQUIRE ??Subroutine117_0
   \   000009                ; // Fall through to label ??Subroutine117_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine117_0:
   \   000000   12....       LCALL   ?Subroutine78 & 0xFFFF
   \                     ??CrossCallReturnLabel_233:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   90....       MOV     DPTR,#st + 12
   \   000003                REQUIRE ??Subroutine121_0
   \   000003                ; // Fall through to label ??Subroutine121_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine121_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine124_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \   000007                REQUIRE ??Subroutine128_0
   \   000007                ; // Fall through to label ??Subroutine128_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine128_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine129_0
   \   000001                ; // Fall through to label ??Subroutine129_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine129_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004                REQUIRE ??Subroutine130_0
   \   000004                ; // Fall through to label ??Subroutine130_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine130_0:
   \   000000   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_278:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   7B01         MOV     R3,#0x1
   \   000002   90....       MOV     DPTR,#st
   \   000005   12....       LCALL   ?Subroutine98 & 0xFFFF
   \                     ??CrossCallReturnLabel_280:
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \   000007                REQUIRE ??Subroutine138_0
   \   000007                ; // Fall through to label ??Subroutine138_0
   1156          
   1157          /**
   1158           *  @brief      Get the gyro full-scale range.
   1159           *  @param[out] fsr Current full-scale range.
   1160           *  @return     0 if successful.
   1161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1162          int mpu_get_gyro_fsr(unsigned short *fsr)
   \                     mpu_get_gyro_fsr:
   1163          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1164              switch (st.chip_cfg.gyro_fsr) {
   \   000004   90....       MOV     DPTR,#st + 4
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_gyro_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6013         JZ      ??mpu_get_gyro_fsr_1
   \   00000D   14           DEC     A
   \   00000E   601C         JZ      ??mpu_get_gyro_fsr_2
   \   000010   14           DEC     A
   \   000011   6025         JZ      ??mpu_get_gyro_fsr_3
   \   000013   802F         SJMP    ??mpu_get_gyro_fsr_4
   1165              case INV_FSR_250DPS:
   1166                  fsr[0] = 250;
   \                     ??mpu_get_gyro_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   74FA         MOV     A,#-0x6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   E4           CLR     A
   \   00001E   802B         SJMP    ??mpu_get_gyro_fsr_5
   1167                  break;
   1168              case INV_FSR_500DPS:
   1169                  fsr[0] = 500;
   \                     ??mpu_get_gyro_fsr_1:
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   74F4         MOV     A,#-0xc
   \   000026   F0           MOVX    @DPTR,A
   \   000027   A3           INC     DPTR
   \   000028   7401         MOV     A,#0x1
   \   00002A   801F         SJMP    ??mpu_get_gyro_fsr_5
   1170                  break;
   1171              case INV_FSR_1000DPS:
   1172                  fsr[0] = 1000;
   \                     ??mpu_get_gyro_fsr_2:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   74E8         MOV     A,#-0x18
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   7403         MOV     A,#0x3
   \   000036   8013         SJMP    ??mpu_get_gyro_fsr_5
   1173                  break;
   1174              case INV_FSR_2000DPS:
   1175                  fsr[0] = 2000;
   \                     ??mpu_get_gyro_fsr_3:
   \   000038   8A82         MOV     DPL,R2
   \   00003A   8B83         MOV     DPH,R3
   \   00003C   74D0         MOV     A,#-0x30
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   7407         MOV     A,#0x7
   \   000042   8007         SJMP    ??mpu_get_gyro_fsr_5
   1176                  break;
   1177              default:
   1178                  fsr[0] = 0;
   \                     ??mpu_get_gyro_fsr_4:
   \   000044   8A82         MOV     DPL,R2
   \   000046   8B83         MOV     DPH,R3
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   1179                  break;
   1180              }
   \                     ??mpu_get_gyro_fsr_5:
   \   00004B   02....       LJMP    ??Subroutine122_0 & 0xFFFF
   1181              return 0;
   1182          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine122_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003                REQUIRE ??Subroutine123_0
   \   000003                ; // Fall through to label ??Subroutine123_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine123_0:
   \   000000   7B00         MOV     R3,#0x0
   \   000002                REQUIRE ??Subroutine124_0
   \   000002                ; // Fall through to label ??Subroutine124_0
   1183          
   1184          /**
   1185           *  @brief      Set the gyro full-scale range.
   1186           *  @param[in]  fsr Desired full-scale range.
   1187           *  @return     0 if successful.
   1188           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1189          int mpu_set_gyro_fsr(unsigned short fsr)
   \                     mpu_set_gyro_fsr:
   1190          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1191              unsigned char data;
   1192          
   1193              if (!(st.chip_cfg.sensors))
   \   00000A   90....       MOV     DPTR,#st + 6
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7006         JNZ     ??mpu_set_gyro_fsr_0
   1194                  return -1;
   \                     ??mpu_set_gyro_fsr_1:
   \   000010   7AFF         MOV     R2,#-0x1
   \   000012   7BFF         MOV     R3,#-0x1
   \   000014   8060         SJMP    ??mpu_set_gyro_fsr_2
   1195          
   1196              switch (fsr) {
   \                     ??mpu_set_gyro_fsr_0:
   \   000016   8A..         MOV     ?V0 + 0,R2
   \   000018   8B..         MOV     ?V0 + 1,R3
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for mpu_set_gyro_fsr>_0`:
   \   00001F   0000         DW        0
   \   000021   0400         DW        4
   \   000023   FA00         DW        250
   \   000025   ....         DW        ??mpu_set_gyro_fsr_3
   \   000027   F401         DW        500
   \   000029   ....         DW        ??mpu_set_gyro_fsr_4
   \   00002B   E803         DW        1000
   \   00002D   ....         DW        ??mpu_set_gyro_fsr_5
   \   00002F   D007         DW        2000
   \   000031   ....         DW        ??mpu_set_gyro_fsr_6
   \   000033   ....         DW        ??mpu_set_gyro_fsr_1
   1197              case 250:
   1198                  data = INV_FSR_250DPS << 3;
   \                     ??mpu_set_gyro_fsr_3:
   \   000035   85..82       MOV     DPL,?XSP + 0
   \   000038   85..83       MOV     DPH,?XSP + 1
   \   00003B   E4           CLR     A
   \   00003C   801C         SJMP    ??mpu_set_gyro_fsr_7
   1199                  break;
   1200              case 500:
   1201                  data = INV_FSR_500DPS << 3;
   \                     ??mpu_set_gyro_fsr_4:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7408         MOV     A,#0x8
   \   000046   8012         SJMP    ??mpu_set_gyro_fsr_7
   1202                  break;
   1203              case 1000:
   1204                  data = INV_FSR_1000DPS << 3;
   \                     ??mpu_set_gyro_fsr_5:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7410         MOV     A,#0x10
   \   000050   8008         SJMP    ??mpu_set_gyro_fsr_7
   1205                  break;
   1206              case 2000:
   1207                  data = INV_FSR_2000DPS << 3;
   \                     ??mpu_set_gyro_fsr_6:
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   7418         MOV     A,#0x18
   \                     ??mpu_set_gyro_fsr_7:
   \   00005A   F0           MOVX    @DPTR,A
   1208                  break;
   1209              default:
   1210                  return -1;
   1211              }
   1212          
   1213              if (st.chip_cfg.gyro_fsr == (data >> 3))
   \   00005B   90....       MOV     DPTR,#st + 4
   \   00005E   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000061   600F         JZ      ??mpu_set_gyro_fsr_8
   1214                  return 0;
   1215              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
   \   000063                ; Setup parameters for call to function MPU_Write_Len
   \   000063   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000066   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_169:
   \   000069   70A5         JNZ     ??mpu_set_gyro_fsr_1
   1216                  return -1;
   1217              st.chip_cfg.gyro_fsr = data >> 3;
   \   00006B   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_235:
   \   00006E   90....       MOV     DPTR,#st + 4
   \   000071   F0           MOVX    @DPTR,A
   1218              return 0;
   \                     ??mpu_set_gyro_fsr_8:
   \   000072   7A00         MOV     R2,#0x0
   \   000074   7B00         MOV     R3,#0x0
   \                     ??mpu_set_gyro_fsr_2:
   \   000076   02....       LJMP    ?Subroutine1 & 0xFFFF
   1219          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine88:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine118_0
   \   000006                ; // Fall through to label ??Subroutine118_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine118_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   13           RRC     A
   \   000002   13           RRC     A
   \   000003   13           RRC     A
   \   000004   541F         ANL     A,#0x1f
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000003   A2E7         MOV     C,0xE0 /* A   */.7
   \   000005   13           RRC     A
   \   000006   A2E7         MOV     C,0xE0 /* A   */.7
   \   000008   13           RRC     A
   \   000009   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000B   13           RRC     A
   \   00000C   68           XRL     A,R0
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine85:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   E0           MOVX    A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   12....       LCALL   ?Subroutine77 & 0xFFFF
   \                     ??CrossCallReturnLabel_277:
   \   000007   A3           INC     DPTR
   \   000008   22           RET
   1220          
   1221          /**
   1222           *  @brief      Get the accel full-scale range.
   1223           *  @param[out] fsr Current full-scale range.
   1224           *  @return     0 if successful.
   1225           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1226          int mpu_get_accel_fsr(unsigned char *fsr)
   \                     mpu_get_accel_fsr:
   1227          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1228              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_fsr_0
   \   00000A   14           DEC     A
   \   00000B   6024         JZ      ??mpu_get_accel_fsr_1
   \   00000D   14           DEC     A
   \   00000E   6029         JZ      ??mpu_get_accel_fsr_2
   \   000010   14           DEC     A
   \   000011   602E         JZ      ??mpu_get_accel_fsr_3
   \   000013   8034         SJMP    ??mpu_get_accel_fsr_4
   1229              case INV_FSR_2G:
   1230                  fsr[0] = 2;
   \                     ??mpu_get_accel_fsr_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   7402         MOV     A,#0x2
   \                     ??mpu_get_accel_fsr_5:
   \   00001B   F0           MOVX    @DPTR,A
   1231                  break;
   1232              case INV_FSR_4G:
   1233                  fsr[0] = 4;
   1234                  break;
   1235              case INV_FSR_8G:
   1236                  fsr[0] = 8;
   1237                  break;
   1238              case INV_FSR_16G:
   1239                  fsr[0] = 16;
   1240                  break;
   1241              default:
   1242                  return -1;
   1243              }
   1244              if (st.chip_cfg.accel_half)
   \   00001C   90....       MOV     DPTR,#st + 14
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6008         JZ      ??mpu_get_accel_fsr_6
   1245                  fsr[0] <<= 1;
   \   000022   8A82         MOV     DPL,R2
   \   000024   8B83         MOV     DPH,R3
   \   000026   E0           MOVX    A,@DPTR
   \   000027   C3           CLR     C
   \   000028   33           RLC     A
   \   000029   F0           MOVX    @DPTR,A
   1246              return 0;
   \                     ??mpu_get_accel_fsr_6:
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_fsr_7:
   \   00002E   02....       LJMP    ??Subroutine124_0 & 0xFFFF
   \                     ??mpu_get_accel_fsr_1:
   \   000031   8A82         MOV     DPL,R2
   \   000033   8B83         MOV     DPH,R3
   \   000035   7404         MOV     A,#0x4
   \   000037   80E2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_2:
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   7408         MOV     A,#0x8
   \   00003F   80DA         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_3:
   \   000041   8A82         MOV     DPL,R2
   \   000043   8B83         MOV     DPH,R3
   \   000045   7410         MOV     A,#0x10
   \   000047   80D2         SJMP    ??mpu_get_accel_fsr_5
   \                     ??mpu_get_accel_fsr_4:
   \   000049   7AFF         MOV     R2,#-0x1
   \   00004B   7BFF         MOV     R3,#-0x1
   \   00004D   80DF         SJMP    ??mpu_get_accel_fsr_7
   1247          }
   1248          
   1249          /**
   1250           *  @brief      Set the accel full-scale range.
   1251           *  @param[in]  fsr Desired full-scale range.
   1252           *  @return     0 if successful.
   1253           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1254          int mpu_set_accel_fsr(unsigned char fsr)
   \                     mpu_set_accel_fsr:
   1255          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1256              unsigned char data;
   1257          
   1258              if (!(st.chip_cfg.sensors))
   \   00000C   90....       MOV     DPTR,#st + 6
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7006         JNZ     ??mpu_set_accel_fsr_0
   1259                  return -1;
   \                     ??mpu_set_accel_fsr_1:
   \   000012   7AFF         MOV     R2,#-0x1
   \   000014   7BFF         MOV     R3,#-0x1
   \   000016   8054         SJMP    ??mpu_set_accel_fsr_2
   1260          
   1261              switch (fsr) {
   \                     ??mpu_set_accel_fsr_0:
   \   000018   EE           MOV     A,R6
   \   000019   24FE         ADD     A,#-0x2
   \   00001B   600E         JZ      ??mpu_set_accel_fsr_3
   \   00001D   24FE         ADD     A,#-0x2
   \   00001F   6013         JZ      ??mpu_set_accel_fsr_4
   \   000021   24FC         ADD     A,#-0x4
   \   000023   6019         JZ      ??mpu_set_accel_fsr_5
   \   000025   24F8         ADD     A,#-0x8
   \   000027   601F         JZ      ??mpu_set_accel_fsr_6
   \   000029   80E7         SJMP    ??mpu_set_accel_fsr_1
   1262              case 2:
   1263                  data = INV_FSR_2G << 3;
   \                     ??mpu_set_accel_fsr_3:
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   E4           CLR     A
   \   000032   801C         SJMP    ??mpu_set_accel_fsr_7
   1264                  break;
   1265              case 4:
   1266                  data = INV_FSR_4G << 3;
   \                     ??mpu_set_accel_fsr_4:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   7408         MOV     A,#0x8
   \   00003C   8012         SJMP    ??mpu_set_accel_fsr_7
   1267                  break;
   1268              case 8:
   1269                  data = INV_FSR_8G << 3;
   \                     ??mpu_set_accel_fsr_5:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   7410         MOV     A,#0x10
   \   000046   8008         SJMP    ??mpu_set_accel_fsr_7
   1270                  break;
   1271              case 16:
   1272                  data = INV_FSR_16G << 3;
   \                     ??mpu_set_accel_fsr_6:
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   7418         MOV     A,#0x18
   \                     ??mpu_set_accel_fsr_7:
   \   000050   F0           MOVX    @DPTR,A
   1273                  break;
   1274              default:
   1275                  return -1;
   1276              }
   1277          
   1278              if (st.chip_cfg.accel_fsr == (data >> 3))
   \   000051   90....       MOV     DPTR,#st + 5
   \   000054   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000057   600F         JZ      ??mpu_set_accel_fsr_8
   1279                  return 0;
   1280              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
   \   000059                ; Setup parameters for call to function MPU_Write_Len
   \   000059   12....       LCALL   ??Subroutine131_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_283:
   \   00005C   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_170:
   \   00005F   70B1         JNZ     ??mpu_set_accel_fsr_1
   1281                  return -1;
   1282              st.chip_cfg.accel_fsr = data >> 3;
   \   000061   12....       LCALL   ?Subroutine88 & 0xFFFF
   \                     ??CrossCallReturnLabel_236:
   \   000064   90....       MOV     DPTR,#st + 5
   \   000067   F0           MOVX    @DPTR,A
   1283              return 0;
   \                     ??mpu_set_accel_fsr_8:
   \   000068   7A00         MOV     R2,#0x0
   \   00006A   7B00         MOV     R3,#0x0
   \                     ??mpu_set_accel_fsr_2:
   \   00006C   02....       LJMP    ?Subroutine0 & 0xFFFF
   1284          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine131_0:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   7B01         MOV     R3,#0x1
   \   000006   90....       MOV     DPTR,#st
   \   000009   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_290:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_293:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine97:
   \   000000   12....       LCALL   ?Subroutine103 & 0xFFFF
   \                     ??CrossCallReturnLabel_295:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   22           RET
   1285          
   1286          /**
   1287           *  @brief      Get the current DLPF setting.
   1288           *  @param[out] lpf Current LPF setting.
   1289           *  0 if successful.
   1290           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1291          int mpu_get_lpf(unsigned short *lpf)
   \                     mpu_get_lpf:
   1292          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1293              switch (st.chip_cfg.lpf) {
   \   000004   90....       MOV     DPTR,#st + 7
   \   000007   E0           MOVX    A,@DPTR
   \   000008   14           DEC     A
   \   000009   6011         JZ      ??mpu_get_lpf_0
   \   00000B   14           DEC     A
   \   00000C   6019         JZ      ??mpu_get_lpf_1
   \   00000E   14           DEC     A
   \   00000F   601E         JZ      ??mpu_get_lpf_2
   \   000011   14           DEC     A
   \   000012   6023         JZ      ??mpu_get_lpf_3
   \   000014   14           DEC     A
   \   000015   6028         JZ      ??mpu_get_lpf_4
   \   000017   14           DEC     A
   \   000018   602D         JZ      ??mpu_get_lpf_5
   \   00001A   8033         SJMP    ??mpu_get_lpf_6
   1294              case INV_FILTER_188HZ:
   1295                  lpf[0] = 188;
   \                     ??mpu_get_lpf_0:
   \   00001C   8A82         MOV     DPL,R2
   \   00001E   8B83         MOV     DPH,R3
   \   000020   74BC         MOV     A,#-0x44
   \                     ??mpu_get_lpf_7:
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   E4           CLR     A
   \   000025   802F         SJMP    ??mpu_get_lpf_8
   1296                  break;
   1297              case INV_FILTER_98HZ:
   1298                  lpf[0] = 98;
   \                     ??mpu_get_lpf_1:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   7462         MOV     A,#0x62
   \   00002D   80F3         SJMP    ??mpu_get_lpf_7
   1299                  break;
   1300              case INV_FILTER_42HZ:
   1301                  lpf[0] = 42;
   \                     ??mpu_get_lpf_2:
   \   00002F   8A82         MOV     DPL,R2
   \   000031   8B83         MOV     DPH,R3
   \   000033   742A         MOV     A,#0x2a
   \   000035   80EB         SJMP    ??mpu_get_lpf_7
   1302                  break;
   1303              case INV_FILTER_20HZ:
   1304                  lpf[0] = 20;
   \                     ??mpu_get_lpf_3:
   \   000037   8A82         MOV     DPL,R2
   \   000039   8B83         MOV     DPH,R3
   \   00003B   7414         MOV     A,#0x14
   \   00003D   80E3         SJMP    ??mpu_get_lpf_7
   1305                  break;
   1306              case INV_FILTER_10HZ:
   1307                  lpf[0] = 10;
   \                     ??mpu_get_lpf_4:
   \   00003F   8A82         MOV     DPL,R2
   \   000041   8B83         MOV     DPH,R3
   \   000043   740A         MOV     A,#0xa
   \   000045   80DB         SJMP    ??mpu_get_lpf_7
   1308                  break;
   1309              case INV_FILTER_5HZ:
   1310                  lpf[0] = 5;
   \                     ??mpu_get_lpf_5:
   \   000047   8A82         MOV     DPL,R2
   \   000049   8B83         MOV     DPH,R3
   \   00004B   7405         MOV     A,#0x5
   \   00004D   80D3         SJMP    ??mpu_get_lpf_7
   1311                  break;
   1312              case INV_FILTER_256HZ_NOLPF2:
   1313              case INV_FILTER_2100HZ_NOLPF:
   1314              default:
   1315                  lpf[0] = 0;
   \                     ??mpu_get_lpf_6:
   \   00004F   8A82         MOV     DPL,R2
   \   000051   8B83         MOV     DPH,R3
   \   000053   E4           CLR     A
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   1316                  break;
   1317              }
   \                     ??mpu_get_lpf_8:
   \   000056   02....       LJMP    ??Subroutine122_0 & 0xFFFF
   1318              return 0;
   1319          }
   1320          
   1321          /**
   1322           *  @brief      Set digital low pass filter.
   1323           *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
   1324           *  @param[in]  lpf Desired LPF setting.
   1325           *  @return     0 if successful.
   1326           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1327          int mpu_set_lpf(unsigned short lpf)
   \                     mpu_set_lpf:
   1328          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1329              unsigned char data;
   1330          
   1331              if (!(st.chip_cfg.sensors))
   \   000009   90....       MOV     DPTR,#st + 6
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   7007         JNZ     ??mpu_set_lpf_0
   1332                  return -1;
   \                     ??mpu_set_lpf_1:
   \   00000F   7AFF         MOV     R2,#-0x1
   \   000011   7BFF         MOV     R3,#-0x1
   \   000013   02....       LJMP    ??mpu_set_lpf_2 & 0xFFFF
   1333          
   1334              if (lpf >= 188)
   \                     ??mpu_set_lpf_0:
   \   000016   C3           CLR     C
   \   000017   EA           MOV     A,R2
   \   000018   94BC         SUBB    A,#-0x44
   \   00001A   EB           MOV     A,R3
   \   00001B   9400         SUBB    A,#0x0
   \   00001D   400A         JC      ??mpu_set_lpf_3
   1335                  data = INV_FILTER_188HZ;
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   7401         MOV     A,#0x1
   \   000027   804E         SJMP    ??mpu_set_lpf_4
   1336              else if (lpf >= 98)
   \                     ??mpu_set_lpf_3:
   \   000029   C3           CLR     C
   \   00002A   EA           MOV     A,R2
   \   00002B   9462         SUBB    A,#0x62
   \   00002D   EB           MOV     A,R3
   \   00002E   9400         SUBB    A,#0x0
   \   000030   400A         JC      ??mpu_set_lpf_5
   1337                  data = INV_FILTER_98HZ;
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   7402         MOV     A,#0x2
   \   00003A   803B         SJMP    ??mpu_set_lpf_4
   1338              else if (lpf >= 42)
   \                     ??mpu_set_lpf_5:
   \   00003C   C3           CLR     C
   \   00003D   EA           MOV     A,R2
   \   00003E   942A         SUBB    A,#0x2a
   \   000040   EB           MOV     A,R3
   \   000041   9400         SUBB    A,#0x0
   \   000043   400A         JC      ??mpu_set_lpf_6
   1339                  data = INV_FILTER_42HZ;
   \   000045   85..82       MOV     DPL,?XSP + 0
   \   000048   85..83       MOV     DPH,?XSP + 1
   \   00004B   7403         MOV     A,#0x3
   \   00004D   8028         SJMP    ??mpu_set_lpf_4
   1340              else if (lpf >= 20)
   \                     ??mpu_set_lpf_6:
   \   00004F   C3           CLR     C
   \   000050   EA           MOV     A,R2
   \   000051   9414         SUBB    A,#0x14
   \   000053   EB           MOV     A,R3
   \   000054   9400         SUBB    A,#0x0
   \   000056   400A         JC      ??mpu_set_lpf_7
   1341                  data = INV_FILTER_20HZ;
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   7404         MOV     A,#0x4
   \   000060   8015         SJMP    ??mpu_set_lpf_4
   1342              else if (lpf >= 10)
   \                     ??mpu_set_lpf_7:
   \   000062   C3           CLR     C
   \   000063   EA           MOV     A,R2
   \   000064   940A         SUBB    A,#0xa
   \   000066   EB           MOV     A,R3
   \   000067   9400         SUBB    A,#0x0
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   4004         JC      ??mpu_set_lpf_8
   1343                  data = INV_FILTER_10HZ;
   \   000071   7405         MOV     A,#0x5
   \   000073   8002         SJMP    ??mpu_set_lpf_4
   1344              else
   1345                  data = INV_FILTER_5HZ;
   \                     ??mpu_set_lpf_8:
   \   000075   7406         MOV     A,#0x6
   \                     ??mpu_set_lpf_4:
   \   000077   F0           MOVX    @DPTR,A
   1346          
   1347              if (st.chip_cfg.lpf == data)
   \   000078   90....       MOV     DPTR,#st + 7
   \   00007B   12....       LCALL   ?Subroutine85 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   00007E   68           XRL     A,R0
   \   00007F   6013         JZ      ??mpu_set_lpf_9
   1348                  return 0;
   1349              if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
   \   000081                ; Setup parameters for call to function MPU_Write_Len
   \   000081   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   000084   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_171:
   \   000087   7086         JNZ     ??mpu_set_lpf_1
   1350                  return -1;
   1351              st.chip_cfg.lpf = data;
   \   000089   85..82       MOV     DPL,?XSP + 0
   \   00008C   85..83       MOV     DPH,?XSP + 1
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   90....       MOV     DPTR,#st + 7
   \   000093   F0           MOVX    @DPTR,A
   1352              return 0;
   \                     ??mpu_set_lpf_9:
   \   000094   7A00         MOV     R2,#0x0
   \   000096   7B00         MOV     R3,#0x0
   \                     ??mpu_set_lpf_2:
   \   000098   02....       LJMP    ?Subroutine10 & 0xFFFF
   1353          }
   1354          
   1355          /**
   1356           *  @brief      Get sampling rate.
   1357           *  @param[out] rate    Current sampling rate (Hz).
   1358           *  @return     0 if successful.
   1359           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1360          int mpu_get_sample_rate(unsigned short *rate)
   \                     mpu_get_sample_rate:
   1361          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1362              if (st.chip_cfg.dmp_on)
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6006         JZ      ??mpu_get_sample_rate_0
   1363                  return -1;
   \   00000A   7AFF         MOV     R2,#-0x1
   \   00000C   7BFF         MOV     R3,#-0x1
   \   00000E   8010         SJMP    ??CrossCallReturnLabel_296
   1364              else
   1365                  rate[0] = st.chip_cfg.sample_rate;
   \                     ??mpu_get_sample_rate_0:
   \   000010   90....       MOV     DPTR,#st + 9
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F8           MOV     R0,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F9           MOV     R1,A
   \   000018   8A82         MOV     DPL,R2
   \   00001A   8B83         MOV     DPH,R3
   \   00001C   E8           MOV     A,R0
   \   00001D   12....       LCALL   ?Subroutine53 & 0xFFFF
   1366              return 0;
   \                     ??CrossCallReturnLabel_296:
   \   000020   02....       LJMP    ??Subroutine124_0 & 0xFFFF
   1367          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   A3           INC     DPTR
   \   000002   E9           MOV     A,R1
   \   000003                REQUIRE ??Subroutine137_0
   \   000003                ; // Fall through to label ??Subroutine137_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine137_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   7A00         MOV     R2,#0x0
   \   000003   7B00         MOV     R3,#0x0
   \   000005   22           RET
   1368          
   1369          /**
   1370           *  @brief      Set sampling rate.
   1371           *  Sampling rate must be between 4Hz and 1kHz.
   1372           *  @param[in]  rate    Desired sampling rate (Hz).
   1373           *  @return     0 if successful.
   1374           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1375          int mpu_set_sample_rate(unsigned short rate)
   \                     mpu_set_sample_rate:
   1376          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1377              unsigned char data;
   1378          
   1379              if (!(st.chip_cfg.sensors))
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7007         JNZ     ??mpu_set_sample_rate_0
   1380                  return -1;
   \                     ??mpu_set_sample_rate_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   02....       LJMP    ??mpu_set_sample_rate_2 & 0xFFFF
   1381          
   1382              if (st.chip_cfg.dmp_on)
   \                     ??mpu_set_sample_rate_0:
   \   00001B   90....       MOV     DPTR,#st + 29
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70F3         JNZ     ??mpu_set_sample_rate_1
   1383                  return -1;
   1384              else {
   1385                  if (st.chip_cfg.lp_accel_mode) {
   \   000021   90....       MOV     DPTR,#st + 15
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6019         JZ      ??mpu_set_sample_rate_3
   1386                      if (rate && (rate <= 40)) {
   \   000027   EE           MOV     A,R6
   \   000028   4F           ORL     A,R7
   \   000029   6010         JZ      ??mpu_set_sample_rate_4
   \   00002B   C3           CLR     C
   \   00002C   EE           MOV     A,R6
   \   00002D   9429         SUBB    A,#0x29
   \   00002F   EF           MOV     A,R7
   \   000030   9400         SUBB    A,#0x0
   \   000032   5007         JNC     ??mpu_set_sample_rate_4
   1387                          /* Just stay in low-power accel mode. */
   1388                          mpu_lp_accel_mode(rate);
   \   000034                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \   000036   12....       LCALL   ??mpu_lp_accel_mode?relay
   1389                          return 0;
   \   000039   806F         SJMP    ??mpu_set_sample_rate_5
   1390                      }
   1391                      /* Requested rate exceeds the allowed frequencies in LP accel mode,
   1392                       * switch back to full-power mode.
   1393                       */
   1394                      mpu_lp_accel_mode(0);
   \                     ??mpu_set_sample_rate_4:
   \   00003B                ; Setup parameters for call to function mpu_lp_accel_mode
   \   00003B   7900         MOV     R1,#0x0
   \   00003D   12....       LCALL   ??mpu_lp_accel_mode?relay
   1395                  }
   1396                  if (rate < 4)
   \                     ??mpu_set_sample_rate_3:
   \   000040   C3           CLR     C
   \   000041   EE           MOV     A,R6
   \   000042   9404         SUBB    A,#0x4
   \   000044   EF           MOV     A,R7
   \   000045   9400         SUBB    A,#0x0
   \   000047   5006         JNC     ??mpu_set_sample_rate_6
   1397                      rate = 4;
   \   000049   7E04         MOV     R6,#0x4
   \   00004B   7F00         MOV     R7,#0x0
   \   00004D   800D         SJMP    ??mpu_set_sample_rate_7
   1398                  else if (rate > 1000)
   \                     ??mpu_set_sample_rate_6:
   \   00004F   C3           CLR     C
   \   000050   EE           MOV     A,R6
   \   000051   94E9         SUBB    A,#-0x17
   \   000053   EF           MOV     A,R7
   \   000054   9403         SUBB    A,#0x3
   \   000056   4004         JC      ??mpu_set_sample_rate_7
   1399                      rate = 1000;
   \   000058   7EE8         MOV     R6,#-0x18
   \   00005A   7F03         MOV     R7,#0x3
   1400          
   1401                  data = 1000 / rate - 1;
   \                     ??mpu_set_sample_rate_7:
   \   00005C   78E8         MOV     R0,#-0x18
   \   00005E   7903         MOV     R1,#0x3
   \   000060   EE           MOV     A,R6
   \   000061   FA           MOV     R2,A
   \   000062   EF           MOV     A,R7
   \   000063   FB           MOV     R3,A
   \   000064   12....       LCALL   ?US_DIV_MOD
   \   000067   E8           MOV     A,R0
   \   000068   14           DEC     A
   \   000069   85..82       MOV     DPL,?XSP + 0
   \   00006C   85..83       MOV     DPH,?XSP + 1
   \   00006F   12....       LCALL   ?Subroutine50 & 0xFFFF
   1402                  if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
   \                     ??CrossCallReturnLabel_66:
   \   000072   90....       MOV     DPTR,#st
   \   000075   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_321:
   \   000078   A3           INC     DPTR
   \   000079   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_172:
   \   00007C   7096         JNZ     ??mpu_set_sample_rate_1
   1403                      return -1;
   1404          
   1405                  st.chip_cfg.sample_rate = 1000 / (1 + data);
   \   00007E   78E8         MOV     R0,#-0x18
   \   000080   7903         MOV     R1,#0x3
   \   000082   85..82       MOV     DPL,?XSP + 0
   \   000085   85..83       MOV     DPH,?XSP + 1
   \   000088   E0           MOVX    A,@DPTR
   \   000089   2401         ADD     A,#0x1
   \   00008B   FA           MOV     R2,A
   \   00008C   E4           CLR     A
   \   00008D   3400         ADDC    A,#0x0
   \   00008F   FB           MOV     R3,A
   \   000090   12....       LCALL   ?S_DIV_MOD
   \   000093   90....       MOV     DPTR,#st + 9
   \   000096   E8           MOV     A,R0
   \   000097   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   1406          
   1407          #ifdef AK89xx_SECONDARY
   1408                  mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
   1409          #endif
   1410          
   1411                  /* Automatically set LPF to 1/2 sampling rate. */
   1412                  mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
   \                     ??CrossCallReturnLabel_242:
   \   00009A                ; Setup parameters for call to function mpu_set_lpf
   \   00009A   90....       MOV     DPTR,#st + 9
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   FA           MOV     R2,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   C3           CLR     C
   \   0000A2   13           RRC     A
   \   0000A3   FB           MOV     R3,A
   \   0000A4   EA           MOV     A,R2
   \   0000A5   13           RRC     A
   \   0000A6   FA           MOV     R2,A
   \   0000A7   12....       LCALL   ??mpu_set_lpf?relay
   1413                  return 0;
   \                     ??mpu_set_sample_rate_5:
   \   0000AA   7A00         MOV     R2,#0x0
   \   0000AC   7B00         MOV     R3,#0x0
   1414              }
   \                     ??mpu_set_sample_rate_2:
   \   0000AE   02....       LJMP    ?Subroutine0 & 0xFFFF
   1415          }
   1416          
   1417          /**
   1418           *  @brief      Get compass sampling rate.
   1419           *  @param[out] rate    Current compass sampling rate (Hz).
   1420           *  @return     0 if successful.
   1421           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1422          int mpu_get_compass_sample_rate(unsigned short *rate)
   \                     mpu_get_compass_sample_rate:
   1423          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1424          #ifdef AK89xx_SECONDARY
   1425              rate[0] = st.chip_cfg.compass_sample_rate;
   1426              return 0;
   1427          #else
   1428              rate[0] = 0;
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
   \   00000A   A3           INC     DPTR
   \   00000B   F0           MOVX    @DPTR,A
   1429              return -1;
   \   00000C   7AFF         MOV     R2,#-0x1
   \   00000E   7BFF         MOV     R3,#-0x1
   \   000010   02....       LJMP    ??Subroutine124_0 & 0xFFFF
   1430          #endif
   1431          }
   1432          
   1433          /**
   1434           *  @brief      Set compass sampling rate.
   1435           *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
   1436           *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
   1437           *  sampling rate.
   1438           *
   1439           *  \n WARNING: The new rate may be different than what was requested. Call
   1440           *  mpu_get_compass_sample_rate to check the actual setting.
   1441           *  @param[in]  rate    Desired compass sampling rate (Hz).
   1442           *  @return     0 if successful.
   1443           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1444          int mpu_set_compass_sample_rate(unsigned short rate)
   \                     mpu_set_compass_sample_rate:
   1445          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1446          #ifdef AK89xx_SECONDARY
   1447              unsigned char div;
   1448              if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
   1449                  return -1;
   1450          
   1451              div = st.chip_cfg.sample_rate / rate - 1;
   1452              if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
   1453                  return -1;
   1454              st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
   1455              return 0;
   1456          #else
   1457              return -1;
   \   000000   02....       LJMP    ?Subroutine4 & 0xFFFF
   1458          #endif
   1459          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   7AFF         MOV     R2,#-0x1
   \   000002   7BFF         MOV     R3,#-0x1
   \   000004   02....       LJMP    ?BRET
   1460          
   1461          /**
   1462           *  @brief      Get gyro sensitivity scale factor.
   1463           *  @param[out] sens    Conversion from hardware units to dps.
   1464           *  @return     0 if successful.
   1465           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1466          int mpu_get_gyro_sens(float *sens)
   \                     mpu_get_gyro_sens:
   1467          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
   1468              switch (st.chip_cfg.gyro_fsr) {
   \   000009   90....       MOV     DPTR,#st + 4
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   600B         JZ      ??mpu_get_gyro_sens_0
   \   00000F   14           DEC     A
   \   000010   601C         JZ      ??mpu_get_gyro_sens_1
   \   000012   14           DEC     A
   \   000013   601E         JZ      ??mpu_get_gyro_sens_2
   \   000015   14           DEC     A
   \   000016   6020         JZ      ??mpu_get_gyro_sens_3
   \   000018   8023         SJMP    ??mpu_get_gyro_sens_4
   1469              case INV_FSR_250DPS:
   1470                  sens[0] = 131.f;
   \                     ??mpu_get_gyro_sens_0:
   \   00001A   90....       MOV     DPTR,#__Constant_43030000
   \                     ??mpu_get_gyro_sens_5:
   \   00001D   12....       LCALL   ?XLOAD_R2345
   \   000020   8882         MOV     DPL,R0
   \   000022   8983         MOV     DPH,R1
   \   000024   12....       LCALL   ?XSTORE_R2345
   1471                  break;
   1472              case INV_FSR_500DPS:
   1473                  sens[0] = 65.5f;
   1474                  break;
   1475              case INV_FSR_1000DPS:
   1476                  sens[0] = 32.8f;
   1477                  break;
   1478              case INV_FSR_2000DPS:
   1479                  sens[0] = 16.4f;
   1480                  break;
   1481              default:
   1482                  return -1;
   1483              }
   1484              return 0;
   \   000027   7A00         MOV     R2,#0x0
   \   000029   7B00         MOV     R3,#0x0
   \                     ??mpu_get_gyro_sens_6:
   \   00002B   02....       LJMP    ??Subroutine112_0 & 0xFFFF
   \                     ??mpu_get_gyro_sens_1:
   \   00002E   90....       MOV     DPTR,#__Constant_42830000
   \   000031   80EA         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_2:
   \   000033   90....       MOV     DPTR,#__Constant_42033333
   \   000036   80E5         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_3:
   \   000038   90....       MOV     DPTR,#__Constant_41833333
   \   00003B   80E0         SJMP    ??mpu_get_gyro_sens_5
   \                     ??mpu_get_gyro_sens_4:
   \   00003D   7AFF         MOV     R2,#-0x1
   \   00003F   7BFF         MOV     R3,#-0x1
   \   000041   80E8         SJMP    ??mpu_get_gyro_sens_6
   1485          }
   1486          
   1487          /**
   1488           *  @brief      Get accel sensitivity scale factor.
   1489           *  @param[out] sens    Conversion from hardware units to g's.
   1490           *  @return     0 if successful.
   1491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1492          int mpu_get_accel_sens(unsigned short *sens)
   \                     mpu_get_accel_sens:
   1493          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1494              switch (st.chip_cfg.accel_fsr) {
   \   000004   90....       MOV     DPTR,#st + 5
   \   000007   E0           MOVX    A,@DPTR
   \   000008   600B         JZ      ??mpu_get_accel_sens_0
   \   00000A   14           DEC     A
   \   00000B   602D         JZ      ??mpu_get_accel_sens_1
   \   00000D   14           DEC     A
   \   00000E   6036         JZ      ??mpu_get_accel_sens_2
   \   000010   14           DEC     A
   \   000011   603E         JZ      ??mpu_get_accel_sens_3
   \   000013   8047         SJMP    ??mpu_get_accel_sens_4
   1495              case INV_FSR_2G:
   1496                  sens[0] = 16384;
   \                     ??mpu_get_accel_sens_0:
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   E4           CLR     A
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7440         MOV     A,#0x40
   \                     ??mpu_get_accel_sens_5:
   \   00001E   F0           MOVX    @DPTR,A
   1497                  break;
   1498              case INV_FSR_4G:
   1499                  sens[0] = 8092;
   1500                  break;
   1501              case INV_FSR_8G:
   1502                  sens[0] = 4096;
   1503                  break;
   1504              case INV_FSR_16G:
   1505                  sens[0] = 2048;
   1506                  break;
   1507              default:
   1508                  return -1;
   1509              }
   1510              if (st.chip_cfg.accel_half)
   \   00001F   90....       MOV     DPTR,#st + 14
   \   000022   E0           MOVX    A,@DPTR
   \   000023   600E         JZ      ??CrossCallReturnLabel_243
   1511                  sens[0] >>= 1;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   00002C   8A82         MOV     DPL,R2
   \   00002E   8B83         MOV     DPH,R3
   \   000030   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   1512              return 0;
   \                     ??CrossCallReturnLabel_243:
   \   000033   7A00         MOV     R2,#0x0
   \   000035   7B00         MOV     R3,#0x0
   \                     ??mpu_get_accel_sens_6:
   \   000037   02....       LJMP    ??Subroutine124_0 & 0xFFFF
   \                     ??mpu_get_accel_sens_1:
   \   00003A   8A82         MOV     DPL,R2
   \   00003C   8B83         MOV     DPH,R3
   \   00003E   749C         MOV     A,#-0x64
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   741F         MOV     A,#0x1f
   \   000044   80D8         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_2:
   \   000046   8A82         MOV     DPL,R2
   \   000048   8B83         MOV     DPH,R3
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   7410         MOV     A,#0x10
   \   00004F   80CD         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_3:
   \   000051   8A82         MOV     DPL,R2
   \   000053   8B83         MOV     DPH,R3
   \   000055   E4           CLR     A
   \   000056   F0           MOVX    @DPTR,A
   \   000057   A3           INC     DPTR
   \   000058   7408         MOV     A,#0x8
   \   00005A   80C2         SJMP    ??mpu_get_accel_sens_5
   \                     ??mpu_get_accel_sens_4:
   \   00005C   7AFF         MOV     R2,#-0x1
   \   00005E   7BFF         MOV     R3,#-0x1
   \   000060   80D5         SJMP    ??mpu_get_accel_sens_6
   1513          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine84:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C3           CLR     C
   \   000005   13           RRC     A
   \   000006   F9           MOV     R1,A
   \   000007   E8           MOV     A,R0
   \   000008   13           RRC     A
   \   000009   22           RET
   1514          
   1515          /**
   1516           *  @brief      Get current FIFO configuration.
   1517           *  @e sensors can contain a combination of the following flags:
   1518           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1519           *  \n INV_XYZ_GYRO
   1520           *  \n INV_XYZ_ACCEL
   1521           *  @param[out] sensors Mask of sensors in FIFO.
   1522           *  @return     0 if successful.
   1523           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1524          int mpu_get_fifo_config(unsigned char *sensors)
   \                     mpu_get_fifo_config:
   1525          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1526              sensors[0] = st.chip_cfg.fifo_enable;
   \   000004   90....       MOV     DPTR,#st + 11
   \   000007   02....       LJMP    ?Subroutine3 & 0xFFFF
   1527              return 0;
   1528          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005                REQUIRE ??Subroutine122_0
   \   000005                ; // Fall through to label ??Subroutine122_0
   1529          
   1530          /**
   1531           *  @brief      Select which sensors are pushed to FIFO.
   1532           *  @e sensors can contain a combination of the following flags:
   1533           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1534           *  \n INV_XYZ_GYRO
   1535           *  \n INV_XYZ_ACCEL
   1536           *  @param[in]  sensors Mask of sensors to push to FIFO.
   1537           *  @return     0 if successful.
   1538           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1539          int mpu_configure_fifo(unsigned char sensors)
   \                     mpu_configure_fifo:
   1540          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   1541              unsigned char prev;
   1542              int result = 0;
   1543          
   1544              /* Compass data isn't going into the FIFO. Stop trying. */
   1545              sensors &= ~INV_XYZ_COMPASS;
   \   000005   E9           MOV     A,R1
   \   000006   C2E0         CLR     0xE0 /* A   */.0
   \   000008   F5..         MOV     ?V0 + 0,A
   1546          
   1547              if (st.chip_cfg.dmp_on)
   \   00000A   90....       MOV     DPTR,#st + 29
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6006         JZ      ??mpu_configure_fifo_0
   1548                  return 0;
   \   000010   7A00         MOV     R2,#0x0
   \   000012   7B00         MOV     R3,#0x0
   \   000014   8043         SJMP    ??mpu_configure_fifo_1
   1549              else {
   1550                  if (!(st.chip_cfg.sensors))
   \                     ??mpu_configure_fifo_0:
   \   000016   90....       MOV     DPTR,#st + 6
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   7006         JNZ     ??mpu_configure_fifo_2
   1551                      return -1;
   \                     ??mpu_configure_fifo_3:
   \   00001C   7AFF         MOV     R2,#-0x1
   \   00001E   7BFF         MOV     R3,#-0x1
   \   000020   8037         SJMP    ??mpu_configure_fifo_1
   1552                  prev = st.chip_cfg.fifo_enable;
   \                     ??mpu_configure_fifo_2:
   \   000022   90....       MOV     DPTR,#st + 11
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F5..         MOV     ?V0 + 1,A
   \   000028   90....       MOV     DPTR,#st + 6
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   55..         ANL     A,?V0 + 0
   \   00002E   F8           MOV     R0,A
   \   00002F   90....       MOV     DPTR,#st + 11
   \   000032   F0           MOVX    @DPTR,A
   1553                  st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
   1554                  if (st.chip_cfg.fifo_enable != sensors)
   \   000033   E5..         MOV     A,?V0 + 0
   \   000035   68           XRL     A,R0
   \   000036   6006         JZ      ??mpu_configure_fifo_4
   1555                      /* You're not getting what you asked for. Some sensors are
   1556                       * asleep.
   1557                       */
   1558                      result = -1;
   \   000038   7EFF         MOV     R6,#-0x1
   \   00003A   7FFF         MOV     R7,#-0x1
   \   00003C   8004         SJMP    ??mpu_configure_fifo_5
   1559                  else
   1560                      result = 0;
   \                     ??mpu_configure_fifo_4:
   \   00003E   7E00         MOV     R6,#0x0
   \   000040   7F00         MOV     R7,#0x0
   1561                  if (sensors || st.chip_cfg.lp_accel_mode)
   \                     ??mpu_configure_fifo_5:
   \   000042   E5..         MOV     A,?V0 + 0
   \   000044   7006         JNZ     ??mpu_configure_fifo_6
   \   000046   90....       MOV     DPTR,#st + 15
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6012         JZ      ??mpu_configure_fifo_7
   1562                      set_int_enable(1);
   \                     ??mpu_configure_fifo_6:
   \   00004C                ; Setup parameters for call to function set_int_enable
   \   00004C   7901         MOV     R1,#0x1
   \   00004E   12....       LCALL   ??set_int_enable?relay
   1563                  else
   1564                      set_int_enable(0);
   1565                  if (sensors) {
   \   000051   E5..         MOV     A,?V0 + 0
   \   000053   7010         JNZ     ??mpu_configure_fifo_8
   1566                      if (mpu_reset_fifo()) {
   1567                          st.chip_cfg.fifo_enable = prev;
   1568                          return -1;
   1569                      }
   1570                  }
   1571              }
   1572          
   1573              return result;
   \                     ??mpu_configure_fifo_9:
   \   000055   EE           MOV     A,R6
   \   000056   FA           MOV     R2,A
   \   000057   EF           MOV     A,R7
   \   000058   FB           MOV     R3,A
   \                     ??mpu_configure_fifo_1:
   \   000059   7F04         MOV     R7,#0x4
   \   00005B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??mpu_configure_fifo_7:
   \   00005E                ; Setup parameters for call to function set_int_enable
   \   00005E   7900         MOV     R1,#0x0
   \   000060   12....       LCALL   ??set_int_enable?relay
   \   000063   80F0         SJMP    ??mpu_configure_fifo_9
   \                     ??mpu_configure_fifo_8:
   \   000065                ; Setup parameters for call to function mpu_reset_fifo
   \   000065   12....       LCALL   ??mpu_reset_fifo?relay
   \   000068   8B..         MOV     ?V0 + 3,R3
   \   00006A   EA           MOV     A,R2
   \   00006B   45..         ORL     A,?V0 + 3
   \   00006D   60E6         JZ      ??mpu_configure_fifo_9
   \   00006F   E5..         MOV     A,?V0 + 1
   \   000071   90....       MOV     DPTR,#st + 11
   \   000074   F0           MOVX    @DPTR,A
   \   000075   80A5         SJMP    ??mpu_configure_fifo_3
   1574          }
   1575          
   1576          /**
   1577           *  @brief      Get current power state.
   1578           *  @param[in]  power_on    1 if turned on, 0 if suspended.
   1579           *  @return     0 if successful.
   1580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1581          int mpu_get_power_state(unsigned char *power_on)
   \                     mpu_get_power_state:
   1582          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1583              if (st.chip_cfg.sensors)
   \   000004   90....       MOV     DPTR,#st + 6
   \   000007   E0           MOVX    A,@DPTR
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   6004         JZ      ??mpu_get_power_state_0
   1584                  power_on[0] = 1;
   \   00000E   7401         MOV     A,#0x1
   \   000010   8001         SJMP    ??mpu_get_power_state_1
   1585              else
   1586                  power_on[0] = 0;
   \                     ??mpu_get_power_state_0:
   \   000012   E4           CLR     A
   \                     ??mpu_get_power_state_1:
   \   000013   02....       LJMP    ??Subroutine122_0 & 0xFFFF
   1587              return 0;
   1588          }
   1589          
   1590          /**
   1591           *  @brief      Turn specific sensors on/off.
   1592           *  @e sensors can contain a combination of the following flags:
   1593           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1594           *  \n INV_XYZ_GYRO
   1595           *  \n INV_XYZ_ACCEL
   1596           *  \n INV_XYZ_COMPASS
   1597           *  @param[in]  sensors    Mask of sensors to wake.
   1598           *  @return     0 if successful.
   1599           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1600          int mpu_set_sensors(unsigned char sensors)
   \                     mpu_set_sensors:
   1601          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1602              unsigned char data;
   1603          #ifdef AK89xx_SECONDARY
   1604              unsigned char user_ctrl;
   1605          #endif
   1606          
   1607              if (sensors & INV_XYZ_GYRO)
   \   00000C   7470         MOV     A,#0x70
   \   00000E   5E           ANL     A,R6
   \   00000F   600A         JZ      ??mpu_set_sensors_0
   1608                  data = INV_CLK_PLL;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7401         MOV     A,#0x1
   \   000019   800E         SJMP    ??mpu_set_sensors_1
   1609              else if (sensors)
   \                     ??mpu_set_sensors_0:
   \   00001B   EE           MOV     A,R6
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   6003         JZ      ??mpu_set_sensors_2
   1610                  data = 0;
   \   000024   E4           CLR     A
   \   000025   8002         SJMP    ??mpu_set_sensors_1
   1611              else
   1612                  data = BIT_SLEEP;
   \                     ??mpu_set_sensors_2:
   \   000027   7440         MOV     A,#0x40
   \                     ??mpu_set_sensors_1:
   \   000029   12....       LCALL   ?Subroutine50 & 0xFFFF
   1613              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
   \                     ??CrossCallReturnLabel_67:
   \   00002C   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00002F   600B         JZ      ??mpu_set_sensors_3
   1614                  st.chip_cfg.sensors = 0;
   \                     ??mpu_set_sensors_4:
   \   000031   90....       MOV     DPTR,#st + 6
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   1615                  return -1;
   \   000036   7AFF         MOV     R2,#-0x1
   \   000038   7BFF         MOV     R3,#-0x1
   \   00003A   806A         SJMP    ??mpu_set_sensors_5
   1616              }
   1617              st.chip_cfg.clk_src = data & ~BIT_SLEEP;
   \                     ??mpu_set_sensors_3:
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   E0           MOVX    A,@DPTR
   \   000043   54BF         ANL     A,#0xbf
   \   000045   90....       MOV     DPTR,#st + 8
   \   000048   F0           MOVX    @DPTR,A
   1618          
   1619              data = 0;
   \   000049   85..82       MOV     DPL,?XSP + 0
   \   00004C   85..83       MOV     DPH,?XSP + 1
   \   00004F   E4           CLR     A
   \   000050   F0           MOVX    @DPTR,A
   1620              if (!(sensors & INV_X_GYRO))
   \   000051   EE           MOV     A,R6
   \   000052   A2E6         MOV     C,0xE0 /* A   */.6
   \   000054   4003         JC      ??mpu_set_sensors_6
   1621                  data |= BIT_STBY_XG;
   \   000056   7404         MOV     A,#0x4
   \   000058   F0           MOVX    @DPTR,A
   1622              if (!(sensors & INV_Y_GYRO))
   \                     ??mpu_set_sensors_6:
   \   000059   EE           MOV     A,R6
   \   00005A   A2E5         MOV     C,0xE0 /* A   */.5
   \   00005C   4004         JC      ??mpu_set_sensors_7
   1623                  data |= BIT_STBY_YG;
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   D2E1         SETB    0xE0 /* A   */.1
   \   000061   F0           MOVX    @DPTR,A
   1624              if (!(sensors & INV_Z_GYRO))
   \                     ??mpu_set_sensors_7:
   \   000062   EE           MOV     A,R6
   \   000063   A2E4         MOV     C,0xE0 /* A   */.4
   \   000065   4004         JC      ??mpu_set_sensors_8
   1625                  data |= BIT_STBY_ZG;
   \   000067   E0           MOVX    A,@DPTR
   \   000068   D2E0         SETB    0xE0 /* A   */.0
   \   00006A   F0           MOVX    @DPTR,A
   1626              if (!(sensors & INV_XYZ_ACCEL))
   \                     ??mpu_set_sensors_8:
   \   00006B   EE           MOV     A,R6
   \   00006C   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006E   4004         JC      ??mpu_set_sensors_9
   1627                  data |= BIT_STBY_XYZA;
   \   000070   E0           MOVX    A,@DPTR
   \   000071   4438         ORL     A,#0x38
   \   000073   F0           MOVX    @DPTR,A
   1628              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
   \                     ??mpu_set_sensors_9:
   \   000074                ; Setup parameters for call to function MPU_Write_Len
   \   000074   AC82         MOV     R4,DPL
   \   000076   AD83         MOV     R5,DPH
   \   000078   7B01         MOV     R3,#0x1
   \   00007A   90....       MOV     DPTR,#st
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   2413         ADD     A,#0x13
   \   000080   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000083   70AC         JNZ     ??mpu_set_sensors_4
   1629                  st.chip_cfg.sensors = 0;
   1630                  return -1;
   1631              }
   1632          
   1633              if (sensors && (sensors != INV_XYZ_ACCEL))
   \   000085   EE           MOV     A,R6
   \   000086   600A         JZ      ??mpu_set_sensors_10
   \   000088   7408         MOV     A,#0x8
   \   00008A   6E           XRL     A,R6
   \   00008B   6005         JZ      ??mpu_set_sensors_10
   1634                  /* Latched interrupts only used in LP accel mode. */
   1635                  mpu_set_int_latched(0);
   \   00008D                ; Setup parameters for call to function mpu_set_int_latched
   \   00008D   7900         MOV     R1,#0x0
   \   00008F   12....       LCALL   ??mpu_set_int_latched?relay
   1636          
   1637          #ifdef AK89xx_SECONDARY
   1638          #ifdef AK89xx_BYPASS
   1639              if (sensors & INV_XYZ_COMPASS)
   1640                  mpu_set_bypass(1);
   1641              else
   1642                  mpu_set_bypass(0);
   1643          #else
   1644              if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1645                  return -1;
   1646              /* Handle AKM power management. */
   1647              if (sensors & INV_XYZ_COMPASS) {
   1648                  data = AKM_SINGLE_MEASUREMENT;
   1649                  user_ctrl |= BIT_AUX_IF_EN;
   1650              } else {
   1651                  data = AKM_POWER_DOWN;
   1652                  user_ctrl &= ~BIT_AUX_IF_EN;
   1653              }
   1654              if (st.chip_cfg.dmp_on)
   1655                  user_ctrl |= BIT_DMP_EN;
   1656              else
   1657                  user_ctrl &= ~BIT_DMP_EN;
   1658              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
   1659                  return -1;
   1660              /* Enable/disable I2C master mode. */
   1661              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
   1662                  return -1;
   1663          #endif
   1664          #endif
   1665          
   1666              st.chip_cfg.sensors = sensors;
   \                     ??mpu_set_sensors_10:
   \   000092   EE           MOV     A,R6
   \   000093   90....       MOV     DPTR,#st + 6
   \   000096   F0           MOVX    @DPTR,A
   1667              st.chip_cfg.lp_accel_mode = 0;
   \   000097   90....       MOV     DPTR,#st + 15
   \   00009A   E4           CLR     A
   \   00009B   F0           MOVX    @DPTR,A
   1668              delay_ms(50);
   \   00009C                ; Setup parameters for call to function delay_ms
   \   00009C   7A32         MOV     R2,#0x32
   \   00009E   FB           MOV     R3,A
   \   00009F   12....       LCALL   ??delay_ms?relay
   1669              return 0;
   \   0000A2   7A00         MOV     R2,#0x0
   \   0000A4   7B00         MOV     R3,#0x0
   \                     ??mpu_set_sensors_5:
   \   0000A6   02....       LJMP    ?Subroutine0 & 0xFFFF
   1670          }
   1671          
   1672          /**
   1673           *  @brief      Read the MPU interrupt status registers.
   1674           *  @param[out] status  Mask of interrupt bits.
   1675           *  @return     0 if successful.
   1676           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1677          int mpu_get_int_status(short *status)
   \                     mpu_get_int_status:
   1678          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1679              unsigned char tmp[2];
   1680              if (!st.chip_cfg.sensors)
   \   00000E   90....       MOV     DPTR,#st + 6
   \   000011   E0           MOVX    A,@DPTR
   \   000012   7006         JNZ     ??mpu_get_int_status_0
   1681                  return -1;
   \                     ??mpu_get_int_status_1:
   \   000014   7AFF         MOV     R2,#-0x1
   \   000016   7BFF         MOV     R3,#-0x1
   \   000018   8023         SJMP    ??CrossCallReturnLabel_297
   1682              if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
   \                     ??mpu_get_int_status_0:
   \   00001A                ; Setup parameters for call to function MPU_Read_Len
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   AC82         MOV     R4,DPL
   \   000022   AD83         MOV     R5,DPH
   \   000024   7B02         MOV     R3,#0x2
   \   000026   90....       MOV     DPTR,#st
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   2410         ADD     A,#0x10
   \   00002C   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   00002F   70E3         JNZ     ??mpu_get_int_status_1
   1683                  return -1;
   1684              status[0] = (tmp[0] << 8) | tmp[1];
   \   000031   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   12....       LCALL   ?Subroutine86 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   00003A   12....       LCALL   ?Subroutine53 & 0xFFFF
   1685              return 0;
   \                     ??CrossCallReturnLabel_297:
   \   00003D   02....       LJMP    ?Subroutine8 & 0xFFFF
   1686          }
   1687          
   1688          /**
   1689           *  @brief      Get one packet from the FIFO.
   1690           *  If @e sensors does not contain a particular sensor, disregard the data
   1691           *  returned to that pointer.
   1692           *  \n @e sensors can contain a combination of the following flags:
   1693           *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
   1694           *  \n INV_XYZ_GYRO
   1695           *  \n INV_XYZ_ACCEL
   1696           *  \n If the FIFO has no new data, @e sensors will be zero.
   1697           *  \n If the FIFO is disabled, @e sensors will be zero and this function will
   1698           *  return a non-zero error code.
   1699           *  @param[out] gyro        Gyro data in hardware units.
   1700           *  @param[out] accel       Accel data in hardware units.
   1701           *  @param[out] timestamp   Timestamp in milliseconds.
   1702           *  @param[out] sensors     Mask of sensors read from FIFO.
   1703           *  @param[out] more        Number of remaining packets.
   1704           *  @return     0 if successful.
   1705           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   7B01         MOV     R3,#0x1
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   2411         ADD     A,#0x11
   \   000012                REQUIRE ??Subroutine113_0
   \   000012                ; // Fall through to label ??Subroutine113_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1706          int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
   \                     mpu_read_fifo:
   1707                  unsigned char *sensors, unsigned char *more)
   1708          {
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   \   00000E   8C..         MOV     ?V0 + 6,R4
   \   000010   8D..         MOV     ?V0 + 7,R5
   \   000012   7424         MOV     A,#0x24
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine80 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   00001A   7426         MOV     A,#0x26
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F5..         MOV     ?V0 + 10,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 11,A
   1709              /* Assumes maximum packet size is gyro (6) + accel (6). */
   1710              unsigned char data[MAX_PACKET_LENGTH];
   1711              unsigned char packet_size = 0;
   \   000026   75..00       MOV     ?V0 + 2,#0x0
   1712              unsigned short fifo_count, index = 0;
   \   000029   7E00         MOV     R6,#0x0
   \   00002B   7F00         MOV     R7,#0x0
   1713          
   1714              if (st.chip_cfg.dmp_on)
   \   00002D   90....       MOV     DPTR,#st + 29
   \   000030   E0           MOVX    A,@DPTR
   \   000031   600E         JZ      ??mpu_read_fifo_0
   1715                  return -1;
   \                     ??mpu_read_fifo_1:
   \   000033   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_2:
   \   000035   7BFF         MOV     R3,#-0x1
   \                     ??mpu_read_fifo_3:
   \   000037   740C         MOV     A,#0xc
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003C   7F0E         MOV     R7,#0xe
   \   00003E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1716          
   1717              sensors[0] = 0;
   \                     ??mpu_read_fifo_0:
   \   000041   85..82       MOV     DPL,?V0 + 4
   \   000044   85..83       MOV     DPH,?V0 + 5
   \   000047   E4           CLR     A
   \   000048   F0           MOVX    @DPTR,A
   1718              if (!st.chip_cfg.sensors)
   \   000049   90....       MOV     DPTR,#st + 6
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   60E4         JZ      ??mpu_read_fifo_1
   1719                  return -1;
   1720              if (!st.chip_cfg.fifo_enable)
   \   00004F   90....       MOV     DPTR,#st + 11
   \   000052   E0           MOVX    A,@DPTR
   \   000053   60DE         JZ      ??mpu_read_fifo_1
   1721                  return -1;
   1722          
   1723              if (st.chip_cfg.fifo_enable & INV_X_GYRO)
   \   000055   A2E6         MOV     C,0xE0 /* A   */.6
   \   000057   5003         JNC     ??mpu_read_fifo_4
   1724                  packet_size += 2;
   \   000059   75..02       MOV     ?V0 + 2,#0x2
   1725              if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
   \                     ??mpu_read_fifo_4:
   \   00005C   A2E5         MOV     C,0xE0 /* A   */.5
   \   00005E   5004         JNC     ??mpu_read_fifo_5
   1726                  packet_size += 2;
   \   000060   05..         INC     ?V0 + 2
   \   000062   05..         INC     ?V0 + 2
   1727              if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
   \                     ??mpu_read_fifo_5:
   \   000064   A2E4         MOV     C,0xE0 /* A   */.4
   \   000066   5004         JNC     ??mpu_read_fifo_6
   1728                  packet_size += 2;
   \   000068   05..         INC     ?V0 + 2
   \   00006A   05..         INC     ?V0 + 2
   1729              if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
   \                     ??mpu_read_fifo_6:
   \   00006C   A2E3         MOV     C,0xE0 /* A   */.3
   \   00006E   5006         JNC     ??mpu_read_fifo_7
   1730                  packet_size += 6;
   \   000070   7406         MOV     A,#0x6
   \   000072   25..         ADD     A,?V0 + 2
   \   000074   F5..         MOV     ?V0 + 2,A
   1731          
   1732              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \                     ??mpu_read_fifo_7:
   \   000076                ; Setup parameters for call to function MPU_Read_Len
   \   000076   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000079   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_210:
   \   00007C   70B5         JNZ     ??mpu_read_fifo_1
   1733                  return -1;
   1734              fifo_count = (data[0] << 8) | data[1];
   \   00007E   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E0           MOVX    A,@DPTR
   \   000085   FA           MOV     R2,A
   \   000086   F5..         MOV     ?V0 + 0,A
   \   000088   E9           MOV     A,R1
   \   000089   F5..         MOV     ?V0 + 1,A
   1735              if (fifo_count < packet_size)
   \   00008B   85....       MOV     ?V0 + 12,?V0 + 2
   \   00008E   C3           CLR     C
   \   00008F   EA           MOV     A,R2
   \   000090   95..         SUBB    A,?V0 + 12
   \   000092   E9           MOV     A,R1
   \   000093   9400         SUBB    A,#0x0
   \   000095   5006         JNC     ??mpu_read_fifo_8
   1736                  return 0;
   \                     ??mpu_read_fifo_9:
   \   000097   7A00         MOV     R2,#0x0
   \   000099   7B00         MOV     R3,#0x0
   \   00009B   809A         SJMP    ??mpu_read_fifo_3
   1737          //    log_i("FIFO count: %hd\n", fifo_count);
   1738              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_8:
   \   00009D   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   0000A0   95..         SUBB    A,?V0 + 0
   \   0000A2   E9           MOV     A,R1
   \   0000A3   95..         SUBB    A,?V0 + 1
   \   0000A5   5018         JNC     ??mpu_read_fifo_10
   1739                  /* FIFO is 50% full, better check overflow bit. */
   1740                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
   \   0000A7                ; Setup parameters for call to function MPU_Read_Len
   \   0000A7   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_198:
   \   0000AA   7087         JNZ     ??mpu_read_fifo_1
   1741                      return -1;
   1742                  if (data[0] & BIT_FIFO_OVERFLOW) {
   \   0000AC   85..82       MOV     DPL,?XSP + 0
   \   0000AF   85..83       MOV     DPH,?XSP + 1
   \   0000B2   E0           MOVX    A,@DPTR
   \   0000B3   A2E4         MOV     C,0xE0 /* A   */.4
   \   0000B5   5008         JNC     ??mpu_read_fifo_10
   1743                      mpu_reset_fifo();
   \   0000B7                ; Setup parameters for call to function mpu_reset_fifo
   \   0000B7   12....       LCALL   ??mpu_reset_fifo?relay
   1744                      return -2;
   \   0000BA   7AFE         MOV     R2,#-0x2
   \   0000BC   02....       LJMP    ??mpu_read_fifo_2 & 0xFFFF
   1745                  }
   1746              }
   1747              get_ms((unsigned long*)timestamp);
   1748          
   1749              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
   \                     ??mpu_read_fifo_10:
   \   0000BF                ; Setup parameters for call to function MPU_Read_Len
   \   0000BF   85..82       MOV     DPL,?XSP + 0
   \   0000C2   85..83       MOV     DPH,?XSP + 1
   \   0000C5   AC82         MOV     R4,DPL
   \   0000C7   AD83         MOV     R5,DPH
   \   0000C9   AB..         MOV     R3,?V0 + 2
   \   0000CB   90....       MOV     DPTR,#st
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   240B         ADD     A,#0xb
   \   0000D1   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   0000D4   6003         JZ      $+5
   \   0000D6   02....       LJMP    ??mpu_read_fifo_1 & 0xFFFF
   1750                  return -1;
   1751              more[0] = fifo_count / packet_size - 1;
   \   0000D9   A8..         MOV     R0,?V0 + 0
   \   0000DB   A9..         MOV     R1,?V0 + 1
   \   0000DD   85....       MOV     ?V0 + 0,?V0 + 2
   \   0000E0   AA..         MOV     R2,?V0 + 0
   \   0000E2   7B00         MOV     R3,#0x0
   \   0000E4   12....       LCALL   ?US_DIV_MOD
   \   0000E7   E8           MOV     A,R0
   \   0000E8   14           DEC     A
   \   0000E9   85..82       MOV     DPL,?V0 + 10
   \   0000EC   85..83       MOV     DPH,?V0 + 11
   \   0000EF   F0           MOVX    @DPTR,A
   1752              sensors[0] = 0;
   \   0000F0   85..82       MOV     DPL,?V0 + 4
   \   0000F3   85..83       MOV     DPH,?V0 + 5
   \   0000F6   E4           CLR     A
   \   0000F7   F0           MOVX    @DPTR,A
   1753          
   1754              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
   \   0000F8   E5..         MOV     A,?V0 + 2
   \   0000FA   609B         JZ      ??mpu_read_fifo_9
   \   0000FC   90....       MOV     DPTR,#st + 11
   \   0000FF   E0           MOVX    A,@DPTR
   \   000100   A2E3         MOV     C,0xE0 /* A   */.3
   \   000102   503F         JNC     ??mpu_read_fifo_11
   1755                  accel[0] = (data[index+0] << 8) | data[index+1];
   \   000104   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000107   12....       LCALL   ?XSTACK_DISP0_8
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   85..82       MOV     DPL,?V0 + 6
   \   00010E   85..83       MOV     DPH,?V0 + 7
   \   000111   12....       LCALL   ??Subroutine115_0 & 0xFFFF
   1756                  accel[1] = (data[index+2] << 8) | data[index+3];
   \                     ??CrossCallReturnLabel_219:
   \   000114   12....       LCALL   ?XSTACK_DISP0_8
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   7403         MOV     A,#0x3
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000121   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   1757                  accel[2] = (data[index+4] << 8) | data[index+5];
   \                     ??CrossCallReturnLabel_244:
   \   000124   7404         MOV     A,#0x4
   \   000126   12....       LCALL   ?XSTACK_DISP0_8
   \   000129   E0           MOVX    A,@DPTR
   \   00012A   F9           MOV     R1,A
   \   00012B   7405         MOV     A,#0x5
   \   00012D   12....       LCALL   ?XSTACK_DISP0_8
   \   000130   12....       LCALL   ?Subroutine44 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000133   12....       LCALL   ?Subroutine48 & 0xFFFF
   1758                  sensors[0] |= INV_XYZ_ACCEL;
   \                     ??CrossCallReturnLabel_237:
   \   000136   D2E3         SETB    0xE0 /* A   */.3
   \   000138   F0           MOVX    @DPTR,A
   1759                  index += 6;
   \   000139   7E06         MOV     R6,#0x6
   1760              }
   1761              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
   \   00013B   EE           MOV     A,R6
   \   00013C   65..         XRL     A,?V0 + 2
   \   00013E   7003         JNZ     $+5
   \   000140   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \                     ??mpu_read_fifo_11:
   \   000143   90....       MOV     DPTR,#st + 11
   \   000146   E0           MOVX    A,@DPTR
   \   000147   A2E6         MOV     C,0xE0 /* A   */.6
   \   000149   5021         JNC     ??mpu_read_fifo_12
   1762                  gyro[0] = (data[index+0] << 8) | data[index+1];
   \   00014B   85..82       MOV     DPL,?XSP + 0
   \   00014E   85..83       MOV     DPH,?XSP + 1
   \   000151   E582         MOV     A,DPL
   \   000153   2E           ADD     A,R6
   \   000154   F582         MOV     DPL,A
   \   000156   E583         MOV     A,DPH
   \   000158   3400         ADDC    A,#0x0
   \   00015A   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   00015D   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   1763                  sensors[0] |= INV_X_GYRO;
   \                     ??CrossCallReturnLabel_239:
   \   000160   D2E6         SETB    0xE0 /* A   */.6
   \   000162   F0           MOVX    @DPTR,A
   1764                  index += 2;
   \   000163   EE           MOV     A,R6
   \   000164   2402         ADD     A,#0x2
   \   000166   0E           INC     R6
   \   000167   0E           INC     R6
   \   000168   E4           CLR     A
   \   000169   3400         ADDC    A,#0x0
   \   00016B   FF           MOV     R7,A
   1765              }
   1766              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
   \                     ??mpu_read_fifo_12:
   \   00016C   EE           MOV     A,R6
   \   00016D   65..         XRL     A,?V0 + 2
   \   00016F   601A         JZ      ??mpu_read_fifo_13
   \   000171   90....       MOV     DPTR,#st + 11
   \   000174   E0           MOVX    A,@DPTR
   \   000175   A2E5         MOV     C,0xE0 /* A   */.5
   \   000177   5012         JNC     ??mpu_read_fifo_13
   1767                  gyro[1] = (data[index+0] << 8) | data[index+1];
   \   000179   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   00017C   12....       LCALL   ??Subroutine120_0 & 0xFFFF
   1768                  sensors[0] |= INV_Y_GYRO;
   \                     ??CrossCallReturnLabel_240:
   \   00017F   D2E5         SETB    0xE0 /* A   */.5
   \   000181   F0           MOVX    @DPTR,A
   1769                  index += 2;
   \   000182   EE           MOV     A,R6
   \   000183   2402         ADD     A,#0x2
   \   000185   0E           INC     R6
   \   000186   0E           INC     R6
   \   000187   EF           MOV     A,R7
   \   000188   3400         ADDC    A,#0x0
   \   00018A   FF           MOV     R7,A
   1770              }
   1771              if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
   \                     ??mpu_read_fifo_13:
   \   00018B   EE           MOV     A,R6
   \   00018C   65..         XRL     A,?V0 + 2
   \   00018E   7003         JNZ     $+5
   \   000190   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   \   000193   90....       MOV     DPTR,#st + 11
   \   000196   E0           MOVX    A,@DPTR
   \   000197   A2E4         MOV     C,0xE0 /* A   */.4
   \   000199   4003         JC      $+5
   \   00019B   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1772                  gyro[2] = (data[index+0] << 8) | data[index+1];
   \   00019E   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_49:
   \   0001A1   12....       LCALL   ?Subroutine48 & 0xFFFF
   1773                  sensors[0] |= INV_Z_GYRO;
   \                     ??CrossCallReturnLabel_238:
   \   0001A4   D2E4         SETB    0xE0 /* A   */.4
   \   0001A6   F0           MOVX    @DPTR,A
   1774                  index += 2;
   \   0001A7   02....       LJMP    ??mpu_read_fifo_9 & 0xFFFF
   1775              }
   1776          
   1777              return 0;
   1778          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine120_0
   \   000002                ; // Fall through to label ??Subroutine120_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine120_0:
   \   000000   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_250:
   \   000003   85..82       MOV     DPL,?V0 + 4
   \   000006   85..83       MOV     DPH,?V0 + 5
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   85..82       MOV     DPL,?V0 + 6
   \   000004   85..83       MOV     DPH,?V0 + 7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   2E           ADD     A,R6
   \   000009   F582         MOV     DPL,A
   \   00000B   E583         MOV     A,DPH
   \   00000D   3F           ADDC    A,R7
   \   00000E   12....       LCALL   ?Subroutine81 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   F583         MOV     DPH,A
   \   000002   E0           MOVX    A,@DPTR
   \   000003   F9           MOV     R1,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   85..82       MOV     DPL,?V0 + 8
   \   000009   85..83       MOV     DPH,?V0 + 9
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   90....       MOV     DPTR,#st + 2
   \   000003   12....       LCALL   ??Subroutine132_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_284:
   \   000006   12....       LCALL   ?Subroutine84 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000009   C3           CLR     C
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AC82         MOV     R4,DPL
   \   000008   AD83         MOV     R5,DPH
   \   00000A   7B02         MOV     R3,#0x2
   \   00000C   90....       MOV     DPTR,#st
   \   00000F   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_111:
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   12....       LCALL   ?Subroutine97 & 0xFFFF
   \                     ??CrossCallReturnLabel_292:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   22           RET
   1779          
   1780          /**
   1781           *  @brief      Get one unparsed packet from the FIFO.
   1782           *  This function should be used if the packet is to be parsed elsewhere.
   1783           *  @param[in]  length  Length of one FIFO packet.
   1784           *  @param[in]  data    FIFO packet.
   1785           *  @param[in]  more    Number of remaining packets.
   1786           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1787          int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
   \                     mpu_read_fifo_stream:
   1788              unsigned char *more)
   1789          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7410         MOV     A,#0x10
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   1790              unsigned char tmp[2];
   1791              unsigned short fifo_count;
   1792              if (!st.chip_cfg.dmp_on)
   \   00001E   90....       MOV     DPTR,#st + 29
   \   000021   E0           MOVX    A,@DPTR
   \   000022   7006         JNZ     ??mpu_read_fifo_stream_0
   1793                  return -1;
   \                     ??mpu_read_fifo_stream_1:
   \   000024   7AFF         MOV     R2,#-0x1
   \                     ??mpu_read_fifo_stream_2:
   \   000026   7BFF         MOV     R3,#-0x1
   \   000028   8071         SJMP    ??CrossCallReturnLabel_298
   1794              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_fifo_stream_0:
   \   00002A   90....       MOV     DPTR,#st + 6
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   60F4         JZ      ??mpu_read_fifo_stream_1
   1795                  return -1;
   1796          
   1797              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
   \   000030                ; Setup parameters for call to function MPU_Read_Len
   \   000030   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000033   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   000036   70EC         JNZ     ??mpu_read_fifo_stream_1
   1798                  return -1;
   1799              fifo_count = (tmp[0] << 8) | tmp[1];
   \   000038   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   FE           MOV     R6,A
   \   000040   E9           MOV     A,R1
   \   000041   FF           MOV     R7,A
   1800              if (fifo_count < length) {
   \   000042   C3           CLR     C
   \   000043   EE           MOV     A,R6
   \   000044   95..         SUBB    A,?V0 + 0
   \   000046   EF           MOV     A,R7
   \   000047   95..         SUBB    A,?V0 + 1
   \   000049   500A         JNC     ??mpu_read_fifo_stream_3
   1801                  more[0] = 0;
   \   00004B   85..82       MOV     DPL,?V0 + 2
   \   00004E   85..83       MOV     DPH,?V0 + 3
   \   000051   E4           CLR     A
   \   000052   F0           MOVX    @DPTR,A
   \   000053   80CF         SJMP    ??mpu_read_fifo_stream_1
   1802                  return -1;
   1803              }
   1804              if (fifo_count > (st.hw->max_fifo >> 1)) {
   \                     ??mpu_read_fifo_stream_3:
   \   000055   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000058   9E           SUBB    A,R6
   \   000059   E9           MOV     A,R1
   \   00005A   9F           SUBB    A,R7
   \   00005B   5017         JNC     ??mpu_read_fifo_stream_4
   1805                  /* FIFO is 50% full, better check overflow bit. */
   1806                  if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
   \   00005D                ; Setup parameters for call to function MPU_Read_Len
   \   00005D   12....       LCALL   ?Subroutine12 & 0xFFFF
   \                     ??CrossCallReturnLabel_199:
   \   000060   70C2         JNZ     ??mpu_read_fifo_stream_1
   1807                      return -1;
   1808                  if (tmp[0] & BIT_FIFO_OVERFLOW) {
   \   000062   85..82       MOV     DPL,?XSP + 0
   \   000065   85..83       MOV     DPH,?XSP + 1
   \   000068   E0           MOVX    A,@DPTR
   \   000069   A2E4         MOV     C,0xE0 /* A   */.4
   \   00006B   5007         JNC     ??mpu_read_fifo_stream_4
   1809                      mpu_reset_fifo();
   \   00006D                ; Setup parameters for call to function mpu_reset_fifo
   \   00006D   12....       LCALL   ??mpu_reset_fifo?relay
   1810                      return -2;
   \   000070   7AFE         MOV     R2,#-0x2
   \   000072   80B2         SJMP    ??mpu_read_fifo_stream_2
   1811                  }
   1812              }
   1813          
   1814              if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
   \                     ??mpu_read_fifo_stream_4:
   \   000074                ; Setup parameters for call to function MPU_Read_Len
   \   000074   AC..         MOV     R4,?V0 + 4
   \   000076   AD..         MOV     R5,?V0 + 5
   \   000078   AB..         MOV     R3,?V0 + 0
   \   00007A   90....       MOV     DPTR,#st
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   240B         ADD     A,#0xb
   \   000080   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000083   709F         JNZ     ??mpu_read_fifo_stream_1
   1815                  return -1;
   1816              more[0] = fifo_count / length - 1;
   \   000085   EE           MOV     A,R6
   \   000086   F8           MOV     R0,A
   \   000087   EF           MOV     A,R7
   \   000088   F9           MOV     R1,A
   \   000089   AA..         MOV     R2,?V0 + 0
   \   00008B   AB..         MOV     R3,?V0 + 1
   \   00008D   12....       LCALL   ?US_DIV_MOD
   \   000090   E8           MOV     A,R0
   \   000091   14           DEC     A
   \   000092   85..82       MOV     DPL,?V0 + 2
   \   000095   85..83       MOV     DPH,?V0 + 3
   \   000098   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   1817              return 0;
   \                     ??CrossCallReturnLabel_298:
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0                REQUIRE ?Subroutine5
   \   0000A0                ; // Fall through to label ?Subroutine5
   1818          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1819          
   1820          /**
   1821           *  @brief      Set device to bypass mode.
   1822           *  @param[in]  bypass_on   1 to enable bypass mode.
   1823           *  @return     0 if successful.
   1824           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1825          int mpu_set_bypass(unsigned char bypass_on)
   \                     mpu_set_bypass:
   1826          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1827              unsigned char tmp;
   1828          
   1829              if (st.chip_cfg.bypass_mode == bypass_on)
   \   00000C   90....       MOV     DPTR,#st + 13
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7003         JNZ     $+5
   \   000013   02....       LJMP    ??mpu_set_bypass_0 & 0xFFFF
   1830                  return 0;
   1831          
   1832              if (bypass_on) {
   \   000016   EE           MOV     A,R6
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   AC82         MOV     R4,DPL
   \   00001F   AD83         MOV     R5,DPH
   \   000021   7B01         MOV     R3,#0x1
   \   000023   90....       MOV     DPTR,#st
   \   000026   6061         JZ      ??mpu_set_bypass_1
   1833                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000028                ; Setup parameters for call to function MPU_Read_Len
   \   000028   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_220:
   \   00002B   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   00002E   6007         JZ      ??mpu_set_bypass_2
   1834                      return -1;
   \                     ??mpu_set_bypass_3:
   \   000030   7AFF         MOV     R2,#-0x1
   \   000032   7BFF         MOV     R3,#-0x1
   \   000034   02....       LJMP    ??mpu_set_bypass_4 & 0xFFFF
   1835                  tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_2:
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   C2E5         CLR     0xE0 /* A   */.5
   \   000040   F0           MOVX    @DPTR,A
   1836                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   000041                ; Setup parameters for call to function MPU_Write_Len
   \   000041   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000044   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_173:
   \   000047   70E7         JNZ     ??mpu_set_bypass_3
   1837                      return -1;
   1838                  delay_ms(3);
   \   000049                ; Setup parameters for call to function delay_ms
   \   000049   7A03         MOV     R2,#0x3
   \   00004B   12....       LCALL   ?Subroutine60 & 0xFFFF
   1839                  tmp = BIT_BYPASS_EN;
   \                     ??CrossCallReturnLabel_82:
   \   00004E   7402         MOV     A,#0x2
   \   000050   F0           MOVX    @DPTR,A
   1840                  if (st.chip_cfg.active_low_int)
   \   000051   90....       MOV     DPTR,#st + 27
   \   000054   E0           MOVX    A,@DPTR
   \   000055   6009         JZ      ??mpu_set_bypass_5
   1841                      tmp |= BIT_ACTL;
   \   000057   85..82       MOV     DPL,?XSP + 0
   \   00005A   85..83       MOV     DPH,?XSP + 1
   \   00005D   7482         MOV     A,#-0x7e
   \   00005F   F0           MOVX    @DPTR,A
   1842                  if (st.chip_cfg.latched_int)
   \                     ??mpu_set_bypass_5:
   \   000060   90....       MOV     DPTR,#st + 28
   \   000063   E0           MOVX    A,@DPTR
   \   000064   600A         JZ      ??mpu_set_bypass_6
   1843                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   000066   85..82       MOV     DPL,?XSP + 0
   \   000069   85..83       MOV     DPH,?XSP + 1
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   4430         ORL     A,#0x30
   \   00006F   F0           MOVX    @DPTR,A
   1844                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_6:
   \   000070                ; Setup parameters for call to function MPU_Write_Len
   \   000070   85..82       MOV     DPL,?XSP + 0
   \   000073   85..83       MOV     DPH,?XSP + 1
   \   000076   AC82         MOV     R4,DPL
   \   000078   AD83         MOV     R5,DPH
   \   00007A   7B01         MOV     R3,#0x1
   \   00007C   90....       MOV     DPTR,#st
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   2414         ADD     A,#0x14
   \   000082   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1845                      return -1;
   1846              } else {
   \                     ??CrossCallReturnLabel_151:
   \   000085   70A9         JNZ     ??mpu_set_bypass_3
   \   000087   8065         SJMP    ??mpu_set_bypass_7
   1847                  /* Enable I2C master mode if compass is being used. */
   1848                  if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \                     ??mpu_set_bypass_1:
   \   000089                ; Setup parameters for call to function MPU_Read_Len
   \   000089   12....       LCALL   ??Subroutine117_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00008C   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   00008F   709F         JNZ     ??mpu_set_bypass_3
   1849                      return -1;
   1850                  if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
   \   000091   90....       MOV     DPTR,#st + 6
   \   000094   E0           MOVX    A,@DPTR
   \   000095   A2E0         MOV     C,0xE0 /* A   */.0
   \   000097   85..82       MOV     DPL,?XSP + 0
   \   00009A   85..83       MOV     DPH,?XSP + 1
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   5004         JNC     ??mpu_set_bypass_8
   1851                      tmp |= BIT_AUX_IF_EN;
   \   0000A0   D2E5         SETB    0xE0 /* A   */.5
   \   0000A2   8002         SJMP    ??mpu_set_bypass_9
   1852                  else
   1853                      tmp &= ~BIT_AUX_IF_EN;
   \                     ??mpu_set_bypass_8:
   \   0000A4   C2E5         CLR     0xE0 /* A   */.5
   \                     ??mpu_set_bypass_9:
   \   0000A6   F0           MOVX    @DPTR,A
   1854                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
   \   0000A7                ; Setup parameters for call to function MPU_Write_Len
   \   0000A7   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   0000AA   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_174:
   \   0000AD   7081         JNZ     ??mpu_set_bypass_3
   1855                      return -1;
   1856                  delay_ms(3);
   \   0000AF                ; Setup parameters for call to function delay_ms
   \   0000AF   7A03         MOV     R2,#0x3
   \   0000B1   7B00         MOV     R3,#0x0
   \   0000B3   12....       LCALL   ??delay_ms?relay
   1857                  if (st.chip_cfg.active_low_int)
   \   0000B6   90....       MOV     DPTR,#st + 27
   \   0000B9   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_252:
   \   0000BC   6004         JZ      ??mpu_set_bypass_10
   1858                      tmp = BIT_ACTL;
   \   0000BE   7480         MOV     A,#-0x80
   \   0000C0   8001         SJMP    ??mpu_set_bypass_11
   1859                  else
   1860                      tmp = 0;
   \                     ??mpu_set_bypass_10:
   \   0000C2   E4           CLR     A
   \                     ??mpu_set_bypass_11:
   \   0000C3   F0           MOVX    @DPTR,A
   1861                  if (st.chip_cfg.latched_int)
   \   0000C4   90....       MOV     DPTR,#st + 28
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   600A         JZ      ??mpu_set_bypass_12
   1862                      tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   0000CA   85..82       MOV     DPL,?XSP + 0
   \   0000CD   85..83       MOV     DPH,?XSP + 1
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   4430         ORL     A,#0x30
   \   0000D3   F0           MOVX    @DPTR,A
   1863                  if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_bypass_12:
   \   0000D4                ; Setup parameters for call to function MPU_Write_Len
   \   0000D4   85..82       MOV     DPL,?XSP + 0
   \   0000D7   85..83       MOV     DPH,?XSP + 1
   \   0000DA   AC82         MOV     R4,DPL
   \   0000DC   AD83         MOV     R5,DPH
   \   0000DE   7B01         MOV     R3,#0x1
   \   0000E0   90....       MOV     DPTR,#st
   \   0000E3   E0           MOVX    A,@DPTR
   \   0000E4   2414         ADD     A,#0x14
   \   0000E6   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   1864                      return -1;
   1865              }
   \                     ??CrossCallReturnLabel_152:
   \   0000E9   6003         JZ      $+5
   \   0000EB   02....       LJMP    ??mpu_set_bypass_3 & 0xFFFF
   1866              st.chip_cfg.bypass_mode = bypass_on;
   \                     ??mpu_set_bypass_7:
   \   0000EE   EE           MOV     A,R6
   \   0000EF   90....       MOV     DPTR,#st + 13
   \   0000F2   F0           MOVX    @DPTR,A
   1867              return 0;
   \                     ??mpu_set_bypass_0:
   \   0000F3   7A00         MOV     R2,#0x0
   \   0000F5   7B00         MOV     R3,#0x0
   \                     ??mpu_set_bypass_4:
   \   0000F7   02....       LJMP    ?Subroutine0 & 0xFFFF
   1868          }
   1869          
   1870          /**
   1871           *  @brief      Set interrupt level.
   1872           *  @param[in]  active_low  1 for active low, 0 for active high.
   1873           *  @return     0 if successful.
   1874           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1875          int mpu_set_int_level(unsigned char active_low)
   \                     mpu_set_int_level:
   1876          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1877              st.chip_cfg.active_low_int = active_low;
   \   000004   E9           MOV     A,R1
   \   000005   90....       MOV     DPTR,#st + 27
   \   000008   80..         SJMP    ??Subroutine122_0
   1878              return 0;
   1879          }
   1880          
   1881          /**
   1882           *  @brief      Enable latched interrupts.
   1883           *  Any MPU register will clear the interrupt.
   1884           *  @param[in]  enable  1 to enable, 0 to disable.
   1885           *  @return     0 if successful.
   1886           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1887          int mpu_set_int_latched(unsigned char enable)
   \                     mpu_set_int_latched:
   1888          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1889              unsigned char tmp;
   1890              if (st.chip_cfg.latched_int == enable)
   \   00000C   90....       MOV     DPTR,#st + 28
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   6051         JZ      ??mpu_set_int_latched_0
   1891                  return 0;
   1892          
   1893              if (enable)
   \   000013   EE           MOV     A,R6
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   6004         JZ      ??mpu_set_int_latched_1
   1894                  tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
   \   00001C   7430         MOV     A,#0x30
   \   00001E   8001         SJMP    ??mpu_set_int_latched_2
   1895              else
   1896                  tmp = 0;
   \                     ??mpu_set_int_latched_1:
   \   000020   E4           CLR     A
   \                     ??mpu_set_int_latched_2:
   \   000021   F0           MOVX    @DPTR,A
   1897              if (st.chip_cfg.bypass_mode)
   \   000022   90....       MOV     DPTR,#st + 13
   \   000025   E0           MOVX    A,@DPTR
   \   000026   600A         JZ      ??mpu_set_int_latched_3
   1898                  tmp |= BIT_BYPASS_EN;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   D2E1         SETB    0xE0 /* A   */.1
   \   000031   F0           MOVX    @DPTR,A
   1899              if (st.chip_cfg.active_low_int)
   \                     ??mpu_set_int_latched_3:
   \   000032   90....       MOV     DPTR,#st + 27
   \   000035   E0           MOVX    A,@DPTR
   \   000036   600A         JZ      ??mpu_set_int_latched_4
   1900                  tmp |= BIT_ACTL;
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E7         SETB    0xE0 /* A   */.7
   \   000041   F0           MOVX    @DPTR,A
   1901              if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
   \                     ??mpu_set_int_latched_4:
   \   000042                ; Setup parameters for call to function MPU_Write_Len
   \   000042   85..82       MOV     DPL,?XSP + 0
   \   000045   85..83       MOV     DPH,?XSP + 1
   \   000048   AC82         MOV     R4,DPL
   \   00004A   AD83         MOV     R5,DPH
   \   00004C   7B01         MOV     R3,#0x1
   \   00004E   90....       MOV     DPTR,#st
   \   000051   E0           MOVX    A,@DPTR
   \   000052   2414         ADD     A,#0x14
   \   000054   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_153:
   \   000057   6006         JZ      ??mpu_set_int_latched_5
   1902                  return -1;
   \   000059   7AFF         MOV     R2,#-0x1
   \   00005B   7BFF         MOV     R3,#-0x1
   \   00005D   8009         SJMP    ??mpu_set_int_latched_6
   1903              st.chip_cfg.latched_int = enable;
   \                     ??mpu_set_int_latched_5:
   \   00005F   EE           MOV     A,R6
   \   000060   90....       MOV     DPTR,#st + 28
   \   000063   F0           MOVX    @DPTR,A
   1904              return 0;
   \                     ??mpu_set_int_latched_0:
   \   000064   7A00         MOV     R2,#0x0
   \   000066   7B00         MOV     R3,#0x0
   \                     ??mpu_set_int_latched_6:
   \   000068   02....       LJMP    ?Subroutine0 & 0xFFFF
   1905          }
   1906          
   1907          #ifdef MPU6050

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1908          static int get_accel_prod_shift(float *st_shift)
   \                     get_accel_prod_shift:
   1909          {
   \   000000   74EE         MOV     A,#-0x12
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 18
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 8,R2
   \   00000C   8B..         MOV     ?V0 + 9,R3
   1910              unsigned char tmp[4], shift_code[3], ii;
   1911          
   1912              if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
   \   00000E                ; Setup parameters for call to function MPU_Read_Len
   \   00000E   7403         MOV     A,#0x3
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7B04         MOV     R3,#0x4
   \   000019   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_256:
   \   00001C   6005         JZ      ??get_accel_prod_shift_0
   1913                  return 0x07;
   \   00001E   7A07         MOV     R2,#0x7
   \   000020   02....       LJMP    ??get_accel_prod_shift_1 & 0xFFFF
   1914          
   1915              shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
   \                     ??get_accel_prod_shift_0:
   \   000023   7406         MOV     A,#0x6
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   C4           SWAP    A
   \   00002B   540F         ANL     A,#0xf
   \   00002D   5403         ANL     A,#0x3
   \   00002F   F8           MOV     R0,A
   \   000030   7403         MOV     A,#0x3
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   F0           MOVX    @DPTR,A
   1916              shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
   \   00003F   E9           MOV     A,R1
   \   000040   13           RRC     A
   \   000041   13           RRC     A
   \   000042   543F         ANL     A,#0x3f
   \   000044   5403         ANL     A,#0x3
   \   000046   F8           MOV     R0,A
   \   000047   7404         MOV     A,#0x4
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   00004F   C0E0         PUSH    A
   \   000051   7401         MOV     A,#0x1
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   D0E0         POP     A
   \   000058   F0           MOVX    @DPTR,A
   1917              shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
   \   000059   7403         MOV     A,#0x3
   \   00005B   59           ANL     A,R1
   \   00005C   F8           MOV     R0,A
   \   00005D   7405         MOV     A,#0x5
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000065   C0E0         PUSH    A
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   D0E0         POP     A
   \   00006E   F0           MOVX    @DPTR,A
   1918              for (ii = 0; ii < 3; ii++) {
   \   00006F   7E00         MOV     R6,#0x0
   1919                  if (!shift_code[ii]) {
   \                     ??get_accel_prod_shift_2:
   \   000071   8E..         MOV     ?V0 + 0,R6
   \   000073   12....       LCALL   ?Subroutine69 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000076   7018         JNZ     ??get_accel_prod_shift_3
   1920                      st_shift[ii] = 0.f;
   \   000078   90....       MOV     DPTR,#__Constant_0
   \   00007B   12....       LCALL   ?XLOAD_R2345
   \   00007E   75..00       MOV     ?V0 + 1,#0x0
   \   000081   7402         MOV     A,#0x2
   \   000083   78..         MOV     R0,#?V0 + 0
   \   000085   12....       LCALL   ?S_SHL
   \   000088   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   00008B   12....       LCALL   ?XSTORE_R2345
   1921                      continue;
   \   00008E   8059         SJMP    ??get_accel_prod_shift_4
   1922                  }
   1923                  /* Equivalent to..
   1924                   * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
   1925                   */
   1926                  st_shift[ii] = 0.34f;
   \                     ??get_accel_prod_shift_3:
   \   000090   90....       MOV     DPTR,#__Constant_3eae147b
   \   000093   12....       LCALL   ?XLOAD_R2345
   \   000096   75..00       MOV     ?V0 + 1,#0x0
   \   000099   7402         MOV     A,#0x2
   \   00009B   78..         MOV     R0,#?V0 + 0
   \   00009D   12....       LCALL   ?S_SHL
   \   0000A0   12....       LCALL   ?Subroutine70 & 0xFFFF
   \                     ??CrossCallReturnLabel_103:
   \   0000A3   12....       LCALL   ?XSTORE_R2345
   \   0000A6   8035         SJMP    ??get_accel_prod_shift_5
   1927                  while (--shift_code[ii])
   1928                      st_shift[ii] *= 1.034f;
   \                     ??get_accel_prod_shift_6:
   \   0000A8   75..00       MOV     ?V0 + 1,#0x0
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   78..         MOV     R0,#?V0 + 0
   \   0000AF   12....       LCALL   ?S_SHL
   \   0000B2   E5..         MOV     A,?V0 + 8
   \   0000B4   25..         ADD     A,?V0 + 0
   \   0000B6   FA           MOV     R2,A
   \   0000B7   E5..         MOV     A,?V0 + 9
   \   0000B9   35..         ADDC    A,?V0 + 1
   \   0000BB   FB           MOV     R3,A
   \   0000BC   8A82         MOV     DPL,R2
   \   0000BE   8B83         MOV     DPH,R3
   \   0000C0   78..         MOV     R0,#?V0 + 0
   \   0000C2   12....       LCALL   ?L_MOV_X
   \   0000C5   90....       MOV     DPTR,#__Constant_3f845a1d
   \   0000C8   78..         MOV     R0,#?V0 + 4
   \   0000CA   12....       LCALL   ?L_MOV_X
   \   0000CD   78..         MOV     R0,#?V0 + 0
   \   0000CF   79..         MOV     R1,#?V0 + 4
   \   0000D1   12....       LCALL   ?FLT_MUL
   \   0000D4   8A82         MOV     DPL,R2
   \   0000D6   8B83         MOV     DPH,R3
   \   0000D8   78..         MOV     R0,#?V0 + 0
   \   0000DA   12....       LCALL   ?L_MOV_TO_X
   \                     ??get_accel_prod_shift_5:
   \   0000DD   8E82         MOV     DPL,R6
   \   0000DF   8582..       MOV     ?V0 + 0,DPL
   \   0000E2   12....       LCALL   ?Subroutine69 & 0xFFFF
   1929              }
   \                     ??CrossCallReturnLabel_101:
   \   0000E5   14           DEC     A
   \   0000E6   F0           MOVX    @DPTR,A
   \   0000E7   70BF         JNZ     ??get_accel_prod_shift_6
   \                     ??get_accel_prod_shift_4:
   \   0000E9   0E           INC     R6
   \   0000EA   EE           MOV     A,R6
   \   0000EB   C3           CLR     C
   \   0000EC   9403         SUBB    A,#0x3
   \   0000EE   4081         JC      ??get_accel_prod_shift_2
   1930              return 0;
   \   0000F0   7A00         MOV     R2,#0x0
   \                     ??get_accel_prod_shift_1:
   \   0000F2   7B00         MOV     R3,#0x0
   \   0000F4   7407         MOV     A,#0x7
   \   0000F6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F9   7F0A         MOV     R7,#0xa
   \   0000FB   02....       LJMP    ?BANKED_LEAVE_XDATA
   1931          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E5..         MOV     A,?V0 + 8
   \   000002   25..         ADD     A,?V0 + 0
   \   000004   F582         MOV     DPL,A
   \   000006   E5..         MOV     A,?V0 + 9
   \   000008   35..         ADDC    A,?V0 + 1
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   25..         ADD     A,?V0 + 0
   \   00000A   F582         MOV     DPL,A
   \   00000C   E583         MOV     A,DPH
   \   00000E   3400         ADDC    A,#0x0
   \   000010   F583         MOV     DPH,A
   \   000012   E0           MOVX    A,@DPTR
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ??Subroutine118_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_234:
   \   000003   541C         ANL     A,#0x1c
   \   000005   48           ORL     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   7A0D         MOV     R2,#0xd
   \   000002                REQUIRE ??Subroutine125_0
   \   000002                ; // Fall through to label ??Subroutine125_0
   1932          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1933          static int accel_self_test(long *bias_regular, long *bias_st)
   \                     accel_self_test:
   1934          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   12....       LCALL   ?Subroutine52 & 0xFFFF
   1935              int jj, result = 0;
   1936              float st_shift[3], st_shift_cust, st_shift_var;
   1937          
   1938              get_accel_prod_shift(st_shift);
   \                     ??CrossCallReturnLabel_70:
   \   000013                ; Setup parameters for call to function get_accel_prod_shift
   \   000013   7402         MOV     A,#0x2
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??get_accel_prod_shift?relay
   1939              for(jj = 0; jj < 3; jj++) {
   \   00001F   7E00         MOV     R6,#0x0
   \   000021   7F00         MOV     R7,#0x0
   1940                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??accel_self_test_0:
   \   000023   8E..         MOV     ?V0 + 2,R6
   \   000025   8F..         MOV     ?V0 + 3,R7
   \   000027   7402         MOV     A,#0x2
   \   000029   78..         MOV     R0,#?V0 + 2
   \   00002B   12....       LCALL   ?S_SHL
   \   00002E   85....       MOV     ?V0 + 0,?V0 + 2
   \   000031   85....       MOV     ?V0 + 1,?V0 + 3
   \   000034                ; Setup parameters for call to function labs
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   25..         ADD     A,?V0 + 0
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   35..         ADDC    A,?V0 + 1
   \   000042   8882         MOV     DPL,R0
   \   000044   F583         MOV     DPH,A
   \   000046   78..         MOV     R0,#?V0 + 4
   \   000048   12....       LCALL   ?L_MOV_X
   \   00004B   E5..         MOV     A,?V0 + 14
   \   00004D   25..         ADD     A,?V0 + 0
   \   00004F   F582         MOV     DPL,A
   \   000051   E5..         MOV     A,?V0 + 15
   \   000053   35..         ADDC    A,?V0 + 1
   \   000055   F583         MOV     DPH,A
   \   000057   78..         MOV     R0,#?V0 + 4
   \   000059   12....       LCALL   ?L_SUB_X
   \   00005C   AA..         MOV     R2,?V0 + 4
   \   00005E   AB..         MOV     R3,?V0 + 5
   \   000060   AC..         MOV     R4,?V0 + 6
   \   000062   AD..         MOV     R5,?V0 + 7
   \   000064   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000067   12....       LCALL   ?L_TO_FLT
   \   00006A   90....       MOV     DPTR,#__Constant_37800000
   \   00006D   78..         MOV     R0,#?V0 + 8
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 4
   \   000074   79..         MOV     R1,#?V0 + 8
   \   000076   12....       LCALL   ?FLT_MUL
   1941                  if (st_shift[jj]) {
   \   000079   7402         MOV     A,#0x2
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000081   78..         MOV     R0,#?V0 + 8
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   90....       MOV     DPTR,#__Constant_0
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_X
   \   00008E   78..         MOV     R0,#?V0 + 8
   \   000090   79..         MOV     R1,#?V0 + 0
   \   000092   12....       LCALL   ?FLT_EQ
   \   000095   6044         JZ      ??accel_self_test_1
   1942                      st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
   1943                      if (fabs(st_shift_var) > test.max_accel_var)
                                 ^
Warning[Pe223]: function "fabsf" declared implicitly
   \   000097                ; Setup parameters for call to function fabsf
   \   000097   8E..         MOV     ?V0 + 0,R6
   \   000099   8F..         MOV     ?V0 + 1,R7
   \   00009B   7402         MOV     A,#0x2
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?S_SHL
   \   0000A2   7402         MOV     A,#0x2
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   12....       LCALL   ?Subroutine71 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   0000AA   78..         MOV     R0,#?V0 + 0
   \   0000AC   12....       LCALL   ?L_MOV_X
   \   0000AF   78..         MOV     R0,#?V0 + 4
   \   0000B1   79..         MOV     R1,#?V0 + 0
   \   0000B3   12....       LCALL   ?FLT_DIV
   \   0000B6   90....       MOV     DPTR,#__Constant_bf800000
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?L_MOV_X
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   79..         MOV     R1,#?V0 + 0
   \   0000C2   12....       LCALL   ?FLT_ADD
   \   0000C5   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   0000C8   4033         JC      ??accel_self_test_2
   1944                          result |= 1 << jj;
   \                     ??accel_self_test_3:
   \   0000CA   75..01       MOV     ?V0 + 0,#0x1
   \   0000CD   75..00       MOV     ?V0 + 1,#0x0
   \   0000D0   EE           MOV     A,R6
   \   0000D1   78..         MOV     R0,#?V0 + 0
   \   0000D3   12....       LCALL   ?S_SHL
   \   0000D6   12....       LCALL   ?Subroutine72 & 0xFFFF
   1945                  } else if ((st_shift_cust < test.min_g) ||
   \                     ??CrossCallReturnLabel_106:
   \   0000D9   8022         SJMP    ??accel_self_test_2
   1946                      (st_shift_cust > test.max_g))
   \                     ??accel_self_test_1:
   \   0000DB   90....       MOV     DPTR,#__Constant_3e99999a
   \   0000DE   78..         MOV     R0,#?V0 + 0
   \   0000E0   12....       LCALL   ?L_MOV_X
   \   0000E3   78..         MOV     R0,#?V0 + 4
   \   0000E5   79..         MOV     R1,#?V0 + 0
   \   0000E7   12....       LCALL   ?FLT_LT
   \   0000EA   40DE         JC      ??accel_self_test_3
   \   0000EC   90....       MOV     DPTR,#__Constant_3f733334
   \   0000EF   78..         MOV     R0,#?V0 + 0
   \   0000F1   12....       LCALL   ?L_MOV_X
   \   0000F4   78..         MOV     R0,#?V0 + 4
   \   0000F6   79..         MOV     R1,#?V0 + 0
   \   0000F8   12....       LCALL   ?FLT_GE
   \   0000FB   40CD         JC      ??accel_self_test_3
   1947                      result |= 1 << jj;
   1948              }
   \                     ??accel_self_test_2:
   \   0000FD   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000100   5003         JNC     $+5
   \   000102   02....       LJMP    ??accel_self_test_0 & 0xFFFF
   1949          
   1950              return result;
   \   000105   AA..         MOV     R2,?V0 + 12
   \   000107   AB..         MOV     R3,?V0 + 13
   \   000109   740E         MOV     A,#0xe
   \   00010B                REQUIRE ?Subroutine6
   \   00010B                ; // Fall through to label ?Subroutine6
   1951          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F10         MOV     R7,#0x10
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   E582         MOV     A,DPL
   \   000002   25..         ADD     A,?V0 + 0
   \   000004   F582         MOV     DPL,A
   \   000006   E583         MOV     A,DPH
   \   000008   35..         ADDC    A,?V0 + 1
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002   45..         ORL     A,?V0 + 12
   \   000004   F5..         MOV     ?V0 + 12,A
   \   000006   E5..         MOV     A,?V0 + 1
   \   000008   45..         ORL     A,?V0 + 13
   \   00000A   F5..         MOV     ?V0 + 13,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   12....       LCALL   ??labs?relay
   \   000003   8A..         MOV     ?V0 + 4,R2
   \   000005   8B..         MOV     ?V0 + 5,R3
   \   000007   8C..         MOV     ?V0 + 6,R4
   \   000009   8D..         MOV     ?V0 + 7,R5
   \   00000B   78..         MOV     R0,#?V0 + 4
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   AA..         MOV     R2,?V0 + 4
   \   000002   AB..         MOV     R3,?V0 + 5
   \   000004   AC..         MOV     R4,?V0 + 6
   \   000006   AD..         MOV     R5,?V0 + 7
   \   000008   12....       LCALL   ??fabsf?relay
   \   00000B   C3           CLR     C
   \   00000C   EA           MOV     A,R2
   \   00000D   9401         SUBB    A,#0x1
   \   00000F   EB           MOV     A,R3
   \   000010   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_314:
   \   000013   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_131:
   \   000003   9403         SUBB    A,#0x3
   \   000005   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_315:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   8C..         MOV     ?V0 + 14,R4
   \   000007   8D..         MOV     ?V0 + 15,R5
   \   000009   75..00       MOV     ?V0 + 12,#0x0
   \   00000C   75..00       MOV     ?V0 + 13,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine96:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine94:
   \   000000   EF           MOV     A,R7
   \   000001                REQUIRE ??Subroutine133_0
   \   000001                ; // Fall through to label ??Subroutine133_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine133_0:
   \   000000   9400         SUBB    A,#0x0
   \   000002   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000004   65D0         XRL     A,PSW
   \   000006   33           RLC     A
   \   000007   22           RET
   1952          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1953          static int gyro_self_test(long *bias_regular, long *bias_st)
   \                     gyro_self_test:
   1954          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 5
   \   000005   74FB         MOV     A,#-0x5
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7403         MOV     A,#0x3
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine52 & 0xFFFF
   1955              int jj, result = 0;
   1956              unsigned char tmp[3];
   1957              float st_shift, st_shift_cust, st_shift_var;
   1958          
   1959              if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
   \                     ??CrossCallReturnLabel_71:
   \   000012                ; Setup parameters for call to function MPU_Read_Len
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   7B03         MOV     R3,#0x3
   \   00001E   12....       LCALL   ?Subroutine13 & 0xFFFF
   \                     ??CrossCallReturnLabel_257:
   \   000021   6007         JZ      ??gyro_self_test_0
   1960                  return 0x07;
   \   000023   7A07         MOV     R2,#0x7
   \   000025   7B00         MOV     R3,#0x0
   \   000027   02....       LJMP    ??gyro_self_test_1 & 0xFFFF
   1961          
   1962              tmp[0] &= 0x1F;
   \                     ??gyro_self_test_0:
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   541F         ANL     A,#0x1f
   \   000033   F0           MOVX    @DPTR,A
   1963              tmp[1] &= 0x1F;
   \   000034   7401         MOV     A,#0x1
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   541F         ANL     A,#0x1f
   \   00003C   F0           MOVX    @DPTR,A
   1964              tmp[2] &= 0x1F;
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   E0           MOVX    A,@DPTR
   \   000043   541F         ANL     A,#0x1f
   \   000045   F0           MOVX    @DPTR,A
   1965          
   1966              for (jj = 0; jj < 3; jj++) {
   \   000046   7E00         MOV     R6,#0x0
   \   000048   7F00         MOV     R7,#0x0
   1967                  st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
   \                     ??gyro_self_test_2:
   \   00004A   8E..         MOV     ?V0 + 0,R6
   \   00004C   8F..         MOV     ?V0 + 1,R7
   \   00004E   7402         MOV     A,#0x2
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?S_SHL
   \   000055   AA..         MOV     R2,?V0 + 0
   \   000057   AB..         MOV     R3,?V0 + 1
   \   000059                ; Setup parameters for call to function labs
   \   000059   7403         MOV     A,#0x3
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   2A           ADD     A,R2
   \   000060   F8           MOV     R0,A
   \   000061   A3           INC     DPTR
   \   000062   E0           MOVX    A,@DPTR
   \   000063   3B           ADDC    A,R3
   \   000064   8882         MOV     DPL,R0
   \   000066   F583         MOV     DPH,A
   \   000068   78..         MOV     R0,#?V0 + 0
   \   00006A   12....       LCALL   ?L_MOV_X
   \   00006D   E5..         MOV     A,?V0 + 14
   \   00006F   2A           ADD     A,R2
   \   000070   F582         MOV     DPL,A
   \   000072   E5..         MOV     A,?V0 + 15
   \   000074   3B           ADDC    A,R3
   \   000075   F583         MOV     DPH,A
   \   000077   78..         MOV     R0,#?V0 + 0
   \   000079   12....       LCALL   ?L_SUB_X
   \   00007C   AA..         MOV     R2,?V0 + 0
   \   00007E   AB..         MOV     R3,?V0 + 1
   \   000080   AC..         MOV     R4,?V0 + 2
   \   000082   AD..         MOV     R5,?V0 + 3
   \   000084   12....       LCALL   ?Subroutine68 & 0xFFFF
   \                     ??CrossCallReturnLabel_99:
   \   000087   12....       LCALL   ?L_TO_FLT
   \   00008A   90....       MOV     DPTR,#__Constant_37800000
   \   00008D   78..         MOV     R0,#?V0 + 0
   \   00008F   12....       LCALL   ?L_MOV_X
   \   000092   78..         MOV     R0,#?V0 + 4
   \   000094   79..         MOV     R1,#?V0 + 0
   \   000096   12....       LCALL   ?FLT_MUL
   1968                  if (tmp[jj]) {
   \   000099   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   00009C   604C         JZ      ??gyro_self_test_3
   1969                      st_shift = 3275.f / test.gyro_sens;
   \   00009E   90....       MOV     DPTR,#__Constant_41c80000
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_MOV_X
   \   0000A6   800F         SJMP    ??gyro_self_test_4
   1970                      while (--tmp[jj])
   1971                          st_shift *= 1.046f;
   \                     ??gyro_self_test_5:
   \   0000A8   90....       MOV     DPTR,#__Constant_3f85e354
   \   0000AB   78..         MOV     R0,#?V0 + 8
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 8
   \   0000B4   12....       LCALL   ?FLT_MUL
   \                     ??gyro_self_test_4:
   \   0000B7   12....       LCALL   ?Subroutine66 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   0000BA   14           DEC     A
   \   0000BB   F0           MOVX    @DPTR,A
   \   0000BC   70EA         JNZ     ??gyro_self_test_5
   1972                      st_shift_var = st_shift_cust / st_shift - 1.f;
   1973                      if (fabs(st_shift_var) > test.max_gyro_var)
                                 ^
Warning[Pe223]: function "fabsf" declared implicitly
   \   0000BE                ; Setup parameters for call to function fabsf
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   79..         MOV     R1,#?V0 + 0
   \   0000C2   12....       LCALL   ?FLT_DIV
   \   0000C5   90....       MOV     DPTR,#__Constant_bf800000
   \   0000C8   78..         MOV     R0,#?V0 + 0
   \   0000CA   12....       LCALL   ?L_MOV_X
   \   0000CD   78..         MOV     R0,#?V0 + 4
   \   0000CF   79..         MOV     R1,#?V0 + 0
   \   0000D1   12....       LCALL   ?FLT_ADD
   \   0000D4   12....       LCALL   ?Subroutine67 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   0000D7   4033         JC      ??gyro_self_test_6
   1974                          result |= 1 << jj;
   \                     ??gyro_self_test_7:
   \   0000D9   75..01       MOV     ?V0 + 0,#0x1
   \   0000DC   75..00       MOV     ?V0 + 1,#0x0
   \   0000DF   EE           MOV     A,R6
   \   0000E0   78..         MOV     R0,#?V0 + 0
   \   0000E2   12....       LCALL   ?S_SHL
   \   0000E5   12....       LCALL   ?Subroutine72 & 0xFFFF
   1975                  } else if ((st_shift_cust < test.min_dps) ||
   \                     ??CrossCallReturnLabel_107:
   \   0000E8   8022         SJMP    ??gyro_self_test_6
   1976                      (st_shift_cust > test.max_dps))
   \                     ??gyro_self_test_3:
   \   0000EA   90....       MOV     DPTR,#__Constant_41200000
   \   0000ED   78..         MOV     R0,#?V0 + 0
   \   0000EF   12....       LCALL   ?L_MOV_X
   \   0000F2   78..         MOV     R0,#?V0 + 4
   \   0000F4   79..         MOV     R1,#?V0 + 0
   \   0000F6   12....       LCALL   ?FLT_LT
   \   0000F9   40DE         JC      ??gyro_self_test_7
   \   0000FB   90....       MOV     DPTR,#__Constant_42d20001
   \   0000FE   78..         MOV     R0,#?V0 + 0
   \   000100   12....       LCALL   ?L_MOV_X
   \   000103   78..         MOV     R0,#?V0 + 4
   \   000105   79..         MOV     R1,#?V0 + 0
   \   000107   12....       LCALL   ?FLT_GE
   \   00010A   40CD         JC      ??gyro_self_test_7
   1977                      result |= 1 << jj;
   1978              }
   \                     ??gyro_self_test_6:
   \   00010C   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   00010F   5003         JNC     $+5
   \   000111   02....       LJMP    ??gyro_self_test_2 & 0xFFFF
   1979              return result;
   \   000114   AA..         MOV     R2,?V0 + 12
   \   000116   AB..         MOV     R3,?V0 + 13
   \                     ??gyro_self_test_1:
   \   000118   7405         MOV     A,#0x5
   \   00011A   02....       LJMP    ?Subroutine6 & 0xFFFF
   1980          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   2E           ADD     A,R6
   \   000009   F582         MOV     DPL,A
   \   00000B   E583         MOV     A,DPH
   \   00000D   3F           ADDC    A,R7
   \   00000E   F583         MOV     DPH,A
   \   000010   E0           MOVX    A,@DPTR
   \   000011   22           RET
   1981          
   1982          #ifdef AK89xx_SECONDARY
   1983          static int compass_self_test(void)
   1984          {
   1985              unsigned char tmp[6];
   1986              unsigned char tries = 10;
   1987              int result = 0x07;
   1988              short data;
   1989          
   1990              mpu_set_bypass(1);
   1991          
   1992              tmp[0] = AKM_POWER_DOWN;
   1993              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   1994                  return 0x07;
   1995              tmp[0] = AKM_BIT_SELF_TEST;
   1996              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp))
   1997                  goto AKM_restore;
   1998              tmp[0] = AKM_MODE_SELF_TEST;
   1999              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp))
   2000                  goto AKM_restore;
   2001          
   2002              do {
   2003                  delay_ms(10);
   2004                  if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 1, tmp))
   2005                      goto AKM_restore;
   2006                  if (tmp[0] & AKM_DATA_READY)
   2007                      break;
   2008              } while (tries--);
   2009              if (!(tmp[0] & AKM_DATA_READY))
   2010                  goto AKM_restore;
   2011          
   2012              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_HXL, 6, tmp))
   2013                  goto AKM_restore;
   2014          
   2015              result = 0;
   2016              data = (short)(tmp[1] << 8) | tmp[0];
   2017              if ((data > 100) || (data < -100))
   2018                  result |= 0x01;
   2019              data = (short)(tmp[3] << 8) | tmp[2];
   2020              if ((data > 100) || (data < -100))
   2021                  result |= 0x02;
   2022              data = (short)(tmp[5] << 8) | tmp[4];
   2023              if ((data > -300) || (data < -1000))
   2024                  result |= 0x04;
   2025          
   2026          AKM_restore:
   2027              tmp[0] = 0 | SUPPORTS_AK89xx_HIGH_SENS;
   2028              i2c_write(st.chip_cfg.compass_addr, AKM_REG_ASTC, 1, tmp);
   2029              tmp[0] = SUPPORTS_AK89xx_HIGH_SENS;
   2030              i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp);
   2031              mpu_set_bypass(0);
   2032              return result;
   2033          }
   2034          #endif
   2035          #endif
   2036          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2037          static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
   \                     get_st_biases:
   2038          {
   \   000000   74E9         MOV     A,#-0x17
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 23
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 12,R2
   \   00000C   8B..         MOV     ?V0 + 13,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   89..         MOV     ?V0 + 14,R1
   2039              unsigned char data[MAX_PACKET_LENGTH];
   2040              unsigned char packet_count, ii;
   2041              unsigned short fifo_count;
   2042          
   2043              data[0] = 0x01;
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   7401         MOV     A,#0x1
   \   00001C   F0           MOVX    @DPTR,A
   2044              data[1] = 0;
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E4           CLR     A
   \   000021   12....       LCALL   ??Subroutine106_0 & 0xFFFF
   2045              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \                     ??CrossCallReturnLabel_140:
   \   000024   6007         JZ      ??get_st_biases_0
   2046                  return -1;
   \                     ??get_st_biases_1:
   \   000026   7AFF         MOV     R2,#-0x1
   \   000028   7BFF         MOV     R3,#-0x1
   \   00002A   02....       LJMP    ??get_st_biases_2 & 0xFFFF
   2047              delay_ms(200);
   \                     ??get_st_biases_0:
   \   00002D                ; Setup parameters for call to function delay_ms
   \   00002D   7AC8         MOV     R2,#-0x38
   \   00002F   7B00         MOV     R3,#0x0
   \   000031   12....       LCALL   ??delay_ms?relay
   2048              data[0] = 0;
   \   000034   12....       LCALL   ?Subroutine46 & 0xFFFF
   2049              if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_302:
   \   000037   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_154:
   \   00003A   70EA         JNZ     ??get_st_biases_1
   2050                  return -1;
   2051              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \   00003C                ; Setup parameters for call to function MPU_Write_Len
   \   00003C   85..82       MOV     DPL,?XSP + 0
   \   00003F   85..83       MOV     DPH,?XSP + 1
   \   000042   12....       LCALL   ??Subroutine129_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_276:
   \   000045   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_175:
   \   000048   70DC         JNZ     ??get_st_biases_1
   2052                  return -1;
   2053              if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   \   00004A                ; Setup parameters for call to function MPU_Write_Len
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   7B01         MOV     R3,#0x1
   \   000056   12....       LCALL   ??Subroutine107_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000059   70CB         JNZ     ??get_st_biases_1
   2054                  return -1;
   2055              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   \   00005B                ; Setup parameters for call to function MPU_Write_Len
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AC82         MOV     R4,DPL
   \   000063   AD83         MOV     R5,DPH
   \   000065   7B01         MOV     R3,#0x1
   \   000067   90....       MOV     DPTR,#st
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   2417         ADD     A,#0x17
   \   00006D   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_155:
   \   000070   70B4         JNZ     ??get_st_biases_1
   2056                  return -1;
   2057              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   000072                ; Setup parameters for call to function MPU_Write_Len
   \   000072   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_231:
   \   000075   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_176:
   \   000078   70AC         JNZ     ??get_st_biases_1
   2058                  return -1;
   2059              data[0] = BIT_FIFO_RST | BIT_DMP_RST;
   \   00007A   85..82       MOV     DPL,?XSP + 0
   \   00007D   85..83       MOV     DPH,?XSP + 1
   \   000080   740C         MOV     A,#0xc
   \   000082   F0           MOVX    @DPTR,A
   2060              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   000083                ; Setup parameters for call to function MPU_Write_Len
   \   000083   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   000086   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_177:
   \   000089   709B         JNZ     ??get_st_biases_1
   2061                  return -1;
   2062              delay_ms(15);
   \   00008B                ; Setup parameters for call to function delay_ms
   \   00008B   7A0F         MOV     R2,#0xf
   \   00008D   7B00         MOV     R3,#0x0
   \   00008F   12....       LCALL   ??delay_ms?relay
   2063              data[0] = st.test->reg_lpf;
   \   000092   90....       MOV     DPTR,#st + 33
   \   000095   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_322:
   \   000098   A3           INC     DPTR
   \   000099   12....       LCALL   ?Subroutine14 & 0xFFFF
   2064              if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \                     ??CrossCallReturnLabel_0:
   \   00009C   A3           INC     DPTR
   \   00009D   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_178:
   \   0000A0   7084         JNZ     ??get_st_biases_1
   2065                  return -1;
   2066              data[0] = st.test->reg_rate_div;
   \   0000A2   90....       MOV     DPTR,#st + 33
   \   0000A5   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_323:
   \   0000A8   12....       LCALL   ?Subroutine14 & 0xFFFF
   2067              if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
   \                     ??CrossCallReturnLabel_1:
   \   0000AB   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_179:
   \   0000AE   6003         JZ      $+5
   \   0000B0   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2068                  return -1;
   2069              if (hw_test)
   \   0000B3   E5..         MOV     A,?V0 + 14
   \   0000B5   90....       MOV     DPTR,#st + 33
   \   0000B8   6007         JZ      ??get_st_biases_3
   2070                  data[0] = st.test->reg_gyro_fsr | 0xE0;
   \   0000BA   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   0000BD   44E0         ORL     A,#0xe0
   \   0000BF   8003         SJMP    ??CrossCallReturnLabel_6
   2071              else
   2072                  data[0] = st.test->reg_gyro_fsr;
   \                     ??get_st_biases_3:
   \   0000C1   12....       LCALL   ?Subroutine17 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   0000C4   85..82       MOV     DPL,?XSP + 0
   \   0000C7   85..83       MOV     DPH,?XSP + 1
   \   0000CA   F0           MOVX    @DPTR,A
   2073              if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
   \   0000CB                ; Setup parameters for call to function MPU_Write_Len
   \   0000CB   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   0000CE   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_180:
   \   0000D1   6003         JZ      $+5
   \   0000D3   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2074                  return -1;
   2075          
   2076              if (hw_test)
   \   0000D6   E5..         MOV     A,?V0 + 14
   \   0000D8   6013         JZ      ??get_st_biases_4
   2077                  data[0] = st.test->reg_accel_fsr | 0xE0;
   \   0000DA   90....       MOV     DPTR,#st + 33
   \   0000DD   E0           MOVX    A,@DPTR
   \   0000DE   240B         ADD     A,#0xb
   \   0000E0   12....       LCALL   ?Subroutine83 & 0xFFFF
   \                     ??CrossCallReturnLabel_192:
   \   0000E3   44E0         ORL     A,#0xe0
   \   0000E5   85..82       MOV     DPL,?XSP + 0
   \   0000E8   85..83       MOV     DPH,?XSP + 1
   \   0000EB   8008         SJMP    ??get_st_biases_5
   2078              else
   2079                  data[0] = test.reg_accel_fsr;
   \                     ??get_st_biases_4:
   \   0000ED   85..82       MOV     DPL,?XSP + 0
   \   0000F0   85..83       MOV     DPH,?XSP + 1
   \   0000F3   7418         MOV     A,#0x18
   \                     ??get_st_biases_5:
   \   0000F5   12....       LCALL   ?Subroutine20 & 0xFFFF
   2080              if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_281:
   \   0000F8   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_181:
   \   0000FB   6003         JZ      $+5
   \   0000FD   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2081                  return -1;
   2082              if (hw_test)
   \   000100   E5..         MOV     A,?V0 + 14
   \   000102   6007         JZ      ??get_st_biases_6
   2083                  delay_ms(200);
   \   000104                ; Setup parameters for call to function delay_ms
   \   000104   7AC8         MOV     R2,#-0x38
   \   000106   7B00         MOV     R3,#0x0
   \   000108   12....       LCALL   ??delay_ms?relay
   2084          
   2085              /* Fill FIFO for test.wait_ms milliseconds. */
   2086              data[0] = BIT_FIFO_EN;
   \                     ??get_st_biases_6:
   \   00010B   85..82       MOV     DPL,?XSP + 0
   \   00010E   85..83       MOV     DPH,?XSP + 1
   \   000111   7440         MOV     A,#0x40
   \   000113   F0           MOVX    @DPTR,A
   2087              if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
   \   000114                ; Setup parameters for call to function MPU_Write_Len
   \   000114   12....       LCALL   ??Subroutine116_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000117   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_182:
   \   00011A   6003         JZ      $+5
   \   00011C   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2088                  return -1;
   2089          
   2090              data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
   \   00011F   85..82       MOV     DPL,?XSP + 0
   \   000122   85..83       MOV     DPH,?XSP + 1
   \   000125   7478         MOV     A,#0x78
   \   000127   12....       LCALL   ??Subroutine128_0 & 0xFFFF
   2091              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_273:
   \   00012A   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_183:
   \   00012D   6003         JZ      $+5
   \   00012F   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2092                  return -1;
   2093              delay_ms(test.wait_ms);
   \   000132                ; Setup parameters for call to function delay_ms
   \   000132   7A32         MOV     R2,#0x32
   \   000134   7B00         MOV     R3,#0x0
   \   000136   12....       LCALL   ??delay_ms?relay
   2094              data[0] = 0;
   \   000139   12....       LCALL   ?Subroutine31 & 0xFFFF
   2095              if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
   \                     ??CrossCallReturnLabel_272:
   \   00013C   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_184:
   \   00013F   6003         JZ      $+5
   \   000141   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2096                  return -1;
   2097          
   2098              if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
   \   000144                ; Setup parameters for call to function MPU_Read_Len
   \   000144   12....       LCALL   ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000147   12....       LCALL   ??Subroutine114_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   00014A   6003         JZ      $+5
   \   00014C   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2099                  return -1;
   2100          
   2101              fifo_count = (data[0] << 8) | data[1];
   2102              packet_count = fifo_count / MAX_PACKET_LENGTH;
   \   00014F   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000152   12....       LCALL   ?XSTACK_DISP0_8
   \   000155   E0           MOVX    A,@DPTR
   \   000156   F8           MOV     R0,A
   \   000157   7A0C         MOV     R2,#0xc
   \   000159   7B00         MOV     R3,#0x0
   \   00015B   12....       LCALL   ?US_DIV_MOD
   \   00015E   E8           MOV     A,R0
   \   00015F   F5..         MOV     ?V0 + 1,A
   2103              gyro[0] = gyro[1] = gyro[2] = 0;
   \   000161   90....       MOV     DPTR,#__Constant_0
   \   000164   12....       LCALL   ?XLOAD_R2345
   \   000167   85..82       MOV     DPL,?V0 + 12
   \   00016A   85..83       MOV     DPH,?V0 + 13
   \   00016D   A3           INC     DPTR
   \   00016E   A3           INC     DPTR
   \   00016F   A3           INC     DPTR
   \   000170   A3           INC     DPTR
   \   000171   A3           INC     DPTR
   \   000172   A3           INC     DPTR
   \   000173   A3           INC     DPTR
   \   000174   A3           INC     DPTR
   \   000175   12....       LCALL   ?XSTORE_R2345
   \   000178   90....       MOV     DPTR,#__Constant_0
   \   00017B   12....       LCALL   ?XLOAD_R2345
   \   00017E   85..82       MOV     DPL,?V0 + 12
   \   000181   85..83       MOV     DPH,?V0 + 13
   \   000184   A3           INC     DPTR
   \   000185   A3           INC     DPTR
   \   000186   A3           INC     DPTR
   \   000187   A3           INC     DPTR
   \   000188   12....       LCALL   ?XSTORE_R2345
   \   00018B   90....       MOV     DPTR,#__Constant_0
   \   00018E   12....       LCALL   ?XLOAD_R2345
   \   000191   85..82       MOV     DPL,?V0 + 12
   \   000194   85..83       MOV     DPH,?V0 + 13
   \   000197   12....       LCALL   ?XSTORE_R2345
   2104              accel[0] = accel[1] = accel[2] = 0;
   \   00019A   90....       MOV     DPTR,#__Constant_0
   \   00019D   12....       LCALL   ?XLOAD_R2345
   \   0001A0   8E82         MOV     DPL,R6
   \   0001A2   8F83         MOV     DPH,R7
   \   0001A4   A3           INC     DPTR
   \   0001A5   A3           INC     DPTR
   \   0001A6   A3           INC     DPTR
   \   0001A7   A3           INC     DPTR
   \   0001A8   A3           INC     DPTR
   \   0001A9   A3           INC     DPTR
   \   0001AA   A3           INC     DPTR
   \   0001AB   A3           INC     DPTR
   \   0001AC   12....       LCALL   ?XSTORE_R2345
   \   0001AF   90....       MOV     DPTR,#__Constant_0
   \   0001B2   12....       LCALL   ?XLOAD_R2345
   \   0001B5   8E82         MOV     DPL,R6
   \   0001B7   8F83         MOV     DPH,R7
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   A3           INC     DPTR
   \   0001BC   A3           INC     DPTR
   \   0001BD   12....       LCALL   ?XSTORE_R2345
   \   0001C0   90....       MOV     DPTR,#__Constant_0
   \   0001C3   12....       LCALL   ?XLOAD_R2345
   \   0001C6   8E82         MOV     DPL,R6
   \   0001C8   8F83         MOV     DPH,R7
   \   0001CA   12....       LCALL   ?XSTORE_R2345
   2105          
   2106              for (ii = 0; ii < packet_count; ii++) {
   \   0001CD   75..00       MOV     ?V0 + 0,#0x0
   \   0001D0   02....       LJMP    ??get_st_biases_7 & 0xFFFF
   2107                  short accel_cur[3], gyro_cur[3];
   2108                  if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
   \                     ??get_st_biases_8:
   \   0001D3                ; Setup parameters for call to function MPU_Read_Len
   \   0001D3   85..82       MOV     DPL,?XSP + 0
   \   0001D6   85..83       MOV     DPH,?XSP + 1
   \   0001D9   AC82         MOV     R4,DPL
   \   0001DB   AD83         MOV     R5,DPH
   \   0001DD   7B0C         MOV     R3,#0xc
   \   0001DF   90....       MOV     DPTR,#st
   \   0001E2   E0           MOVX    A,@DPTR
   \   0001E3   240B         ADD     A,#0xb
   \   0001E5   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   0001E8   6003         JZ      $+5
   \   0001EA   02....       LJMP    ??get_st_biases_1 & 0xFFFF
   2109                      return -1;
   2110                  accel_cur[0] = ((short)data[0] << 8) | data[1];
   \   0001ED   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_47:
   \   0001F0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F3   E0           MOVX    A,@DPTR
   \   0001F4   F8           MOV     R0,A
   \   0001F5   7412         MOV     A,#0x12
   \   0001F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0001FA   12....       LCALL   ?Subroutine54 & 0xFFFF
   2111                  accel_cur[1] = ((short)data[2] << 8) | data[3];
   \                     ??CrossCallReturnLabel_218:
   \   0001FD   12....       LCALL   ?XSTACK_DISP0_8
   \   000200   E0           MOVX    A,@DPTR
   \   000201   F9           MOV     R1,A
   \   000202   7403         MOV     A,#0x3
   \   000204   12....       LCALL   ?XSTACK_DISP0_8
   \   000207   E0           MOVX    A,@DPTR
   \   000208   FC           MOV     R4,A
   \   000209   E9           MOV     A,R1
   \   00020A   FD           MOV     R5,A
   \   00020B   7414         MOV     A,#0x14
   \   00020D   12....       LCALL   ?XSTACK_DISP0_8
   \   000210   EC           MOV     A,R4
   \   000211   F0           MOVX    @DPTR,A
   \   000212   A3           INC     DPTR
   \   000213   ED           MOV     A,R5
   \   000214   F0           MOVX    @DPTR,A
   2112                  accel_cur[2] = ((short)data[4] << 8) | data[5];
   \   000215   7404         MOV     A,#0x4
   \   000217   12....       LCALL   ?XSTACK_DISP0_8
   \   00021A   E0           MOVX    A,@DPTR
   \   00021B   F9           MOV     R1,A
   \   00021C   7405         MOV     A,#0x5
   \   00021E   12....       LCALL   ?XSTACK_DISP0_8
   \   000221   E0           MOVX    A,@DPTR
   \   000222   FA           MOV     R2,A
   \   000223   E9           MOV     A,R1
   \   000224   FB           MOV     R3,A
   \   000225   7416         MOV     A,#0x16
   \   000227   12....       LCALL   ?XSTACK_DISP0_8
   \   00022A   EA           MOV     A,R2
   \   00022B   F0           MOVX    @DPTR,A
   \   00022C   A3           INC     DPTR
   \   00022D   EB           MOV     A,R3
   \   00022E   F0           MOVX    @DPTR,A
   2113                  accel[0] += (long)accel_cur[0];
   \   00022F   7412         MOV     A,#0x12
   \   000231   12....       LCALL   ?XSTACK_DISP0_8
   \   000234   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000237   8E82         MOV     DPL,R6
   \   000239   8F83         MOV     DPH,R7
   \   00023B   78..         MOV     R0,#?V0 + 4
   \   00023D   12....       LCALL   ?L_ADD_TO_X
   2114                  accel[1] += (long)accel_cur[1];
   \   000240   8C..         MOV     ?V0 + 4,R4
   \   000242   ED           MOV     A,R5
   \   000243   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000246   78..         MOV     R0,#?V0 + 4
   \   000248   12....       LCALL   ?L_ADD_TO_X
   2115                  accel[2] += (long)accel_cur[2];
   \   00024B   8A..         MOV     ?V0 + 4,R2
   \   00024D   EB           MOV     A,R3
   \   00024E   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   000251   A3           INC     DPTR
   \   000252   A3           INC     DPTR
   \   000253   A3           INC     DPTR
   \   000254   A3           INC     DPTR
   \   000255   78..         MOV     R0,#?V0 + 4
   \   000257   12....       LCALL   ?L_ADD_TO_X
   2116                  gyro_cur[0] = (((short)data[6] << 8) | data[7]);
   \   00025A   7406         MOV     A,#0x6
   \   00025C   12....       LCALL   ?XSTACK_DISP0_8
   \   00025F   E0           MOVX    A,@DPTR
   \   000260   F9           MOV     R1,A
   \   000261   7407         MOV     A,#0x7
   \   000263   12....       LCALL   ?XSTACK_DISP0_8
   \   000266   E0           MOVX    A,@DPTR
   \   000267   F8           MOV     R0,A
   \   000268   740C         MOV     A,#0xc
   \   00026A   12....       LCALL   ?XSTACK_DISP0_8
   \   00026D   E8           MOV     A,R0
   \   00026E   12....       LCALL   ??Subroutine119_0 & 0xFFFF
   2117                  gyro_cur[1] = (((short)data[8] << 8) | data[9]);
   \                     ??CrossCallReturnLabel_245:
   \   000271   7408         MOV     A,#0x8
   \   000273   12....       LCALL   ?XSTACK_DISP0_8
   \   000276   E0           MOVX    A,@DPTR
   \   000277   F9           MOV     R1,A
   \   000278   7409         MOV     A,#0x9
   \   00027A   12....       LCALL   ?XSTACK_DISP0_8
   \   00027D   E0           MOVX    A,@DPTR
   \   00027E   FC           MOV     R4,A
   \   00027F   E9           MOV     A,R1
   \   000280   FD           MOV     R5,A
   \   000281   740E         MOV     A,#0xe
   \   000283   12....       LCALL   ?XSTACK_DISP0_8
   \   000286   EC           MOV     A,R4
   \   000287   F0           MOVX    @DPTR,A
   \   000288   A3           INC     DPTR
   \   000289   ED           MOV     A,R5
   \   00028A   F0           MOVX    @DPTR,A
   2118                  gyro_cur[2] = (((short)data[10] << 8) | data[11]);
   \   00028B   740A         MOV     A,#0xa
   \   00028D   12....       LCALL   ?XSTACK_DISP0_8
   \   000290   E0           MOVX    A,@DPTR
   \   000291   F9           MOV     R1,A
   \   000292   740B         MOV     A,#0xb
   \   000294   12....       LCALL   ?XSTACK_DISP0_8
   \   000297   E0           MOVX    A,@DPTR
   \   000298   FA           MOV     R2,A
   \   000299   E9           MOV     A,R1
   \   00029A   FB           MOV     R3,A
   \   00029B   7410         MOV     A,#0x10
   \   00029D   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A0   EA           MOV     A,R2
   \   0002A1   F0           MOVX    @DPTR,A
   \   0002A2   A3           INC     DPTR
   \   0002A3   EB           MOV     A,R3
   \   0002A4   F0           MOVX    @DPTR,A
   2119                  gyro[0] += (long)gyro_cur[0];
   \   0002A5   740C         MOV     A,#0xc
   \   0002A7   12....       LCALL   ?XSTACK_DISP0_8
   \   0002AA   12....       LCALL   ?Subroutine15 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   0002AD   85..82       MOV     DPL,?V0 + 12
   \   0002B0   85..83       MOV     DPH,?V0 + 13
   \   0002B3   78..         MOV     R0,#?V0 + 4
   \   0002B5   12....       LCALL   ?L_ADD_TO_X
   2120                  gyro[1] += (long)gyro_cur[1];
   \   0002B8   8C..         MOV     ?V0 + 4,R4
   \   0002BA   ED           MOV     A,R5
   \   0002BB   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   0002BE   78..         MOV     R0,#?V0 + 4
   \   0002C0   12....       LCALL   ?L_ADD_TO_X
   2121                  gyro[2] += (long)gyro_cur[2];
   \   0002C3   8A..         MOV     ?V0 + 4,R2
   \   0002C5   EB           MOV     A,R3
   \   0002C6   12....       LCALL   ?Subroutine62 & 0xFFFF
   2122              }
   \                     ??CrossCallReturnLabel_87:
   \   0002C9   A3           INC     DPTR
   \   0002CA   A3           INC     DPTR
   \   0002CB   A3           INC     DPTR
   \   0002CC   A3           INC     DPTR
   \   0002CD   78..         MOV     R0,#?V0 + 4
   \   0002CF   12....       LCALL   ?L_ADD_TO_X
   \   0002D2   05..         INC     ?V0 + 0
   \                     ??get_st_biases_7:
   \   0002D4   E5..         MOV     A,?V0 + 0
   \   0002D6   C3           CLR     C
   \   0002D7   95..         SUBB    A,?V0 + 1
   \   0002D9   5003         JNC     $+5
   \   0002DB   02....       LJMP    ??get_st_biases_8 & 0xFFFF
   2123          #ifdef EMPL_NO_64BIT
   2124              gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
   2125              gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
   2126              gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
   2127              if (has_accel) {
   2128                  accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
   2129                      packet_count);
   2130                  accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
   2131                      packet_count);
   2132                  accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
   2133                      packet_count);
   2134                  /* Don't remove gravity! */
   2135                  accel[2] -= 65536L;
   2136              }
   2137          #else
   2138              gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
   \   0002DE   E5..         MOV     A,?V0 + 1
   \   0002E0   F5..         MOV     ?V0 + 4,A
   \   0002E2   E4           CLR     A
   \   0002E3   F5..         MOV     ?V0 + 5,A
   \   0002E5   F5..         MOV     ?V0 + 6,A
   \   0002E7   F5..         MOV     ?V0 + 7,A
   \   0002E9   85..82       MOV     DPL,?V0 + 12
   \   0002EC   85..83       MOV     DPH,?V0 + 13
   \   0002EF   78..         MOV     R0,#?V0 + 0
   \   0002F1   12....       LCALL   ?L_MOV_X
   \   0002F4   7410         MOV     A,#0x10
   \   0002F6   78..         MOV     R0,#?V0 + 0
   \   0002F8   12....       LCALL   ?L_SHL
   \   0002FB   90....       MOV     DPTR,#__Constant_83
   \   0002FE   78..         MOV     R0,#?V0 + 8
   \   000300   12....       LCALL   ?L_MOV_X
   \   000303   78..         MOV     R0,#?V0 + 0
   \   000305   79..         MOV     R1,#?V0 + 8
   \   000307   12....       LCALL   ?UL_DIV_MOD
   \   00030A   85....       MOV     ?V0 + 8,?V0 + 4
   \   00030D   85....       MOV     ?V0 + 9,?V0 + 5
   \   000310   85....       MOV     ?V0 + 10,?V0 + 6
   \   000313   85....       MOV     ?V0 + 11,?V0 + 7
   \   000316   78..         MOV     R0,#?V0 + 0
   \   000318   79..         MOV     R1,#?V0 + 8
   \   00031A   12....       LCALL   ?UL_DIV_MOD
   \   00031D   85..82       MOV     DPL,?V0 + 12
   \   000320   85..83       MOV     DPH,?V0 + 13
   \   000323   78..         MOV     R0,#?V0 + 0
   \   000325   12....       LCALL   ?L_MOV_TO_X
   2139              gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
   \   000328   E5..         MOV     A,?V0 + 12
   \   00032A   2404         ADD     A,#0x4
   \   00032C   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_269:
   \   00032F   12....       LCALL   ?L_MOV_X
   \   000332   7410         MOV     A,#0x10
   \   000334   78..         MOV     R0,#?V0 + 0
   \   000336   12....       LCALL   ?L_SHL
   \   000339   90....       MOV     DPTR,#__Constant_83
   \   00033C   78..         MOV     R0,#?V0 + 8
   \   00033E   12....       LCALL   ?L_MOV_X
   \   000341   78..         MOV     R0,#?V0 + 0
   \   000343   79..         MOV     R1,#?V0 + 8
   \   000345   12....       LCALL   ?UL_DIV_MOD
   \   000348   85....       MOV     ?V0 + 8,?V0 + 4
   \   00034B   85....       MOV     ?V0 + 9,?V0 + 5
   \   00034E   85....       MOV     ?V0 + 10,?V0 + 6
   \   000351   85....       MOV     ?V0 + 11,?V0 + 7
   \   000354   78..         MOV     R0,#?V0 + 0
   \   000356   79..         MOV     R1,#?V0 + 8
   \   000358   12....       LCALL   ?UL_DIV_MOD
   \   00035B   8A82         MOV     DPL,R2
   \   00035D   8B83         MOV     DPH,R3
   \   00035F   78..         MOV     R0,#?V0 + 0
   \   000361   12....       LCALL   ?L_MOV_TO_X
   2140              gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
   \   000364   E5..         MOV     A,?V0 + 12
   \   000366   2408         ADD     A,#0x8
   \   000368   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_270:
   \   00036B   12....       LCALL   ?L_MOV_X
   \   00036E   7410         MOV     A,#0x10
   \   000370   78..         MOV     R0,#?V0 + 0
   \   000372   12....       LCALL   ?L_SHL
   \   000375   90....       MOV     DPTR,#__Constant_83
   \   000378   78..         MOV     R0,#?V0 + 8
   \   00037A   12....       LCALL   ?L_MOV_X
   \   00037D   78..         MOV     R0,#?V0 + 0
   \   00037F   79..         MOV     R1,#?V0 + 8
   \   000381   12....       LCALL   ?UL_DIV_MOD
   \   000384   85....       MOV     ?V0 + 8,?V0 + 4
   \   000387   85....       MOV     ?V0 + 9,?V0 + 5
   \   00038A   85....       MOV     ?V0 + 10,?V0 + 6
   \   00038D   85....       MOV     ?V0 + 11,?V0 + 7
   \   000390   78..         MOV     R0,#?V0 + 0
   \   000392   79..         MOV     R1,#?V0 + 8
   \   000394   12....       LCALL   ?UL_DIV_MOD
   \   000397   8A82         MOV     DPL,R2
   \   000399   8B83         MOV     DPH,R3
   \   00039B   78..         MOV     R0,#?V0 + 0
   \   00039D   12....       LCALL   ?L_MOV_TO_X
   2141              accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
   2142                  packet_count);
   \   0003A0   8E82         MOV     DPL,R6
   \   0003A2   8F83         MOV     DPH,R7
   \   0003A4   78..         MOV     R0,#?V0 + 8
   \   0003A6   12....       LCALL   ?L_MOV_X
   \   0003A9   7410         MOV     A,#0x10
   \   0003AB   78..         MOV     R0,#?V0 + 8
   \   0003AD   12....       LCALL   ?L_SHL
   \   0003B0   740B         MOV     A,#0xb
   \   0003B2   78..         MOV     R0,#?V0 + 8
   \   0003B4   12....       LCALL   ?UL_SHR
   \   0003B7   85....       MOV     ?V0 + 0,?V0 + 4
   \   0003BA   F5..         MOV     ?V0 + 1,A
   \   0003BC   F5..         MOV     ?V0 + 2,A
   \   0003BE   F5..         MOV     ?V0 + 3,A
   \   0003C0   78..         MOV     R0,#?V0 + 8
   \   0003C2   79..         MOV     R1,#?V0 + 0
   \   0003C4   12....       LCALL   ?UL_DIV_MOD
   \   0003C7   85....       MOV     ?V0 + 0,?V0 + 8
   \   0003CA   85....       MOV     ?V0 + 1,?V0 + 9
   \   0003CD   85....       MOV     ?V0 + 2,?V0 + 10
   \   0003D0   85....       MOV     ?V0 + 3,?V0 + 11
   \   0003D3   8E82         MOV     DPL,R6
   \   0003D5   8F83         MOV     DPH,R7
   \   0003D7   78..         MOV     R0,#?V0 + 0
   \   0003D9   12....       LCALL   ?L_MOV_TO_X
   2143              accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
   2144                  packet_count);
   \   0003DC   EE           MOV     A,R6
   \   0003DD   2404         ADD     A,#0x4
   \   0003DF   FA           MOV     R2,A
   \   0003E0   EF           MOV     A,R7
   \   0003E1   3400         ADDC    A,#0x0
   \   0003E3   FB           MOV     R3,A
   \   0003E4   8A82         MOV     DPL,R2
   \   0003E6   8B83         MOV     DPH,R3
   \   0003E8   78..         MOV     R0,#?V0 + 8
   \   0003EA   12....       LCALL   ?L_MOV_X
   \   0003ED   7410         MOV     A,#0x10
   \   0003EF   78..         MOV     R0,#?V0 + 8
   \   0003F1   12....       LCALL   ?L_SHL
   \   0003F4   740B         MOV     A,#0xb
   \   0003F6   78..         MOV     R0,#?V0 + 8
   \   0003F8   12....       LCALL   ?UL_SHR
   \   0003FB   85....       MOV     ?V0 + 0,?V0 + 4
   \   0003FE   F5..         MOV     ?V0 + 1,A
   \   000400   F5..         MOV     ?V0 + 2,A
   \   000402   F5..         MOV     ?V0 + 3,A
   \   000404   78..         MOV     R0,#?V0 + 8
   \   000406   79..         MOV     R1,#?V0 + 0
   \   000408   12....       LCALL   ?UL_DIV_MOD
   \   00040B   85....       MOV     ?V0 + 0,?V0 + 8
   \   00040E   85....       MOV     ?V0 + 1,?V0 + 9
   \   000411   85....       MOV     ?V0 + 2,?V0 + 10
   \   000414   85....       MOV     ?V0 + 3,?V0 + 11
   \   000417   8A82         MOV     DPL,R2
   \   000419   8B83         MOV     DPH,R3
   \   00041B   78..         MOV     R0,#?V0 + 0
   \   00041D   12....       LCALL   ?L_MOV_TO_X
   2145              accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
   2146                  packet_count);
   \   000420   EE           MOV     A,R6
   \   000421   2408         ADD     A,#0x8
   \   000423   FA           MOV     R2,A
   \   000424   EF           MOV     A,R7
   \   000425   12....       LCALL   ??Subroutine127_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_268:
   \   000428   12....       LCALL   ?L_MOV_X
   \   00042B   7410         MOV     A,#0x10
   \   00042D   78..         MOV     R0,#?V0 + 0
   \   00042F   12....       LCALL   ?L_SHL
   \   000432   740B         MOV     A,#0xb
   \   000434   78..         MOV     R0,#?V0 + 0
   \   000436   12....       LCALL   ?UL_SHR
   \   000439   78..         MOV     R0,#?V0 + 0
   \   00043B   79..         MOV     R1,#?V0 + 4
   \   00043D   12....       LCALL   ?UL_DIV_MOD
   \   000440   8A82         MOV     DPL,R2
   \   000442   8B83         MOV     DPH,R3
   \   000444   78..         MOV     R0,#?V0 + 0
   \   000446   12....       LCALL   ?L_MOV_TO_X
   2147              /* Don't remove gravity! */
   2148              if (accel[2] > 0L)
   \   000449   90....       MOV     DPTR,#__Constant_1
   \   00044C   78..         MOV     R0,#?V0 + 0
   \   00044E   12....       LCALL   ?L_MOV_X
   \   000451   8B83         MOV     DPH,R3
   \   000453   8A82         MOV     DPL,R2
   \   000455   78..         MOV     R0,#?V0 + 0
   \   000457   12....       LCALL   ?SL_GT_X
   \   00045A   4005         JC      ??get_st_biases_9
   2149                  accel[2] -= 65536L;
   \   00045C   90....       MOV     DPTR,#__Constant_ffff0000
   \   00045F   8003         SJMP    ??get_st_biases_10
   2150              else
   2151                  accel[2] += 65536L;
   \                     ??get_st_biases_9:
   \   000461   90....       MOV     DPTR,#__Constant_10000
   \                     ??get_st_biases_10:
   \   000464   78..         MOV     R0,#?V0 + 0
   \   000466   12....       LCALL   ?L_MOV_X
   \   000469   8E82         MOV     DPL,R6
   \   00046B   8F83         MOV     DPH,R7
   \   00046D   A3           INC     DPTR
   \   00046E   A3           INC     DPTR
   \   00046F   A3           INC     DPTR
   \   000470   A3           INC     DPTR
   \   000471   A3           INC     DPTR
   \   000472   A3           INC     DPTR
   \   000473   A3           INC     DPTR
   \   000474   A3           INC     DPTR
   \   000475   78..         MOV     R0,#?V0 + 0
   \   000477   12....       LCALL   ?L_ADD_TO_X
   2152          #endif
   2153          
   2154              return 0;
   \   00047A   7A00         MOV     R2,#0x0
   \   00047C   7B00         MOV     R3,#0x0
   \                     ??get_st_biases_2:
   \   00047E   7418         MOV     A,#0x18
   \   000480   12....       LCALL   ?DEALLOC_XSTACK8
   \   000483   7F0F         MOV     R7,#0xf
   \   000485   02....       LJMP    ?BANKED_LEAVE_XDATA
   2155          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_267:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine95:
   \   000000   F5..         MOV     ?V0 + 5,A
   \   000002                REQUIRE ??Subroutine126_0
   \   000002                ; // Fall through to label ??Subroutine126_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   12....       LCALL   ?Subroutine95 & 0xFFFF
   \                     ??CrossCallReturnLabel_266:
   \   000003   85..82       MOV     DPL,?V0 + 12
   \   000006   85..83       MOV     DPH,?V0 + 13
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   FA           MOV     R2,A
   \   000001   E5..         MOV     A,?V0 + 13
   \   000003                REQUIRE ??Subroutine127_0
   \   000003                ; // Fall through to label ??Subroutine127_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine127_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   FB           MOV     R3,A
   \   000003   8A82         MOV     DPL,R2
   \   000005   8B83         MOV     DPH,R3
   \   000007   78..         MOV     R0,#?V0 + 0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                ; Setup parameters for call to function MPU_Write_Len
   \   000001                REQUIRE ??Subroutine131_0
   \   000001                ; // Fall through to label ??Subroutine131_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine74 & 0xFFFF
   \                     ??CrossCallReturnLabel_110:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   F0           MOVX    @DPTR,A
   \   000010                ; Setup parameters for call to function MPU_Write_Len
   \   000010                ; Setup parameters for call to function MPU_Write_Len
   \   000010   12....       LCALL   ?Subroutine79 & 0xFFFF
   \                     ??CrossCallReturnLabel_285:
   \   000013   22           RET
   2156          
   2157          /**
   2158           *  @brief      Trigger gyro/accel/compass self-test.
   2159           *  On success/error, the self-test returns a mask representing the sensor(s)
   2160           *  that failed. For each bit, a one (1) represents a "pass" case; conversely,
   2161           *  a zero (0) indicates a failure.
   2162           *
   2163           *  \n The mask is defined as follows:
   2164           *  \n Bit 0:   Gyro.
   2165           *  \n Bit 1:   Accel.
   2166           *  \n Bit 2:   Compass.
   2167           *
   2168           *  \n Currently, the hardware self-test is unsupported for MPU6500. However,
   2169           *  this function can still be used to obtain the accel and gyro biases.
   2170           *
   2171           *  \n This function must be called with the device either face-up or face-down
   2172           *  (z-axis is parallel to gravity).
   2173           *  @param[out] gyro        Gyro biases in q16 format.
   2174           *  @param[out] accel       Accel biases (if applicable) in q16 format.
   2175           *  @return     Result mask (see above).
   2176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2177          int mpu_run_self_test(long *gyro, long *accel)
   \                     mpu_run_self_test:
   2178          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 4,R2
   \   00000C   8B..         MOV     ?V0 + 5,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
   2179          #ifdef MPU6050
   2180              const unsigned char tries = 2;
   2181              long gyro_st[3], accel_st[3];
   2182              unsigned char accel_result, gyro_result;
   2183          #ifdef AK89xx_SECONDARY
   2184              unsigned char compass_result;
   2185          #endif
   2186              int ii;
   2187          #endif
   2188              int result;
   2189              unsigned char accel_fsr, fifo_sensors, sensors_on;
   2190              unsigned short gyro_fsr, sample_rate, lpf;
   2191              unsigned char dmp_was_on;
   2192          
   2193              if (st.chip_cfg.dmp_on) {
   \   000012   90....       MOV     DPTR,#st + 29
   \   000015   E0           MOVX    A,@DPTR
   \   000016   600A         JZ      ??mpu_run_self_test_0
   2194                  mpu_set_dmp_state(0);
   \   000018                ; Setup parameters for call to function mpu_set_dmp_state
   \   000018   7900         MOV     R1,#0x0
   \   00001A   12....       LCALL   ??mpu_set_dmp_state?relay
   2195                  dmp_was_on = 1;
   \   00001D   75..01       MOV     ?V0 + 0,#0x1
   \   000020   8003         SJMP    ??mpu_run_self_test_1
   2196              } else
   2197                  dmp_was_on = 0;
   \                     ??mpu_run_self_test_0:
   \   000022   75..00       MOV     ?V0 + 0,#0x0
   2198          
   2199              /* Get initial settings. */
   2200              mpu_get_gyro_fsr(&gyro_fsr);
   \                     ??mpu_run_self_test_1:
   \   000025                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000025   7406         MOV     A,#0x6
   \   000027   12....       LCALL   ?XSTACK_DISP0_8
   \   00002A   AA82         MOV     R2,DPL
   \   00002C   AB83         MOV     R3,DPH
   \   00002E   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2201              mpu_get_accel_fsr(&accel_fsr);
   \   000031                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000031   7401         MOV     A,#0x1
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   AA82         MOV     R2,DPL
   \   000038   AB83         MOV     R3,DPH
   \   00003A   12....       LCALL   ??mpu_get_accel_fsr?relay
   2202              mpu_get_lpf(&lpf);
   \   00003D                ; Setup parameters for call to function mpu_get_lpf
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   AA82         MOV     R2,DPL
   \   000044   AB83         MOV     R3,DPH
   \   000046   12....       LCALL   ??mpu_get_lpf?relay
   2203              mpu_get_sample_rate(&sample_rate);
   \   000049                ; Setup parameters for call to function mpu_get_sample_rate
   \   000049   7404         MOV     A,#0x4
   \   00004B   12....       LCALL   ?XSTACK_DISP0_8
   \   00004E   AA82         MOV     R2,DPL
   \   000050   AB83         MOV     R3,DPH
   \   000052   12....       LCALL   ??mpu_get_sample_rate?relay
   2204              sensors_on = st.chip_cfg.sensors;
   \   000055   90....       MOV     DPTR,#st + 6
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V0 + 1,A
   2205              mpu_get_fifo_config(&fifo_sensors);
   \   00005B                ; Setup parameters for call to function mpu_get_fifo_config
   \   00005B   85..82       MOV     DPL,?XSP + 0
   \   00005E   85..83       MOV     DPH,?XSP + 1
   \   000061   AA82         MOV     R2,DPL
   \   000063   AB83         MOV     R3,DPH
   \   000065   12....       LCALL   ??mpu_get_fifo_config?relay
   2206          
   2207              /* For older chips, the self-test will be different. */
   2208          #if defined MPU6050
   2209              for (ii = 0; ii < tries; ii++)
   \   000068   7E00         MOV     R6,#0x0
   \   00006A   7F00         MOV     R7,#0x0
   2210                  if (!get_st_biases(gyro, accel, 0))
   \                     ??mpu_run_self_test_2:
   \   00006C                ; Setup parameters for call to function get_st_biases
   \   00006C   7900         MOV     R1,#0x0
   \   00006E   AC..         MOV     R4,?V0 + 2
   \   000070   AD..         MOV     R5,?V0 + 3
   \   000072   AA..         MOV     R2,?V0 + 4
   \   000074   AB..         MOV     R3,?V0 + 5
   \   000076   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_108:
   \   000079   6005         JZ      ??mpu_run_self_test_3
   \   00007B   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00007E   40EC         JC      ??mpu_run_self_test_2
   2211                      break;
   2212              if (ii == tries) {
   \                     ??mpu_run_self_test_3:
   \   000080   7402         MOV     A,#0x2
   \   000082   6E           XRL     A,R6
   \   000083   7001         JNZ     ??mpu_run_self_test_4
   \   000085   EF           MOV     A,R7
   \                     ??mpu_run_self_test_4:
   \   000086   7004         JNZ     ??mpu_run_self_test_5
   2213                  /* If we reach this point, we most likely encountered an I2C error.
   2214                   * We'll just report an error for all three sensors.
   2215                   */
   2216                  result = 0;
   \                     ??mpu_run_self_test_6:
   \   000088   7E00         MOV     R6,#0x0
   2217                  goto restore;
   \   00008A   805B         SJMP    ??mpu_run_self_test_7
   2218              }
   2219              for (ii = 0; ii < tries; ii++)
   \                     ??mpu_run_self_test_5:
   \   00008C   7E00         MOV     R6,#0x0
   \   00008E   7F00         MOV     R7,#0x0
   2220                  if (!get_st_biases(gyro_st, accel_st, 1))
   \                     ??mpu_run_self_test_8:
   \   000090                ; Setup parameters for call to function get_st_biases
   \   000090   7901         MOV     R1,#0x1
   \   000092   7408         MOV     A,#0x8
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   AC82         MOV     R4,DPL
   \   000099   AD83         MOV     R5,DPH
   \   00009B   7414         MOV     A,#0x14
   \   00009D   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A0   AA82         MOV     R2,DPL
   \   0000A2   AB83         MOV     R3,DPH
   \   0000A4   12....       LCALL   ?Subroutine73 & 0xFFFF
   \                     ??CrossCallReturnLabel_109:
   \   0000A7   6005         JZ      ??mpu_run_self_test_9
   \   0000A9   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   0000AC   40E2         JC      ??mpu_run_self_test_8
   2221                      break;
   2222              if (ii == tries) {
   \                     ??mpu_run_self_test_9:
   \   0000AE   7402         MOV     A,#0x2
   \   0000B0   6E           XRL     A,R6
   \   0000B1   7001         JNZ     ??mpu_run_self_test_10
   \   0000B3   EF           MOV     A,R7
   \                     ??mpu_run_self_test_10:
   \   0000B4   60D2         JZ      ??mpu_run_self_test_6
   2223                  /* Again, probably an I2C error. */
   2224                  result = 0;
   2225                  goto restore;
   2226              }
   2227              accel_result = accel_self_test(accel, accel_st);
   \   0000B6                ; Setup parameters for call to function accel_self_test
   \   0000B6   7408         MOV     A,#0x8
   \   0000B8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BB   AC82         MOV     R4,DPL
   \   0000BD   AD83         MOV     R5,DPH
   \   0000BF   AA..         MOV     R2,?V0 + 2
   \   0000C1   AB..         MOV     R3,?V0 + 3
   \   0000C3   12....       LCALL   ??accel_self_test?relay
   \   0000C6   EA           MOV     A,R2
   \   0000C7   F5..         MOV     ?V0 + 2,A
   2228              gyro_result = gyro_self_test(gyro, gyro_st);
   \   0000C9                ; Setup parameters for call to function gyro_self_test
   \   0000C9   7414         MOV     A,#0x14
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   AC82         MOV     R4,DPL
   \   0000D0   AD83         MOV     R5,DPH
   \   0000D2   AA..         MOV     R2,?V0 + 4
   \   0000D4   AB..         MOV     R3,?V0 + 5
   \   0000D6   12....       LCALL   ??gyro_self_test?relay
   2229          
   2230              result = 0;
   \   0000D9   7E00         MOV     R6,#0x0
   2231              if (!gyro_result)
   \   0000DB   EA           MOV     A,R2
   \   0000DC   7001         JNZ     ??mpu_run_self_test_11
   2232                  result |= 0x01;
   \   0000DE   0E           INC     R6
   2233              if (!accel_result)
   \                     ??mpu_run_self_test_11:
   \   0000DF   E5..         MOV     A,?V0 + 2
   \   0000E1   7004         JNZ     ??mpu_run_self_test_7
   2234                  result |= 0x02;
   \   0000E3   7402         MOV     A,#0x2
   \   0000E5   4E           ORL     A,R6
   \   0000E6   FE           MOV     R6,A
   2235          
   2236          #ifdef AK89xx_SECONDARY
   2237              compass_result = compass_self_test();
   2238              if (!compass_result)
   2239                  result |= 0x04;
   2240          #endif
   2241          restore:
   2242          #elif defined MPU6500
   2243              /* For now, this function will return a "pass" result for all three sensors
   2244               * for compatibility with current test applications.
   2245               */
   2246              get_st_biases(gyro, accel, 0);
   2247              result = 0x7;
   2248          #endif
   2249              /* Set to invalid values to ensure no I2C writes are skipped. */
   2250              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_run_self_test_7:
   \   0000E7   12....       LCALL   ?Subroutine47 & 0xFFFF
   2251              st.chip_cfg.accel_fsr = 0xFF;
   2252              st.chip_cfg.lpf = 0xFF;
   2253              st.chip_cfg.sample_rate = 0xFFFF;
   2254              st.chip_cfg.sensors = 0xFF;
   2255              st.chip_cfg.fifo_enable = 0xFF;
   2256              st.chip_cfg.clk_src = INV_CLK_PLL;
   2257              mpu_set_gyro_fsr(gyro_fsr);
   \                     ??CrossCallReturnLabel_60:
   \   0000EA                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   0000EA   7406         MOV     A,#0x6
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   12....       LCALL   ?Subroutine42 & 0xFFFF
   2258              mpu_set_accel_fsr(accel_fsr);
   \                     ??CrossCallReturnLabel_52:
   \   0000F2                ; Setup parameters for call to function mpu_set_accel_fsr
   \   0000F2   7401         MOV     A,#0x1
   \   0000F4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F7   E0           MOVX    A,@DPTR
   \   0000F8   F9           MOV     R1,A
   \   0000F9   12....       LCALL   ??mpu_set_accel_fsr?relay
   2259              mpu_set_lpf(lpf);
   \   0000FC                ; Setup parameters for call to function mpu_set_lpf
   \   0000FC   7402         MOV     A,#0x2
   \   0000FE   12....       LCALL   ?XSTACK_DISP0_8
   \   000101   12....       LCALL   ?Subroutine43 & 0xFFFF
   2260              mpu_set_sample_rate(sample_rate);
   \                     ??CrossCallReturnLabel_54:
   \   000104                ; Setup parameters for call to function mpu_set_sample_rate
   \   000104   7404         MOV     A,#0x4
   \   000106   12....       LCALL   ?XSTACK_DISP0_8
   \   000109   12....       LCALL   ?Subroutine35 & 0xFFFF
   2261              mpu_set_sensors(sensors_on);
   \                     ??CrossCallReturnLabel_28:
   \   00010C                ; Setup parameters for call to function mpu_set_sensors
   \   00010C   A9..         MOV     R1,?V0 + 1
   \   00010E   12....       LCALL   ??mpu_set_sensors?relay
   2262              mpu_configure_fifo(fifo_sensors);
   \   000111                ; Setup parameters for call to function mpu_configure_fifo
   \   000111   85..82       MOV     DPL,?XSP + 0
   \   000114   85..83       MOV     DPH,?XSP + 1
   \   000117   E0           MOVX    A,@DPTR
   \   000118   F9           MOV     R1,A
   \   000119   12....       LCALL   ??mpu_configure_fifo?relay
   2263          
   2264              if (dmp_was_on)
   \   00011C   E5..         MOV     A,?V0 + 0
   \   00011E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000120   5005         JNC     ??mpu_run_self_test_12
   2265                  mpu_set_dmp_state(1);
   \   000122                ; Setup parameters for call to function mpu_set_dmp_state
   \   000122   7901         MOV     R1,#0x1
   \   000124   12....       LCALL   ??mpu_set_dmp_state?relay
   2266          
   2267              return result;
   \                     ??mpu_run_self_test_12:
   \   000127   EE           MOV     A,R6
   \   000128   FA           MOV     R2,A
   \   000129   7B00         MOV     R3,#0x0
   \   00012B   7420         MOV     A,#0x20
   \   00012D                REQUIRE ?Subroutine2
   \   00012D                ; // Fall through to label ?Subroutine2
   2268          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   12....       LCALL   ??get_st_biases?relay
   \   000003   8B..         MOV     ?V0 + 7,R3
   \   000005   EA           MOV     A,R2
   \   000006   45..         ORL     A,?V0 + 7
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   12....       LCALL   ?Subroutine96 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000003   9402         SUBB    A,#0x2
   \   000005   12....       LCALL   ?Subroutine94 & 0xFFFF
   \                     ??CrossCallReturnLabel_316:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   90....       MOV     DPTR,#st + 4
   \   000003   74FF         MOV     A,#-0x1
   \   000005   12....       LCALL   ?Subroutine91 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000008   90....       MOV     DPTR,#st + 6
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   90....       MOV     DPTR,#st + 11
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   90....       MOV     DPTR,#st + 8
   \   000013   7401         MOV     A,#0x1
   \   000015   F0           MOVX    @DPTR,A
   \   000016   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   12....       LCALL   ??mpu_set_lpf?relay
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   12....       LCALL   ?Subroutine87 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   12....       LCALL   ??mpu_set_gyro_fsr?relay
   \   000006   22           RET
   2269          
   2270          /**
   2271           *  @brief      Write to the DMP memory.
   2272           *  This function prevents I2C writes past the bank boundaries. The DMP memory
   2273           *  is only accessible when the chip is awake.
   2274           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2275           *  @param[in]  length      Number of bytes to write.
   2276           *  @param[in]  data        Bytes to write to memory.
   2277           *  @return     0 if successful.
   2278           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2279          int mpu_write_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_write_mem:
   2280                  unsigned char *data)
   2281          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   \   00000E   740C         MOV     A,#0xc
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FE           MOV     R6,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FF           MOV     R7,A
   2282              unsigned char tmp[2];
   2283          
   2284              if (!data)
   \   000018   EE           MOV     A,R6
   \   000019   4F           ORL     A,R7
   \   00001A   7006         JNZ     ??mpu_write_mem_0
   2285                  return -1;
   \                     ??mpu_write_mem_1:
   \   00001C   7AFF         MOV     R2,#-0x1
   \   00001E   7BFF         MOV     R3,#-0x1
   \   000020   805A         SJMP    ??mpu_write_mem_2
   2286              if (!st.chip_cfg.sensors)
   \                     ??mpu_write_mem_0:
   \   000022   90....       MOV     DPTR,#st + 6
   \   000025   E0           MOVX    A,@DPTR
   \   000026   60F4         JZ      ??mpu_write_mem_1
   2287                  return -1;
   2288          
   2289              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000028   EB           MOV     A,R3
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   F0           MOVX    @DPTR,A
   2290              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine19 & 0xFFFF
   2291          
   2292              /* Check bank boundaries. */
   2293              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_287:
   \   000038   C082         PUSH    DPL
   \   00003A   C083         PUSH    DPH
   \   00003C   7401         MOV     A,#0x1
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000044   D083         POP     DPH
   \   000046   D082         POP     DPL
   \   000048   C3           CLR     C
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   98           SUBB    A,R0
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   99           SUBB    A,R1
   \   00004E   40CC         JC      ??mpu_write_mem_1
   2294                  return -1;
   2295          
   2296              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   000050                ; Setup parameters for call to function MPU_Write_Len
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   AC82         MOV     R4,DPL
   \   000058   AD83         MOV     R5,DPH
   \   00005A   7B02         MOV     R3,#0x2
   \   00005C   90....       MOV     DPTR,#st
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   2418         ADD     A,#0x18
   \   000062   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_156:
   \   000065   70B5         JNZ     ??mpu_write_mem_1
   2297                  return -1;
   2298              if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000067                ; Setup parameters for call to function MPU_Write_Len
   \   000067   EE           MOV     A,R6
   \   000068   FC           MOV     R4,A
   \   000069   EF           MOV     A,R7
   \   00006A   FD           MOV     R5,A
   \   00006B   AB..         MOV     R3,?V0 + 0
   \   00006D   90....       MOV     DPTR,#st
   \   000070   E0           MOVX    A,@DPTR
   \   000071   2415         ADD     A,#0x15
   \   000073   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   000076   70A4         JNZ     ??mpu_write_mem_1
   2299                  return -1;
   2300              return 0;
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B00         MOV     R3,#0x0
   \                     ??mpu_write_mem_2:
   \   00007C                REQUIRE ?Subroutine7
   \   00007C                ; // Fall through to label ?Subroutine7
   2301          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7402         MOV     A,#0x2
   \   000002   80..         SJMP    ??Subroutine135_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   90....       MOV     DPTR,#st + 2
   \   000005                REQUIRE ??Subroutine134_0
   \   000005                ; // Fall through to label ??Subroutine134_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine134_0:
   \   000000   12....       LCALL   ?Subroutine76 & 0xFFFF
   \                     ??CrossCallReturnLabel_291:
   \   000003   A3           INC     DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   25..         ADD     A,?V0 + 0
   \   000003   F8           MOV     R0,A
   \   000004   E4           CLR     A
   \   000005   35..         ADDC    A,?V0 + 1
   \   000007   F9           MOV     R1,A
   \   000008   22           RET
   2302          
   2303          /**
   2304           *  @brief      Read from the DMP memory.
   2305           *  This function prevents I2C reads past the bank boundaries. The DMP memory
   2306           *  is only accessible when the chip is awake.
   2307           *  @param[in]  mem_addr    Memory location (bank << 8 | start address)
   2308           *  @param[in]  length      Number of bytes to read.
   2309           *  @param[out] data        Bytes read from memory.
   2310           *  @return     0 if successful.
   2311           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2312          int mpu_read_mem(unsigned short mem_addr, unsigned short length,
   \                     mpu_read_mem:
   2313                  unsigned char *data)
   2314          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0 + 0,R4
   \   00000C   8D..         MOV     ?V0 + 1,R5
   \   00000E   740C         MOV     A,#0xc
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   FE           MOV     R6,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FF           MOV     R7,A
   2315              unsigned char tmp[2];
   2316          
   2317              if (!data)
   \   000018   EE           MOV     A,R6
   \   000019   4F           ORL     A,R7
   \   00001A   7006         JNZ     ??mpu_read_mem_0
   2318                  return -1;
   \                     ??mpu_read_mem_1:
   \   00001C   7AFF         MOV     R2,#-0x1
   \   00001E   7BFF         MOV     R3,#-0x1
   \   000020   805A         SJMP    ??mpu_read_mem_2
   2319              if (!st.chip_cfg.sensors)
   \                     ??mpu_read_mem_0:
   \   000022   90....       MOV     DPTR,#st + 6
   \   000025   E0           MOVX    A,@DPTR
   \   000026   60F4         JZ      ??mpu_read_mem_1
   2320                  return -1;
   2321          
   2322              tmp[0] = (unsigned char)(mem_addr >> 8);
   \   000028   EB           MOV     A,R3
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   F0           MOVX    @DPTR,A
   2323              tmp[1] = (unsigned char)(mem_addr & 0xFF);
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine19 & 0xFFFF
   2324          
   2325              /* Check bank boundaries. */
   2326              if (tmp[1] + length > st.hw->bank_size)
   \                     ??CrossCallReturnLabel_288:
   \   000038   C082         PUSH    DPL
   \   00003A   C083         PUSH    DPH
   \   00003C   7401         MOV     A,#0x1
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000044   D083         POP     DPH
   \   000046   D082         POP     DPL
   \   000048   C3           CLR     C
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   98           SUBB    A,R0
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   99           SUBB    A,R1
   \   00004E   40CC         JC      ??mpu_read_mem_1
   2327                  return -1;
   2328          
   2329              if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
   \   000050                ; Setup parameters for call to function MPU_Write_Len
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   AC82         MOV     R4,DPL
   \   000058   AD83         MOV     R5,DPH
   \   00005A   7B02         MOV     R3,#0x2
   \   00005C   90....       MOV     DPTR,#st
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   2418         ADD     A,#0x18
   \   000062   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_158:
   \   000065   70B5         JNZ     ??mpu_read_mem_1
   2330                  return -1;
   2331              if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
   \   000067                ; Setup parameters for call to function MPU_Read_Len
   \   000067   EE           MOV     A,R6
   \   000068   FC           MOV     R4,A
   \   000069   EF           MOV     A,R7
   \   00006A   FD           MOV     R5,A
   \   00006B   AB..         MOV     R3,?V0 + 0
   \   00006D   90....       MOV     DPTR,#st
   \   000070   E0           MOVX    A,@DPTR
   \   000071   2415         ADD     A,#0x15
   \   000073   12....       LCALL   ??Subroutine113_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000076   70A4         JNZ     ??mpu_read_mem_1
   2332                  return -1;
   2333              return 0;
   \   000078   7A00         MOV     R2,#0x0
   \   00007A   7B00         MOV     R3,#0x0
   \                     ??mpu_read_mem_2:
   \   00007C   02....       LJMP    ?Subroutine7 & 0xFFFF
   2334          }
   2335          
   2336          /**
   2337           *  @brief      Load and verify DMP image.
   2338           *  @param[in]  length      Length of DMP image.
   2339           *  @param[in]  firmware    DMP code.
   2340           *  @param[in]  start_addr  Starting address of DMP code memory.
   2341           *  @param[in]  sample_rate Fixed sampling rate used when DMP is enabled.
   2342           *  @return     0 if successful.
   2343           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2344          int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
   \                     mpu_load_firmware:
   2345              unsigned short start_addr, unsigned short sample_rate)
   2346          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 4,R4
   \   000010   8D..         MOV     ?V0 + 5,R5
   \   000012   7426         MOV     A,#0x26
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 3,A
   \   00001E   7428         MOV     A,#0x28
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F5..         MOV     ?V0 + 6,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F5..         MOV     ?V0 + 7,A
   2347              unsigned short ii;
   2348              unsigned short this_write;
   2349              /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
   2350          #define LOAD_CHUNK  (16)
   2351              unsigned char cur[LOAD_CHUNK], tmp[2];
   2352          
   2353              if (st.chip_cfg.dmp_loaded)
   \   00002A   90....       MOV     DPTR,#st + 30
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6007         JZ      ??mpu_load_firmware_0
   2354                  /* DMP should only be loaded once. */
   2355                  return -1;
   \                     ??mpu_load_firmware_1:
   \   000030   7AFF         MOV     R2,#-0x1
   \                     ??mpu_load_firmware_2:
   \   000032   7BFF         MOV     R3,#-0x1
   \   000034   02....       LJMP    ??CrossCallReturnLabel_299 & 0xFFFF
   2356          
   2357              if (!firmware)
   \                     ??mpu_load_firmware_0:
   \   000037   EC           MOV     A,R4
   \   000038   45..         ORL     A,?V0 + 5
   \   00003A   60F4         JZ      ??mpu_load_firmware_1
   2358                  return -1;
   2359              for (ii = 0; ii < length; ii += this_write) {
   \   00003C   7E00         MOV     R6,#0x0
   \   00003E   7F00         MOV     R7,#0x0
   \   000040   8008         SJMP    ??mpu_load_firmware_3
   \                     ??mpu_load_firmware_4:
   \   000042   EE           MOV     A,R6
   \   000043   25..         ADD     A,?V0 + 10
   \   000045   FE           MOV     R6,A
   \   000046   EF           MOV     A,R7
   \   000047   35..         ADDC    A,?V0 + 11
   \   000049   FF           MOV     R7,A
   \                     ??mpu_load_firmware_3:
   \   00004A   C3           CLR     C
   \   00004B   EE           MOV     A,R6
   \   00004C   95..         SUBB    A,?V0 + 0
   \   00004E   EF           MOV     A,R7
   \   00004F   95..         SUBB    A,?V0 + 1
   \   000051   4003         JC      $+5
   \   000053   02....       LJMP    ??mpu_load_firmware_5 & 0xFFFF
   2360                  this_write = min(LOAD_CHUNK, length - ii);
   \   000056   E5..         MOV     A,?V0 + 0
   \   000058   C3           CLR     C
   \   000059   9E           SUBB    A,R6
   \   00005A   F8           MOV     R0,A
   \   00005B   E5..         MOV     A,?V0 + 1
   \   00005D   9F           SUBB    A,R7
   \   00005E   F9           MOV     R1,A
   \   00005F   C3           CLR     C
   \   000060   E8           MOV     A,R0
   \   000061   9411         SUBB    A,#0x11
   \   000063   E9           MOV     A,R1
   \   000064   9400         SUBB    A,#0x0
   \   000066   4008         JC      ??mpu_load_firmware_6
   \   000068   75..10       MOV     ?V0 + 10,#0x10
   \   00006B   75..00       MOV     ?V0 + 11,#0x0
   \   00006E   800B         SJMP    ??mpu_load_firmware_7
   \                     ??mpu_load_firmware_6:
   \   000070   E5..         MOV     A,?V0 + 0
   \   000072   C3           CLR     C
   \   000073   9E           SUBB    A,R6
   \   000074   F5..         MOV     ?V0 + 10,A
   \   000076   E5..         MOV     A,?V0 + 1
   \   000078   9F           SUBB    A,R7
   \   000079   F5..         MOV     ?V0 + 11,A
   2361                  if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
   \                     ??mpu_load_firmware_7:
   \   00007B                ; Setup parameters for call to function mpu_write_mem
   \   00007B   E5..         MOV     A,?V0 + 4
   \   00007D   2E           ADD     A,R6
   \   00007E   F5..         MOV     ?V0 + 8,A
   \   000080   E5..         MOV     A,?V0 + 5
   \   000082   3F           ADDC    A,R7
   \   000083   F5..         MOV     ?V0 + 9,A
   \   000085   78..         MOV     R0,#?V0 + 8
   \   000087   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008A   AC..         MOV     R4,?V0 + 10
   \   00008C   AD..         MOV     R5,?V0 + 11
   \   00008E   EE           MOV     A,R6
   \   00008F   FA           MOV     R2,A
   \   000090   EF           MOV     A,R7
   \   000091   FB           MOV     R3,A
   \   000092   12....       LCALL   ??mpu_write_mem?relay
   \   000095   7402         MOV     A,#0x2
   \   000097   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009A   8B..         MOV     ?V0 + 9,R3
   \   00009C   EA           MOV     A,R2
   \   00009D   45..         ORL     A,?V0 + 9
   \   00009F   708F         JNZ     ??mpu_load_firmware_1
   2362                      return -1;
   2363                  if (mpu_read_mem(ii, this_write, cur))
   \   0000A1                ; Setup parameters for call to function mpu_read_mem
   \   0000A1   7402         MOV     A,#0x2
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   8582..       MOV     ?V0 + 8,DPL
   \   0000A9   8583..       MOV     ?V0 + 9,DPH
   \   0000AC   78..         MOV     R0,#?V0 + 8
   \   0000AE   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B1   AC..         MOV     R4,?V0 + 10
   \   0000B3   AD..         MOV     R5,?V0 + 11
   \   0000B5   EE           MOV     A,R6
   \   0000B6   FA           MOV     R2,A
   \   0000B7   EF           MOV     A,R7
   \   0000B8   FB           MOV     R3,A
   \   0000B9   12....       LCALL   ??mpu_read_mem?relay
   \   0000BC   7402         MOV     A,#0x2
   \   0000BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C1   8B..         MOV     ?V0 + 9,R3
   \   0000C3   EA           MOV     A,R2
   \   0000C4   45..         ORL     A,?V0 + 9
   \   0000C6   6003         JZ      $+5
   \   0000C8   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2364                      return -1;
   2365                  if (memcmp(firmware+ii, cur, this_write))
   \   0000CB                ; Setup parameters for call to function memcmp
   \   0000CB   78..         MOV     R0,#?V0 + 10
   \   0000CD   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D0   7404         MOV     A,#0x4
   \   0000D2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D5   AC82         MOV     R4,DPL
   \   0000D7   AD83         MOV     R5,DPH
   \   0000D9   E5..         MOV     A,?V0 + 4
   \   0000DB   2E           ADD     A,R6
   \   0000DC   FA           MOV     R2,A
   \   0000DD   E5..         MOV     A,?V0 + 5
   \   0000DF   3F           ADDC    A,R7
   \   0000E0   FB           MOV     R3,A
   \   0000E1   12....       LCALL   ??memcmp?relay
   \   0000E4   7402         MOV     A,#0x2
   \   0000E6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E9   8B..         MOV     ?V0 + 9,R3
   \   0000EB   EA           MOV     A,R2
   \   0000EC   45..         ORL     A,?V0 + 9
   \   0000EE   7003         JNZ     $+5
   \   0000F0   02....       LJMP    ??mpu_load_firmware_4 & 0xFFFF
   2366                      return -2;
   \   0000F3   7AFE         MOV     R2,#-0x2
   \   0000F5   02....       LJMP    ??mpu_load_firmware_2 & 0xFFFF
   2367              }
   2368          
   2369              /* Set program start address. */
   2370              tmp[0] = start_addr >> 8;
   \                     ??mpu_load_firmware_5:
   \   0000F8   85..82       MOV     DPL,?XSP + 0
   \   0000FB   85..83       MOV     DPH,?XSP + 1
   \   0000FE   E5..         MOV     A,?V0 + 3
   \   000100   F0           MOVX    @DPTR,A
   2371              tmp[1] = start_addr & 0xFF;
   \   000101   7401         MOV     A,#0x1
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   E5..         MOV     A,?V0 + 2
   \   000108   12....       LCALL   ?Subroutine49 & 0xFFFF
   2372              if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
   \                     ??CrossCallReturnLabel_62:
   \   00010B   E0           MOVX    A,@DPTR
   \   00010C   241A         ADD     A,#0x1a
   \   00010E   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_159:
   \   000111   6003         JZ      $+5
   \   000113   02....       LJMP    ??mpu_load_firmware_1 & 0xFFFF
   2373                  return -1;
   2374          
   2375              st.chip_cfg.dmp_loaded = 1;
   \   000116   90....       MOV     DPTR,#st + 30
   \   000119   7401         MOV     A,#0x1
   \   00011B   F0           MOVX    @DPTR,A
   2376              st.chip_cfg.dmp_sample_rate = sample_rate;
   \   00011C   A3           INC     DPTR
   \   00011D   E5..         MOV     A,?V0 + 6
   \   00011F   F0           MOVX    @DPTR,A
   \   000120   A3           INC     DPTR
   \   000121   E5..         MOV     A,?V0 + 7
   \   000123   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   2377              return 0;
   \                     ??CrossCallReturnLabel_299:
   \   000126   7412         MOV     A,#0x12
   \   000128   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012B   7F0C         MOV     R7,#0xc
   \   00012D   02....       LJMP    ?BANKED_LEAVE_XDATA
   2378          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   12....       LCALL   ?Subroutine90 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000003   90....       MOV     DPTR,#st
   \   000006   22           RET
   2379          
   2380          /**
   2381           *  @brief      Enable/disable DMP support.
   2382           *  @param[in]  enable  1 to turn on the DMP.
   2383           *  @return     0 if successful.
   2384           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2385          int mpu_set_dmp_state(unsigned char enable)
   \                     mpu_set_dmp_state:
   2386          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2387              unsigned char tmp;
   2388              if (st.chip_cfg.dmp_on == enable)
   \   00000C   90....       MOV     DPTR,#st + 29
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   6E           XRL     A,R6
   \   000011   7007         JNZ     ??mpu_set_dmp_state_0
   2389                  return 0;
   \                     ??mpu_set_dmp_state_1:
   \   000013   7A00         MOV     R2,#0x0
   \   000015   7B00         MOV     R3,#0x0
   \                     ??mpu_set_dmp_state_2:
   \   000017   02....       LJMP    ?Subroutine0 & 0xFFFF
   2390          
   2391              if (enable) {
   \                     ??mpu_set_dmp_state_0:
   \   00001A   EE           MOV     A,R6
   \   00001B   6030         JZ      ??mpu_set_dmp_state_3
   2392                  if (!st.chip_cfg.dmp_loaded)
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   7006         JNZ     ??mpu_set_dmp_state_4
   2393                      return -1;
   \   000021   7AFF         MOV     R2,#-0x1
   \   000023   7BFF         MOV     R3,#-0x1
   \   000025   80F0         SJMP    ??mpu_set_dmp_state_2
   2394                  /* Disable data ready interrupt. */
   2395                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_4:
   \   000027                ; Setup parameters for call to function set_int_enable
   \   000027   7900         MOV     R1,#0x0
   \   000029   12....       LCALL   ??set_int_enable?relay
   2396                  /* Disable bypass mode. */
   2397                  mpu_set_bypass(0);
   \   00002C                ; Setup parameters for call to function mpu_set_bypass
   \   00002C   7900         MOV     R1,#0x0
   \   00002E   12....       LCALL   ??mpu_set_bypass?relay
   2398                  /* Keep constant sample rate, FIFO rate controlled by DMP. */
   2399                  mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
   \   000031                ; Setup parameters for call to function mpu_set_sample_rate
   \   000031   90....       MOV     DPTR,#st + 31
   \   000034   12....       LCALL   ?Subroutine35 & 0xFFFF
   2400                  /* Remove FIFO elements. */
   2401                  tmp = 0;
   \                     ??CrossCallReturnLabel_29:
   \   000037   85..82       MOV     DPL,?XSP + 0
   \   00003A   85..83       MOV     DPH,?XSP + 1
   \   00003D   E4           CLR     A
   \   00003E   12....       LCALL   ?Subroutine26 & 0xFFFF
   2402                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2403                  st.chip_cfg.dmp_on = 1;
   \                     ??CrossCallReturnLabel_18:
   \   000041   7401         MOV     A,#0x1
   \   000043   F0           MOVX    @DPTR,A
   2404                  /* Enable DMP interrupt. */
   2405                  set_int_enable(1);
   \   000044                ; Setup parameters for call to function set_int_enable
   \   000044   F9           MOV     R1,A
   \   000045   12....       LCALL   ??set_int_enable?relay
   2406                  mpu_reset_fifo();
   \   000048                ; Setup parameters for call to function mpu_reset_fifo
   \                     ??mpu_set_dmp_state_5:
   \   000048   12....       LCALL   ??mpu_reset_fifo?relay
   \   00004B   80C6         SJMP    ??mpu_set_dmp_state_1
   2407              } else {
   2408                  /* Disable DMP interrupt. */
   2409                  set_int_enable(0);
   \                     ??mpu_set_dmp_state_3:
   \   00004D                ; Setup parameters for call to function set_int_enable
   \   00004D   7900         MOV     R1,#0x0
   \   00004F   12....       LCALL   ??set_int_enable?relay
   2410                  /* Restore FIFO settings. */
   2411                  tmp = st.chip_cfg.fifo_enable;
   \   000052   90....       MOV     DPTR,#st + 11
   \   000055   12....       LCALL   ??Subroutine121_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_253:
   \   000058   12....       LCALL   ?Subroutine26 & 0xFFFF
   2412                  i2c_write(st.hw->addr, 0x23, 1, &tmp);
   2413                  st.chip_cfg.dmp_on = 0;
   \                     ??CrossCallReturnLabel_19:
   \   00005B   E4           CLR     A
   \   00005C   F0           MOVX    @DPTR,A
   2414                  mpu_reset_fifo();
   \   00005D                ; Setup parameters for call to function mpu_reset_fifo
   \   00005D   80E9         SJMP    ??mpu_set_dmp_state_5
   2415              }
   2416              return 0;
   2417          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine93 & 0xFFFF
   \                     ??CrossCallReturnLabel_309:
   \   000003   7A23         MOV     R2,#0x23
   \   000005   12....       LCALL   ?Subroutine82 & 0xFFFF
   \                     ??CrossCallReturnLabel_261:
   \   000008   12....       LCALL   ??MPU_Write_Len?relay
   \   00000B   90....       MOV     DPTR,#st + 29
   \   00000E   22           RET
   2418          
   2419          /**
   2420           *  @brief      Get DMP state.
   2421           *  @param[out] enabled 1 if enabled.
   2422           *  @return     0 if successful.
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          int mpu_get_dmp_state(unsigned char *enabled)
   \                     mpu_get_dmp_state:
   2425          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2426              enabled[0] = st.chip_cfg.dmp_on;
   \   000004   90....       MOV     DPTR,#st + 29
   \   000007   02....       LJMP    ?Subroutine3 & 0xFFFF
   2427              return 0;
   2428          }
   2429          
   2430          
   2431          /* This initialization is similar to the one in ak8975.c. */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2432          int setup_compass(void)
   \                     setup_compass:
   2433          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2434          #ifdef AK89xx_SECONDARY
   2435              unsigned char data[4], akm_addr;
   2436          
   2437              mpu_set_bypass(1);
   2438          
   2439              /* Find compass. Possible addresses range from 0x0C to 0x0F. */
   2440              for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
   2441                  int result;
   2442                  result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
   2443                  if (!result && (data[0] == AKM_WHOAMI))
   2444                      break;
   2445              }
   2446          
   2447              if (akm_addr > 0x0F) {
   2448                  /* TODO: Handle this case in all compass-related functions. */
   2449                  log_e("Compass not found.\n");
   2450                  return -1;
   2451              }
   2452          
   2453              st.chip_cfg.compass_addr = akm_addr;
   2454          
   2455              data[0] = AKM_POWER_DOWN;
   2456              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2457                  return -1;
   2458              delay_ms(1);
   2459          
   2460              data[0] = AKM_FUSE_ROM_ACCESS;
   2461              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2462                  return -1;
   2463              delay_ms(1);
   2464          
   2465              /* Get sensitivity adjustment data from fuse ROM. */
   2466              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
   2467                  return -1;
   2468              st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
   2469              st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
   2470              st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
   2471          
   2472              data[0] = AKM_POWER_DOWN;
   2473              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
   2474                  return -1;
   2475              delay_ms(1);
   2476          
   2477              mpu_set_bypass(0);
   2478          
   2479              /* Set up master mode, master clock, and ES bit. */
   2480              data[0] = 0x40;
   2481              if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
   2482                  return -1;
   2483          
   2484              /* Slave 0 reads from AKM data registers. */
   2485              data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
   2486              if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
   2487                  return -1;
   2488          
   2489              /* Compass reads start at this register. */
   2490              data[0] = AKM_REG_ST1;
   2491              if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
   2492                  return -1;
   2493          
   2494              /* Enable slave 0, 8-byte reads. */
   2495              data[0] = BIT_SLAVE_EN | 8;
   2496              if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
   2497                  return -1;
   2498          
   2499              /* Slave 1 changes AKM measurement mode. */
   2500              data[0] = st.chip_cfg.compass_addr;
   2501              if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
   2502                  return -1;
   2503          
   2504              /* AKM measurement mode register. */
   2505              data[0] = AKM_REG_CNTL;
   2506              if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
   2507                  return -1;
   2508          
   2509              /* Enable slave 1, 1-byte writes. */
   2510              data[0] = BIT_SLAVE_EN | 1;
   2511              if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
   2512                  return -1;
   2513          
   2514              /* Set slave 1 data. */
   2515              data[0] = AKM_SINGLE_MEASUREMENT;
   2516              if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
   2517                  return -1;
   2518          
   2519              /* Trigger slave 0 and slave 1 actions at each sample. */
   2520              data[0] = 0x03;
   2521              if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
   2522                  return -1;
   2523          
   2524          #ifdef MPU9150
   2525              /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
   2526              data[0] = BIT_I2C_MST_VDDIO;
   2527              if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
   2528                  return -1;
   2529          #endif
   2530          
   2531              return 0;
   2532          #else
   2533              return -1;
   \   000000   80..         SJMP    ?Subroutine4
   2534          #endif
   2535          }
   2536          
   2537          /**
   2538           *  @brief      Read raw compass data.
   2539           *  @param[out] data        Raw data in hardware units.
   2540           *  @param[out] timestamp   Timestamp in milliseconds. Null if not needed.
   2541           *  @return     0 if successful.
   2542           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2543          int mpu_get_compass_reg(short *data, unsigned long *timestamp)
   \                     mpu_get_compass_reg:
   2544          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2545          #ifdef AK89xx_SECONDARY
   2546              unsigned char tmp[9];
   2547          
   2548              if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
   2549                  return -1;
   2550          
   2551          #ifdef AK89xx_BYPASS
   2552              if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
   2553                  return -1;
   2554              tmp[8] = AKM_SINGLE_MEASUREMENT;
   2555              if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
   2556                  return -1;
   2557          #else
   2558              if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
   2559                  return -1;
   2560          #endif
   2561          
   2562          #if defined AK8975_SECONDARY
   2563              /* AK8975 doesn't have the overrun error bit. */
   2564              if (!(tmp[0] & AKM_DATA_READY))
   2565                  return -2;
   2566              if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
   2567                  return -3;
   2568          #elif defined AK8963_SECONDARY
   2569              /* AK8963 doesn't have the data read error bit. */
   2570              if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
   2571                  return -2;
   2572              if (tmp[7] & AKM_OVERFLOW)
   2573                  return -3;
   2574          #endif
   2575              data[0] = (tmp[2] << 8) | tmp[1];
   2576              data[1] = (tmp[4] << 8) | tmp[3];
   2577              data[2] = (tmp[6] << 8) | tmp[5];
   2578          
   2579              data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
   2580              data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
   2581              data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
   2582          
   2583              if (timestamp)
   2584                  get_ms(timestamp);
   2585              return 0;
   2586          #else
   2587              return -1;
   \   000000                REQUIRE ?Subroutine4
   \   000000                ; // Fall through to label ?Subroutine4
   2588          #endif
   2589          }
   2590          
   2591          /**
   2592           *  @brief      Get the compass full-scale range.
   2593           *  @param[out] fsr Current full-scale range.
   2594           *  @return     0 if successful.
   2595           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2596          int mpu_get_compass_fsr(unsigned short *fsr)
   \                     mpu_get_compass_fsr:
   2597          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2598          #ifdef AK89xx_SECONDARY
   2599              fsr[0] = st.hw->compass_fsr;
   2600              return 0;
   2601          #else
   2602              return -1;
   \   000000   80..         SJMP    ?Subroutine4
   2603          #endif
   2604          }
   2605          
   2606          /**
   2607           *  @brief      Enters LP accel motion interrupt mode.
   2608           *  The behavior of this feature is very different between the MPU6050 and the
   2609           *  MPU6500. Each chip's version of this feature is explained below.
   2610           *
   2611           *  \n MPU6050:
   2612           *  \n When this mode is first enabled, the hardware captures a single accel
   2613           *  sample, and subsequent samples are compared with this one to determine if
   2614           *  the device is in motion. Therefore, whenever this "locked" sample needs to
   2615           *  be changed, this function must be called again.
   2616           *
   2617           *  \n The hardware motion threshold can be between 32mg and 8160mg in 32mg
   2618           *  increments.
   2619           *
   2620           *  \n Low-power accel mode supports the following frequencies:
   2621           *  \n 1.25Hz, 5Hz, 20Hz, 40Hz
   2622           *
   2623           *  \n MPU6500:
   2624           *  \n Unlike the MPU6050 version, the hardware does not "lock in" a reference
   2625           *  sample. The hardware monitors the accel data and detects any large change
   2626           *  over a short period of time.
   2627           *
   2628           *  \n The hardware motion threshold can be between 4mg and 1020mg in 4mg
   2629           *  increments.
   2630           *
   2631           *  \n MPU6500 Low-power accel mode supports the following frequencies:
   2632           *  \n 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
   2633           *
   2634           *  \n\n NOTES:
   2635           *  \n The driver will round down @e thresh to the nearest supported value if
   2636           *  an unsupported threshold is selected.
   2637           *  \n To select a fractional wake-up frequency, round down the value passed to
   2638           *  @e lpa_freq.
   2639           *  \n The MPU6500 does not support a delay parameter. If this function is used
   2640           *  for the MPU6500, the value passed to @e time will be ignored.
   2641           *  \n To disable this mode, set @e lpa_freq to zero. The driver will restore
   2642           *  the previous configuration.
   2643           *
   2644           *  @param[in]  thresh      Motion threshold in mg.
   2645           *  @param[in]  time        Duration in milliseconds that the accel data must
   2646           *                          exceed @e thresh before motion is reported.
   2647           *  @param[in]  lpa_freq    Minimum sampling rate, or zero to disable.
   2648           *  @return     0 if successful.
   2649           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2650          int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
   \                     mpu_lp_motion_interrupt:
   2651              unsigned char lpa_freq)
   2652          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   EC           MOV     A,R4
   \   00000D   FE           MOV     R6,A
   2653              unsigned char data[3];
   2654          
   2655              if (lpa_freq) {
   \   00000E   7003         JNZ     $+5
   \   000010   02....       LJMP    ??mpu_lp_motion_interrupt_0 & 0xFFFF
   2656                  unsigned char thresh_hw;
   2657          
   2658          #if defined MPU6050
   2659                  /* TODO: Make these const/#defines. */
   2660                  /* 1LSb = 32mg. */
   2661                  if (thresh > 8160)
   \   000013   C3           CLR     C
   \   000014   EA           MOV     A,R2
   \   000015   94E1         SUBB    A,#-0x1f
   \   000017   EB           MOV     A,R3
   \   000018   941F         SUBB    A,#0x1f
   \   00001A   4005         JC      ??mpu_lp_motion_interrupt_1
   2662                      thresh_hw = 255;
   \   00001C   75..FF       MOV     ?V0 + 0,#-0x1
   \   00001F   8019         SJMP    ??mpu_lp_motion_interrupt_2
   2663                  else if (thresh < 32)
   \                     ??mpu_lp_motion_interrupt_1:
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   9420         SUBB    A,#0x20
   \   000025   EB           MOV     A,R3
   \   000026   9400         SUBB    A,#0x0
   \   000028   5005         JNC     ??mpu_lp_motion_interrupt_3
   2664                      thresh_hw = 1;
   \   00002A   75..01       MOV     ?V0 + 0,#0x1
   \   00002D   800B         SJMP    ??mpu_lp_motion_interrupt_2
   2665                  else
   2666                      thresh_hw = thresh >> 5;
   \                     ??mpu_lp_motion_interrupt_3:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   8B..         MOV     ?V0 + 1,R3
   \   000033   7405         MOV     A,#0x5
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?US_SHR
   2667          #elif defined MPU6500
   2668                  /* 1LSb = 4mg. */
   2669                  if (thresh > 1020)
   2670                      thresh_hw = 255;
   2671                  else if (thresh < 4)
   2672                      thresh_hw = 1;
   2673                  else
   2674                      thresh_hw = thresh >> 2;
   2675          #endif
   2676          
   2677                  if (!time)
   \                     ??mpu_lp_motion_interrupt_2:
   \   00003A   EF           MOV     A,R7
   \   00003B   7002         JNZ     ??mpu_lp_motion_interrupt_4
   2678                      /* Minimum duration must be 1ms. */
   2679                      time = 1;
   \   00003D   7F01         MOV     R7,#0x1
   2680          
   2681          #if defined MPU6050
   2682                  if (lpa_freq > 40)
   \                     ??mpu_lp_motion_interrupt_4:
   \   00003F   EE           MOV     A,R6
   \   000040   C3           CLR     C
   \   000041   9429         SUBB    A,#0x29
   \   000043   4007         JC      ??mpu_lp_motion_interrupt_5
   2683          #elif defined MPU6500
   2684                  if (lpa_freq > 640)
   2685          #endif
   2686                      /* At this point, the chip has not been re-configured, so the
   2687                       * function can safely exit.
   2688                       */
   2689                      return -1;
   \                     ??mpu_lp_motion_interrupt_6:
   \   000045   7AFF         MOV     R2,#-0x1
   \   000047   7BFF         MOV     R3,#-0x1
   \   000049   02....       LJMP    ??mpu_lp_motion_interrupt_7 & 0xFFFF
   2690          
   2691                  if (!st.chip_cfg.int_motion_only) {
   \                     ??mpu_lp_motion_interrupt_5:
   \   00004C   90....       MOV     DPTR,#st + 16
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   7042         JNZ     ??mpu_lp_motion_interrupt_8
   2692                      /* Store current settings for later. */
   2693                      if (st.chip_cfg.dmp_on) {
   \   000052   90....       MOV     DPTR,#st + 29
   \   000055   E0           MOVX    A,@DPTR
   \   000056   600C         JZ      ??mpu_lp_motion_interrupt_9
   2694                          mpu_set_dmp_state(0);
   \   000058                ; Setup parameters for call to function mpu_set_dmp_state
   \   000058   7900         MOV     R1,#0x0
   \   00005A   12....       LCALL   ??mpu_set_dmp_state?relay
   2695                          st.chip_cfg.cache.dmp_on = 1;
   \   00005D   90....       MOV     DPTR,#st + 26
   \   000060   7401         MOV     A,#0x1
   \   000062   8004         SJMP    ??mpu_lp_motion_interrupt_10
   2696                      } else
   2697                          st.chip_cfg.cache.dmp_on = 0;
   \                     ??mpu_lp_motion_interrupt_9:
   \   000064   90....       MOV     DPTR,#st + 26
   \   000067   E4           CLR     A
   \                     ??mpu_lp_motion_interrupt_10:
   \   000068   F0           MOVX    @DPTR,A
   2698                      mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
   \   000069                ; Setup parameters for call to function mpu_get_gyro_fsr
   \   000069   7A..         MOV     R2,#(st + 17) & 0xff
   \   00006B   7B..         MOV     R3,#((st + 17) >> 8) & 0xff
   \   00006D   12....       LCALL   ??mpu_get_gyro_fsr?relay
   2699                      mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
   \   000070                ; Setup parameters for call to function mpu_get_accel_fsr
   \   000070   7A..         MOV     R2,#(st + 19) & 0xff
   \   000072   7B..         MOV     R3,#((st + 19) >> 8) & 0xff
   \   000074   12....       LCALL   ??mpu_get_accel_fsr?relay
   2700                      mpu_get_lpf(&st.chip_cfg.cache.lpf);
   \   000077                ; Setup parameters for call to function mpu_get_lpf
   \   000077   7A..         MOV     R2,#(st + 20) & 0xff
   \   000079   7B..         MOV     R3,#((st + 20) >> 8) & 0xff
   \   00007B   12....       LCALL   ??mpu_get_lpf?relay
   2701                      mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
   \   00007E                ; Setup parameters for call to function mpu_get_sample_rate
   \   00007E   7A..         MOV     R2,#(st + 22) & 0xff
   \   000080   7B..         MOV     R3,#((st + 22) >> 8) & 0xff
   \   000082   12....       LCALL   ??mpu_get_sample_rate?relay
   2702                      st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
   \   000085   90....       MOV     DPTR,#st + 6
   \   000088   E0           MOVX    A,@DPTR
   \   000089   90....       MOV     DPTR,#st + 24
   \   00008C   F0           MOVX    @DPTR,A
   2703                      mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
   \   00008D                ; Setup parameters for call to function mpu_get_fifo_config
   \   00008D   7A..         MOV     R2,#(st + 25) & 0xff
   \   00008F   7B..         MOV     R3,#((st + 25) >> 8) & 0xff
   \   000091   12....       LCALL   ??mpu_get_fifo_config?relay
   2704                  }
   2705          
   2706          #ifdef MPU6050
   2707                  /* Disable hardware interrupts for now. */
   2708                  set_int_enable(0);
   \                     ??mpu_lp_motion_interrupt_8:
   \   000094                ; Setup parameters for call to function set_int_enable
   \   000094   7900         MOV     R1,#0x0
   \   000096   12....       LCALL   ??set_int_enable?relay
   2709          
   2710                  /* Enter full-power accel-only mode. */
   2711                  mpu_lp_accel_mode(0);
   \   000099                ; Setup parameters for call to function mpu_lp_accel_mode
   \   000099   7900         MOV     R1,#0x0
   \   00009B   12....       LCALL   ??mpu_lp_accel_mode?relay
   2712          
   2713                  /* Override current LPF (and HPF) settings to obtain a valid accel
   2714                   * reading.
   2715                   */
   2716                  data[0] = INV_FILTER_256HZ_NOLPF2;
   \   00009E   85..82       MOV     DPL,?XSP + 0
   \   0000A1   85..83       MOV     DPH,?XSP + 1
   \   0000A4   E4           CLR     A
   \   0000A5   F0           MOVX    @DPTR,A
   2717                  if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
   \   0000A6                ; Setup parameters for call to function MPU_Write_Len
   \   0000A6   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   0000A9   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_185:
   \   0000AC   7097         JNZ     ??mpu_lp_motion_interrupt_6
   2718                      return -1;
   2719          
   2720                  /* NOTE: Digital high pass filter should be configured here. Since this
   2721                   * driver doesn't modify those bits anywhere, they should already be
   2722                   * cleared by default.
   2723                   */
   2724          
   2725                  /* Configure the device to send motion interrupts. */
   2726                  /* Enable motion interrupt. */
   2727                  data[0] = BIT_MOT_INT_EN;
   \   0000AE   85..82       MOV     DPL,?XSP + 0
   \   0000B1   85..83       MOV     DPH,?XSP + 1
   \   0000B4   7440         MOV     A,#0x40
   \   0000B6   12....       LCALL   ??Subroutine138_0 & 0xFFFF
   2728                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   \                     ??CrossCallReturnLabel_307:
   \   0000B9   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_160:
   \   0000BC   6003         JZ      $+5
   \   0000BE   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2729                      goto lp_int_restore;
   2730          
   2731                  /* Set motion interrupt parameters. */
   2732                  data[0] = thresh_hw;
   \   0000C1   85..82       MOV     DPL,?XSP + 0
   \   0000C4   85..83       MOV     DPH,?XSP + 1
   \   0000C7   E5..         MOV     A,?V0 + 0
   \   0000C9   F0           MOVX    @DPTR,A
   2733                  data[1] = time;
   \   0000CA   7401         MOV     A,#0x1
   \   0000CC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CF   EF           MOV     A,R7
   \   0000D0   12....       LCALL   ?Subroutine49 & 0xFFFF
   2734                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
   \                     ??CrossCallReturnLabel_63:
   \   0000D3   12....       LCALL   ??Subroutine134_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_289:
   \   0000D6   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_186:
   \   0000D9   6003         JZ      $+5
   \   0000DB   02....       LJMP    ??mpu_lp_motion_interrupt_11 & 0xFFFF
   2735                      goto lp_int_restore;
   2736          
   2737                  /* Force hardware to "lock" current accel sample. */
   2738                  delay_ms(5);
   \   0000DE                ; Setup parameters for call to function delay_ms
   \   0000DE   7A05         MOV     R2,#0x5
   \   0000E0   7B00         MOV     R3,#0x0
   \   0000E2   12....       LCALL   ??delay_ms?relay
   2739                  data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
   \   0000E5   90....       MOV     DPTR,#st + 5
   \   0000E8   E0           MOVX    A,@DPTR
   \   0000E9   33           RLC     A
   \   0000EA   33           RLC     A
   \   0000EB   33           RLC     A
   \   0000EC   54F8         ANL     A,#0xf8
   \   0000EE   4407         ORL     A,#0x7
   \   0000F0   85..82       MOV     DPL,?XSP + 0
   \   0000F3   85..83       MOV     DPH,?XSP + 1
   \   0000F6   12....       LCALL   ?Subroutine20 & 0xFFFF
   2740                  if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
   \                     ??CrossCallReturnLabel_282:
   \   0000F9   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_187:
   \   0000FC   7075         JNZ     ??mpu_lp_motion_interrupt_11
   2741                      goto lp_int_restore;
   2742          
   2743                  /* Set up LP accel mode. */
   2744                  data[0] = BIT_LPA_CYCLE;
   \   0000FE   85..82       MOV     DPL,?XSP + 0
   \   000101   85..83       MOV     DPH,?XSP + 1
   \   000104   7420         MOV     A,#0x20
   \   000106   F0           MOVX    @DPTR,A
   2745                  if (lpa_freq == 1)
   \   000107   7401         MOV     A,#0x1
   \   000109   6E           XRL     A,R6
   \   00010A   7008         JNZ     ??mpu_lp_motion_interrupt_12
   2746                      data[1] = INV_LPA_1_25HZ;
   \   00010C   7401         MOV     A,#0x1
   \   00010E   12....       LCALL   ?XSTACK_DISP0_8
   \   000111   E4           CLR     A
   \   000112   8023         SJMP    ??mpu_lp_motion_interrupt_13
   2747                  else if (lpa_freq <= 5)
   \                     ??mpu_lp_motion_interrupt_12:
   \   000114   EE           MOV     A,R6
   \   000115   C3           CLR     C
   \   000116   9406         SUBB    A,#0x6
   \   000118   5009         JNC     ??mpu_lp_motion_interrupt_14
   2748                      data[1] = INV_LPA_5HZ;
   \   00011A   7401         MOV     A,#0x1
   \   00011C   12....       LCALL   ?XSTACK_DISP0_8
   \   00011F   7401         MOV     A,#0x1
   \   000121   8014         SJMP    ??mpu_lp_motion_interrupt_13
   2749                  else if (lpa_freq <= 20)
   \                     ??mpu_lp_motion_interrupt_14:
   \   000123   EE           MOV     A,R6
   \   000124   C3           CLR     C
   \   000125   9415         SUBB    A,#0x15
   \   000127   7401         MOV     A,#0x1
   \   000129   5007         JNC     ??mpu_lp_motion_interrupt_15
   2750                      data[1] = INV_LPA_20HZ;
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   7402         MOV     A,#0x2
   \   000130   8005         SJMP    ??mpu_lp_motion_interrupt_13
   2751                  else
   2752                      data[1] = INV_LPA_40HZ;
   \                     ??mpu_lp_motion_interrupt_15:
   \   000132   12....       LCALL   ?XSTACK_DISP0_8
   \   000135   7403         MOV     A,#0x3
   \                     ??mpu_lp_motion_interrupt_13:
   \   000137   F0           MOVX    @DPTR,A
   2753                  data[1] = (data[1] << 6) | BIT_STBY_XYZG;
   \   000138   7401         MOV     A,#0x1
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   12....       LCALL   ?Subroutine11 & 0xFFFF
   2754                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
   \                     ??CrossCallReturnLabel_138:
   \   000140   7031         JNZ     ??mpu_lp_motion_interrupt_11
   2755                      goto lp_int_restore;
   2756          
   2757                  st.chip_cfg.int_motion_only = 1;
   \   000142   90....       MOV     DPTR,#st + 16
   \   000145   7401         MOV     A,#0x1
   \   000147   12....       LCALL   ??Subroutine137_0 & 0xFFFF
   2758                  return 0;
   2759          #elif defined MPU6500
   2760                  /* Disable hardware interrupts. */
   2761                  set_int_enable(0);
   2762          
   2763                  /* Enter full-power accel-only mode, no FIFO/DMP. */
   2764                  data[0] = 0;
   2765                  data[1] = 0;
   2766                  data[2] = BIT_STBY_XYZG;
   2767                  if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
   2768                      goto lp_int_restore;
   2769          
   2770                  /* Set motion threshold. */
   2771                  data[0] = thresh_hw;
   2772                  if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
   2773                      goto lp_int_restore;
   2774          
   2775                  /* Set wake frequency. */
   2776                  if (lpa_freq == 1)
   2777                      data[0] = INV_LPA_1_25HZ;
   2778                  else if (lpa_freq == 2)
   2779                      data[0] = INV_LPA_2_5HZ;
   2780                  else if (lpa_freq <= 5)
   2781                      data[0] = INV_LPA_5HZ;
   2782                  else if (lpa_freq <= 10)
   2783                      data[0] = INV_LPA_10HZ;
   2784                  else if (lpa_freq <= 20)
   2785                      data[0] = INV_LPA_20HZ;
   2786                  else if (lpa_freq <= 40)
   2787                      data[0] = INV_LPA_40HZ;
   2788                  else if (lpa_freq <= 80)
   2789                      data[0] = INV_LPA_80HZ;
   2790                  else if (lpa_freq <= 160)
   2791                      data[0] = INV_LPA_160HZ;
   2792                  else if (lpa_freq <= 320)
   2793                      data[0] = INV_LPA_320HZ;
   2794                  else
   2795                      data[0] = INV_LPA_640HZ;
   2796                  if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
   2797                      goto lp_int_restore;
   2798          
   2799                  /* Enable motion interrupt (MPU6500 version). */
   2800                  data[0] = BITS_WOM_EN;
   2801                  if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2802                      goto lp_int_restore;
   2803          
   2804                  /* Enable cycle mode. */
   2805                  data[0] = BIT_LPA_CYCLE;
   2806                  if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
   2807                      goto lp_int_restore;
   2808          
   2809                  /* Enable interrupt. */
   2810                  data[0] = BIT_MOT_INT_EN;
   2811                  if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
   2812                      goto lp_int_restore;
   2813          
   2814                  st.chip_cfg.int_motion_only = 1;
   2815                  return 0;
   2816          #endif
   2817              } else {
   \                     ??CrossCallReturnLabel_300:
   \   00014A   8066         SJMP    ??mpu_lp_motion_interrupt_7
   2818                  /* Don't "restore" the previous state if no state has been saved. */
   2819                  int ii;
   2820                  char *cache_ptr = (char*)&st.chip_cfg.cache;
   2821                  for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
   \                     ??mpu_lp_motion_interrupt_0:
   \   00014C   7800         MOV     R0,#0x0
   \   00014E   7900         MOV     R1,#0x0
   2822                      if (cache_ptr[ii] != 0)
   \                     ??mpu_lp_motion_interrupt_16:
   \   000150   74..         MOV     A,#(st + 17) & 0xff
   \   000152   28           ADD     A,R0
   \   000153   F582         MOV     DPL,A
   \   000155   74..         MOV     A,#((st + 17) >> 8) & 0xff
   \   000157   39           ADDC    A,R1
   \   000158   F583         MOV     DPH,A
   \   00015A   E0           MOVX    A,@DPTR
   \   00015B   7016         JNZ     ??mpu_lp_motion_interrupt_11
   2823                          goto lp_int_restore;
   2824                  }
   \   00015D   E8           MOV     A,R0
   \   00015E   2401         ADD     A,#0x1
   \   000160   08           INC     R0
   \   000161   E9           MOV     A,R1
   \   000162   3400         ADDC    A,#0x0
   \   000164   F9           MOV     R1,A
   \   000165   C3           CLR     C
   \   000166   E8           MOV     A,R0
   \   000167   940A         SUBB    A,#0xa
   \   000169   E9           MOV     A,R1
   \   00016A   9400         SUBB    A,#0x0
   \   00016C   4003         JC      $+5
   \   00016E   02....       LJMP    ??mpu_lp_motion_interrupt_6 & 0xFFFF
   \   000171   80DD         SJMP    ??mpu_lp_motion_interrupt_16
   2825                  /* If we reach this point, motion interrupt mode hasn't been used yet. */
   2826                  return -1;
   2827              }
   2828          lp_int_restore:
   2829              /* Set to invalid values to ensure no I2C writes are skipped. */
   2830              st.chip_cfg.gyro_fsr = 0xFF;
   \                     ??mpu_lp_motion_interrupt_11:
   \   000173   12....       LCALL   ?Subroutine47 & 0xFFFF
   2831              st.chip_cfg.accel_fsr = 0xFF;
   2832              st.chip_cfg.lpf = 0xFF;
   2833              st.chip_cfg.sample_rate = 0xFFFF;
   2834              st.chip_cfg.sensors = 0xFF;
   2835              st.chip_cfg.fifo_enable = 0xFF;
   2836              st.chip_cfg.clk_src = INV_CLK_PLL;
   2837              mpu_set_sensors(st.chip_cfg.cache.sensors_on);
   \                     ??CrossCallReturnLabel_61:
   \   000176                ; Setup parameters for call to function mpu_set_sensors
   \   000176   90....       MOV     DPTR,#st + 24
   \   000179   E0           MOVX    A,@DPTR
   \   00017A   F9           MOV     R1,A
   \   00017B   12....       LCALL   ??mpu_set_sensors?relay
   2838              mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
   \   00017E                ; Setup parameters for call to function mpu_set_gyro_fsr
   \   00017E   90....       MOV     DPTR,#st + 17
   \   000181   12....       LCALL   ?Subroutine42 & 0xFFFF
   2839              mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
   \                     ??CrossCallReturnLabel_53:
   \   000184                ; Setup parameters for call to function mpu_set_accel_fsr
   \   000184   90....       MOV     DPTR,#st + 19
   \   000187   E0           MOVX    A,@DPTR
   \   000188   F9           MOV     R1,A
   \   000189   12....       LCALL   ??mpu_set_accel_fsr?relay
   2840              mpu_set_lpf(st.chip_cfg.cache.lpf);
   \   00018C                ; Setup parameters for call to function mpu_set_lpf
   \   00018C   90....       MOV     DPTR,#st + 20
   \   00018F   12....       LCALL   ?Subroutine43 & 0xFFFF
   2841              mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
   \                     ??CrossCallReturnLabel_55:
   \   000192                ; Setup parameters for call to function mpu_set_sample_rate
   \   000192   90....       MOV     DPTR,#st + 22
   \   000195   12....       LCALL   ?Subroutine35 & 0xFFFF
   2842              mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
   \                     ??CrossCallReturnLabel_30:
   \   000198                ; Setup parameters for call to function mpu_configure_fifo
   \   000198   90....       MOV     DPTR,#st + 25
   \   00019B   E0           MOVX    A,@DPTR
   \   00019C   F9           MOV     R1,A
   \   00019D   12....       LCALL   ??mpu_configure_fifo?relay
   2843          
   2844              if (st.chip_cfg.cache.dmp_on)
   \   0001A0   90....       MOV     DPTR,#st + 26
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   6005         JZ      ??mpu_lp_motion_interrupt_17
   2845                  mpu_set_dmp_state(1);
   \   0001A6                ; Setup parameters for call to function mpu_set_dmp_state
   \   0001A6   7901         MOV     R1,#0x1
   \   0001A8   12....       LCALL   ??mpu_set_dmp_state?relay
   2846          
   2847          #ifdef MPU6500
   2848              /* Disable motion interrupt (MPU6500 version). */
   2849              data[0] = 0;
   2850              if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
   2851                  goto lp_int_restore;
   2852          #endif
   2853          
   2854              st.chip_cfg.int_motion_only = 0;
   \                     ??mpu_lp_motion_interrupt_17:
   \   0001AB   90....       MOV     DPTR,#st + 16
   \   0001AE   E4           CLR     A
   \   0001AF   F0           MOVX    @DPTR,A
   2855              return 0;
   \   0001B0   FA           MOV     R2,A
   \   0001B1   FB           MOV     R3,A
   \                     ??mpu_lp_motion_interrupt_7:
   \   0001B2   7403         MOV     A,#0x3
   \   0001B4   02....       LJMP    ??Subroutine135_0 & 0xFFFF
   2856          }
   2857          
   2858          //q30格式,long转float时的除数.
   2859          #define q30  1073741824.0f
   2860          
   2861          //陀螺仪方向设置

   \                                 In  segment XDATA_I, align 1, keep-with-next
   2862          static signed char gyro_orientation[9] = { 1, 0, 0,
   \                     gyro_orientation:
   \   000000                DS 9
   \   000009                REQUIRE `?<Initializer for gyro_orientation>`
   \   000009                REQUIRE __INIT_XDATA_I
   2863                                                     0, 1, 0,
   2864                                                     0, 0, 1};
   2865          //MPU6050自测试
   2866          //返回值:0,正常
   2867          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2868          u8 run_self_test(void)
   \                     run_self_test:
   2869          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2870          	int result;
   2871          	//char test_packet[4] = {0};
   2872          	long gyro[3], accel[3]; 
   2873          	result = mpu_run_self_test(gyro, accel);
   2874          	if (result == 0x3) 
   \   00000A                ; Setup parameters for call to function mpu_run_self_test
   \   00000A   7406         MOV     A,#0x6
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   7412         MOV     A,#0x12
   \   000015   12....       LCALL   ?XSTACK_DISP0_8
   \   000018   AA82         MOV     R2,DPL
   \   00001A   AB83         MOV     R3,DPH
   \   00001C   12....       LCALL   ??mpu_run_self_test?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   7403         MOV     A,#0x3
   \   000023   65..         XRL     A,?V0 + 0
   \   000025   7001         JNZ     ??run_self_test_0
   \   000027   EB           MOV     A,R3
   \                     ??run_self_test_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??run_self_test_1 & 0xFFFF
   2875          	{
   2876          		/* Test passed. We can trust the gyro data here, so let's push it down
   2877          		* to the DMP.
   2878          		*/
   2879          		float sens;
   2880          		unsigned short accel_sens;
   2881          		mpu_get_gyro_sens(&sens);
   \   00002D                ; Setup parameters for call to function mpu_get_gyro_sens
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   AA82         MOV     R2,DPL
   \   000034   AB83         MOV     R3,DPH
   \   000036   12....       LCALL   ??mpu_get_gyro_sens?relay
   2882          		gyro[0] = (long)(gyro[0] * sens);
   \   000039   7412         MOV     A,#0x12
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   78..         MOV     R0,#?V0 + 0
   \   000040   12....       LCALL   ?L_MOV_X
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?L_TO_FLT
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   78..         MOV     R0,#?V0 + 4
   \   00004F   12....       LCALL   ?L_MOV_X
   \   000052   78..         MOV     R0,#?V0 + 0
   \   000054   79..         MOV     R1,#?V0 + 4
   \   000056   12....       LCALL   ?FLT_MUL
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?FLT_TO_L
   \   00005E   7412         MOV     A,#0x12
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   78..         MOV     R0,#?V0 + 0
   \   000065   12....       LCALL   ?L_MOV_TO_X
   2883          		gyro[1] = (long)(gyro[1] * sens);
   \   000068   7416         MOV     A,#0x16
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   78..         MOV     R0,#?V0 + 0
   \   00006F   12....       LCALL   ?L_MOV_X
   \   000072   78..         MOV     R0,#?V0 + 0
   \   000074   12....       LCALL   ?L_TO_FLT
   \   000077   7402         MOV     A,#0x2
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   78..         MOV     R0,#?V0 + 4
   \   00007E   12....       LCALL   ?L_MOV_X
   \   000081   78..         MOV     R0,#?V0 + 0
   \   000083   79..         MOV     R1,#?V0 + 4
   \   000085   12....       LCALL   ?FLT_MUL
   \   000088   78..         MOV     R0,#?V0 + 0
   \   00008A   12....       LCALL   ?FLT_TO_L
   \   00008D   7416         MOV     A,#0x16
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_TO_X
   2884          		gyro[2] = (long)(gyro[2] * sens);
   \   000097   741A         MOV     A,#0x1a
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_MOV_X
   \   0000A1   78..         MOV     R0,#?V0 + 0
   \   0000A3   12....       LCALL   ?L_TO_FLT
   \   0000A6   7402         MOV     A,#0x2
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   78..         MOV     R0,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_MOV_X
   \   0000B0   78..         MOV     R0,#?V0 + 0
   \   0000B2   79..         MOV     R1,#?V0 + 4
   \   0000B4   12....       LCALL   ?FLT_MUL
   \   0000B7   78..         MOV     R0,#?V0 + 0
   \   0000B9   12....       LCALL   ?FLT_TO_L
   \   0000BC   741A         MOV     A,#0x1a
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   78..         MOV     R0,#?V0 + 0
   \   0000C3   12....       LCALL   ?L_MOV_TO_X
   2885          		dmp_set_gyro_bias(gyro);
   \   0000C6                ; Setup parameters for call to function dmp_set_gyro_bias
   \   0000C6   7412         MOV     A,#0x12
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   AA82         MOV     R2,DPL
   \   0000CD   AB83         MOV     R3,DPH
   \   0000CF   12....       LCALL   ??dmp_set_gyro_bias?relay
   2886          		mpu_get_accel_sens(&accel_sens);
   \   0000D2                ; Setup parameters for call to function mpu_get_accel_sens
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   AA82         MOV     R2,DPL
   \   0000DA   AB83         MOV     R3,DPH
   \   0000DC   12....       LCALL   ??mpu_get_accel_sens?relay
   2887          		accel[0] *= accel_sens;
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   E0           MOVX    A,@DPTR
   \   0000E6   F5..         MOV     ?V0 + 0,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   E0           MOVX    A,@DPTR
   \   0000EA   F5..         MOV     ?V0 + 1,A
   \   0000EC   E4           CLR     A
   \   0000ED   F5..         MOV     ?V0 + 2,A
   \   0000EF   F5..         MOV     ?V0 + 3,A
   \   0000F1   7406         MOV     A,#0x6
   \   0000F3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F6   78..         MOV     R0,#?V0 + 4
   \   0000F8   12....       LCALL   ?L_MOV_X
   \   0000FB   78..         MOV     R0,#?V0 + 4
   \   0000FD   79..         MOV     R1,#?V0 + 0
   \   0000FF   12....       LCALL   ?L_MUL
   \   000102   7406         MOV     A,#0x6
   \   000104   12....       LCALL   ?XSTACK_DISP0_8
   \   000107   78..         MOV     R0,#?V0 + 4
   \   000109   12....       LCALL   ?L_MOV_TO_X
   2888          		accel[1] *= accel_sens;
   \   00010C   740A         MOV     A,#0xa
   \   00010E   12....       LCALL   ?XSTACK_DISP0_8
   \   000111   78..         MOV     R0,#?V0 + 4
   \   000113   12....       LCALL   ?L_MOV_X
   \   000116   78..         MOV     R0,#?V0 + 4
   \   000118   79..         MOV     R1,#?V0 + 0
   \   00011A   12....       LCALL   ?L_MUL
   \   00011D   740A         MOV     A,#0xa
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   78..         MOV     R0,#?V0 + 4
   \   000124   12....       LCALL   ?L_MOV_TO_X
   2889          		accel[2] *= accel_sens;
   \   000127   740E         MOV     A,#0xe
   \   000129   12....       LCALL   ?XSTACK_DISP0_8
   \   00012C   78..         MOV     R0,#?V0 + 4
   \   00012E   12....       LCALL   ?L_MOV_X
   \   000131   78..         MOV     R0,#?V0 + 4
   \   000133   79..         MOV     R1,#?V0 + 0
   \   000135   12....       LCALL   ?L_MUL
   \   000138   740E         MOV     A,#0xe
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   78..         MOV     R0,#?V0 + 4
   \   00013F   12....       LCALL   ?L_MOV_TO_X
   2890          		dmp_set_accel_bias(accel);
   \   000142                ; Setup parameters for call to function dmp_set_accel_bias
   \   000142   7406         MOV     A,#0x6
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   AA82         MOV     R2,DPL
   \   000149   AB83         MOV     R3,DPH
   \   00014B   12....       LCALL   ??dmp_set_accel_bias?relay
   2891          		return 0;
   \   00014E   7900         MOV     R1,#0x0
   \   000150   8002         SJMP    ??run_self_test_2
   2892          	}else return 1;
   \                     ??run_self_test_1:
   \   000152   7901         MOV     R1,#0x1
   \                     ??run_self_test_2:
   \   000154   741E         MOV     A,#0x1e
   \   000156   02....       LJMP    ?Subroutine2 & 0xFFFF
   2893          }
   2894          //陀螺仪方向控制

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2895          unsigned short inv_orientation_matrix_to_scalar(
   \                     inv_orientation_matrix_to_scalar:
   2896              const signed char *mtx)
   2897          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2898              unsigned short scalar; 
   2899              /*
   2900                 XYZ  010_001_000 Identity Matrix
   2901                 XZY  001_010_000
   2902                 YXZ  010_000_001
   2903                 YZX  000_010_001
   2904                 ZXY  001_000_010
   2905                 ZYX  000_001_010
   2906               */
   2907          
   2908              scalar = inv_row_2_scale(mtx);
   \   000009                ; Setup parameters for call to function inv_row_2_scale
   \   000009   12....       LCALL   ??inv_row_2_scale?relay
   \   00000C   8A..         MOV     ?V0 + 0,R2
   \   00000E   8B..         MOV     ?V0 + 1,R3
   2909              scalar |= inv_row_2_scale(mtx + 3) << 3;
   \   000010                ; Setup parameters for call to function inv_row_2_scale
   \   000010   EE           MOV     A,R6
   \   000011   2403         ADD     A,#0x3
   \   000013   12....       LCALL   ?Subroutine59 & 0xFFFF
   2910              scalar |= inv_row_2_scale(mtx + 6) << 6;
   2911          
   2912          
   2913              return scalar;
   \                     ??CrossCallReturnLabel_78:
   \   000016   7403         MOV     A,#0x3
   \   000018   78..         MOV     R0,#?V0 + 2
   \   00001A   12....       LCALL   ?S_SHL
   \   00001D   E5..         MOV     A,?V0 + 0
   \   00001F   45..         ORL     A,?V0 + 2
   \   000021   F5..         MOV     ?V0 + 0,A
   \   000023   E5..         MOV     A,?V0 + 1
   \   000025   45..         ORL     A,?V0 + 3
   \   000027   F5..         MOV     ?V0 + 1,A
   \   000029                ; Setup parameters for call to function inv_row_2_scale
   \   000029   EE           MOV     A,R6
   \   00002A   2406         ADD     A,#0x6
   \   00002C   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   00002F   7406         MOV     A,#0x6
   \   000031   78..         MOV     R0,#?V0 + 2
   \   000033   12....       LCALL   ?S_SHL
   \   000036   E5..         MOV     A,?V0 + 0
   \   000038   45..         ORL     A,?V0 + 2
   \   00003A   FA           MOV     R2,A
   \   00003B   E5..         MOV     A,?V0 + 1
   \   00003D   45..         ORL     A,?V0 + 3
   \   00003F   FB           MOV     R3,A
   \   000040   02....       LJMP    ?Subroutine5 & 0xFFFF
   2914          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   FA           MOV     R2,A
   \   000001   EF           MOV     A,R7
   \   000002   3400         ADDC    A,#0x0
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??inv_row_2_scale?relay
   \   000008   8A..         MOV     ?V0 + 2,R2
   \   00000A   8B..         MOV     ?V0 + 3,R3
   \   00000C   22           RET
   2915          //方向转换

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2916          unsigned short inv_row_2_scale(const signed char *row)
   \                     inv_row_2_scale:
   2917          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2918              unsigned short b;
   2919          
   2920              if (row[0] > 0)
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   12....       LCALL   ??Subroutine140_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_318:
   \   00000B   4004         JC      ??inv_row_2_scale_0
   2921                  b = 0;
   \   00000D   7A00         MOV     R2,#0x0
   \   00000F   803D         SJMP    ??inv_row_2_scale_1
   2922              else if (row[0] < 0)
   \                     ??inv_row_2_scale_0:
   \   000011   12....       LCALL   ??Subroutine139_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_311:
   \   000014   5004         JNC     ??inv_row_2_scale_2
   2923                  b = 4;
   \   000016   7A04         MOV     R2,#0x4
   \   000018   8034         SJMP    ??inv_row_2_scale_1
   2924              else if (row[1] > 0)
   \                     ??inv_row_2_scale_2:
   \   00001A   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_319:
   \   00001D   4004         JC      ??inv_row_2_scale_3
   2925                  b = 1;
   \   00001F   7A01         MOV     R2,#0x1
   \   000021   802B         SJMP    ??inv_row_2_scale_1
   2926              else if (row[1] < 0)
   \                     ??inv_row_2_scale_3:
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_312:
   \   00002A   5004         JNC     ??inv_row_2_scale_4
   2927                  b = 5;
   \   00002C   7A05         MOV     R2,#0x5
   \   00002E   801E         SJMP    ??inv_row_2_scale_1
   2928              else if (row[2] > 0)
   \                     ??inv_row_2_scale_4:
   \   000030   8A82         MOV     DPL,R2
   \   000032   8B83         MOV     DPH,R3
   \   000034   A3           INC     DPTR
   \   000035   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_320:
   \   000038   4004         JC      ??inv_row_2_scale_5
   2929                  b = 2;
   \   00003A   7A02         MOV     R2,#0x2
   \   00003C   8010         SJMP    ??inv_row_2_scale_1
   2930              else if (row[2] < 0)
   \                     ??inv_row_2_scale_5:
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_313:
   \   000046   5004         JNC     ??inv_row_2_scale_6
   2931                  b = 6;
   \   000048   7A06         MOV     R2,#0x6
   \   00004A   8002         SJMP    ??inv_row_2_scale_1
   2932              else
   2933                  b = 7;      // error
   \                     ??inv_row_2_scale_6:
   \   00004C   7A07         MOV     R2,#0x7
   \                     ??inv_row_2_scale_1:
   \   00004E   02....       LJMP    ??Subroutine123_0 & 0xFFFF
   2934              return b;
   2935          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine139_0
   \   000001                ; // Fall through to label ??Subroutine139_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine139_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   12....       LCALL   ??Subroutine133_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_317:
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   A3           INC     DPTR
   \   000001                REQUIRE ??Subroutine140_0
   \   000001                ; // Fall through to label ??Subroutine140_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine140_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   C3           CLR     C
   \   000002   9401         SUBB    A,#0x1
   \   000004   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000006   65D0         XRL     A,PSW
   \   000008   33           RLC     A
   \   000009   22           RET
   2936          //空函数,未用到.

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2937          void mget_ms(unsigned long *time)
   \                     mget_ms:
   2938          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2939          
   2940          }
   \   000000   02....       LJMP    ?BRET
   2941          //mpu6050,dmp初始化
   2942          //返回值:0,正常
   2943          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2944          u8 mpu_dmp_init(void)
   \                     mpu_dmp_init:
   2945          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2946          	u8 res=0;
   2947          	MPU_IIC_Init(); 	//初始化IIC总线
   \   000005                ; Setup parameters for call to function MPU_IIC_Init
   \   000005   12....       LCALL   ??MPU_IIC_Init?relay
   2948          	if(mpu_init()==0)	//初始化MPU6050
   \   000008                ; Setup parameters for call to function mpu_init
   \   000008   12....       LCALL   ??mpu_init?relay
   \   00000B   8B..         MOV     ?V0 + 1,R3
   \   00000D   EA           MOV     A,R2
   \   00000E   45..         ORL     A,?V0 + 1
   \   000010   706D         JNZ     ??mpu_dmp_init_0
   2949          	{	 
   2950          		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置所需要的传感器
   2951          		if(res)return 1; 
   \   000012                ; Setup parameters for call to function mpu_set_sensors
   \   000012   7978         MOV     R1,#0x78
   \   000014   12....       LCALL   ??mpu_set_sensors?relay
   \   000017   EA           MOV     A,R2
   \   000018   6004         JZ      ??mpu_dmp_init_1
   \   00001A   7901         MOV     R1,#0x1
   \   00001C   8063         SJMP    ??mpu_dmp_init_2
   2952          		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置FIFO
   2953          		if(res)return 2; 
   \                     ??mpu_dmp_init_1:
   \   00001E                ; Setup parameters for call to function mpu_configure_fifo
   \   00001E   7978         MOV     R1,#0x78
   \   000020   12....       LCALL   ??mpu_configure_fifo?relay
   \   000023   EA           MOV     A,R2
   \   000024   6004         JZ      ??mpu_dmp_init_3
   \   000026   7902         MOV     R1,#0x2
   \   000028   8057         SJMP    ??mpu_dmp_init_2
   2954          		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	//设置采样率
   2955          		if(res)return 3; 
   \                     ??mpu_dmp_init_3:
   \   00002A                ; Setup parameters for call to function mpu_set_sample_rate
   \   00002A   7A64         MOV     R2,#0x64
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   12....       LCALL   ??mpu_set_sample_rate?relay
   \   000031   EA           MOV     A,R2
   \   000032   6004         JZ      ??mpu_dmp_init_4
   \   000034   7903         MOV     R1,#0x3
   \   000036   8049         SJMP    ??mpu_dmp_init_2
   2956          		res=dmp_load_motion_driver_firmware();		//加载dmp固件
   2957          		if(res)return 4; 
   \                     ??mpu_dmp_init_4:
   \   000038                ; Setup parameters for call to function dmp_load_motion_driver_firmware
   \   000038   12....       LCALL   ??dmp_load_motion_driver_firmware?relay
   \   00003B   EA           MOV     A,R2
   \   00003C   6004         JZ      ??mpu_dmp_init_5
   \   00003E   7904         MOV     R1,#0x4
   \   000040   803F         SJMP    ??mpu_dmp_init_2
   2958          		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向
   2959          		if(res)return 5; 
   \                     ??mpu_dmp_init_5:
   \   000042                ; Setup parameters for call to function dmp_set_orientation
   \   000042                ; Setup parameters for call to function inv_orientation_matrix_to_scalar
   \   000042   7A..         MOV     R2,#gyro_orientation & 0xff
   \   000044   7B..         MOV     R3,#(gyro_orientation >> 8) & 0xff
   \   000046   12....       LCALL   ??inv_orientation_matrix_to_scalar?relay
   \   000049   12....       LCALL   ??dmp_set_orientation?relay
   \   00004C   EA           MOV     A,R2
   \   00004D   6004         JZ      ??mpu_dmp_init_6
   \   00004F   7905         MOV     R1,#0x5
   \   000051   802E         SJMP    ??mpu_dmp_init_2
   2960          		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	//设置dmp功能
   2961          		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
   2962          		    DMP_FEATURE_GYRO_CAL);
   2963          		if(res)return 6; 
   \                     ??mpu_dmp_init_6:
   \   000053                ; Setup parameters for call to function dmp_enable_feature
   \   000053   7A73         MOV     R2,#0x73
   \   000055   7B01         MOV     R3,#0x1
   \   000057   12....       LCALL   ??dmp_enable_feature?relay
   \   00005A   EA           MOV     A,R2
   \   00005B   6004         JZ      ??mpu_dmp_init_7
   \   00005D   7906         MOV     R1,#0x6
   \   00005F   8020         SJMP    ??mpu_dmp_init_2
   2964          		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//设置DMP输出速率(最大不超过200Hz)
   2965          		if(res)return 7;   
   \                     ??mpu_dmp_init_7:
   \   000061                ; Setup parameters for call to function dmp_set_fifo_rate
   \   000061   7A64         MOV     R2,#0x64
   \   000063   7B00         MOV     R3,#0x0
   \   000065   12....       LCALL   ??dmp_set_fifo_rate?relay
   \   000068   EA           MOV     A,R2
   \   000069   6004         JZ      ??mpu_dmp_init_8
   \   00006B   7907         MOV     R1,#0x7
   \   00006D   8012         SJMP    ??mpu_dmp_init_2
   2966          		//res=run_self_test();		//自检
   2967          		//if(res)return 8;    
   2968          		res=mpu_set_dmp_state(1);	//使能DMP
   2969          		if(res)return 9;     
   \                     ??mpu_dmp_init_8:
   \   00006F                ; Setup parameters for call to function mpu_set_dmp_state
   \   00006F   7901         MOV     R1,#0x1
   \   000071   12....       LCALL   ??mpu_set_dmp_state?relay
   \   000074   EA           MOV     A,R2
   \   000075   6004         JZ      ??mpu_dmp_init_9
   \   000077   7909         MOV     R1,#0x9
   \   000079   8006         SJMP    ??mpu_dmp_init_2
   2970          	}else return 10;
   2971          	return 0;
   \                     ??mpu_dmp_init_9:
   \   00007B   7900         MOV     R1,#0x0
   \   00007D   8002         SJMP    ??mpu_dmp_init_2
   \                     ??mpu_dmp_init_0:
   \   00007F   790A         MOV     R1,#0xa
   \                     ??mpu_dmp_init_2:
   \   000081   02....       LJMP    ??Subroutine136_0 & 0xFFFF
   2972          }
   2973          //得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)
   2974          //pitch:俯仰角 精度:0.1°   范围:-90.0° <---> +90.0°
   2975          //roll:横滚角  精度:0.1°   范围:-180.0°<---> +180.0°
   2976          //yaw:航向角   精度:0.1°   范围:-180.0°<---> +180.0°
   2977          //返回值:0,正常
   2978          //    其他,失败

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2979          u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
   \                     mpu_dmp_get_data:
   2980          {
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 155
   \   000005   7465         MOV     A,#0x65
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7411         MOV     A,#0x11
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   740F         MOV     A,#0xf
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   EC           MOV     A,R4
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   ED           MOV     A,R5
   \   00001D   F0           MOVX    @DPTR,A
   2981          	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
   2982          	unsigned long sensor_timestamp;
   2983          	short gyro[3], accel[3], sensors;
   2984          	unsigned char more;
   2985          	long quat[4]; 
   2986          	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
   \   00001E                ; Setup parameters for call to function dmp_read_fifo
   \   00001E   7404         MOV     A,#0x4
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   8582..       MOV     ?V0 + 0,DPL
   \   000026   8583..       MOV     ?V0 + 1,DPH
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   740F         MOV     A,#0xf
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   8582..       MOV     ?V0 + 0,DPL
   \   000036   8583..       MOV     ?V0 + 1,DPH
   \   000039   78..         MOV     R0,#?V0 + 0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   741B         MOV     A,#0x1b
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   8582..       MOV     ?V0 + 0,DPL
   \   000046   8583..       MOV     ?V0 + 1,DPH
   \   000049   78..         MOV     R0,#?V0 + 0
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   7421         MOV     A,#0x21
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   8582..       MOV     ?V0 + 0,DPL
   \   000056   8583..       MOV     ?V0 + 1,DPH
   \   000059   78..         MOV     R0,#?V0 + 0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   7433         MOV     A,#0x33
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   AC82         MOV     R4,DPL
   \   000065   AD83         MOV     R5,DPH
   \   000067   7439         MOV     A,#0x39
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   AA82         MOV     R2,DPL
   \   00006E   AB83         MOV     R3,DPH
   \   000070   12....       LCALL   ??dmp_read_fifo?relay
   \   000073   7408         MOV     A,#0x8
   \   000075   12....       LCALL   ?DEALLOC_XSTACK8
   \   000078   8B..         MOV     ?V0 + 1,R3
   \   00007A   EA           MOV     A,R2
   \   00007B   45..         ORL     A,?V0 + 1
   \   00007D   6005         JZ      ??mpu_dmp_get_data_0
   \   00007F   7901         MOV     R1,#0x1
   \   000081   02....       LJMP    ??mpu_dmp_get_data_1 & 0xFFFF
   2987          	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
   2988          	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
   2989          	**/
   2990          	/*if (sensors & INV_XYZ_GYRO )
   2991          	send_packet(PACKET_TYPE_GYRO, gyro);
   2992          	if (sensors & INV_XYZ_ACCEL)
   2993          	send_packet(PACKET_TYPE_ACCEL, accel); */
   2994          	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
   2995          	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
   2996          	**/
   2997          	if(sensors&INV_WXYZ_QUAT) 
   \                     ??mpu_dmp_get_data_0:
   \   000084   740D         MOV     A,#0xd
   \   000086   12....       LCALL   ?XSTACK_DISP0_8
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   5401         ANL     A,#0x1
   \   00008D   7003         JNZ     $+5
   \   00008F   02....       LJMP    ??mpu_dmp_get_data_2 & 0xFFFF
   2998          	{
   2999          		q0 = quat[0] / q30;	//q30格式转换为浮点数
   \   000092   741B         MOV     A,#0x1b
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   12....       LCALL   ?L_MOV_X
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_TO_FLT
   \   0000A1   90....       MOV     DPTR,#__Constant_30800000
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   12....       LCALL   ?L_MOV_X
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   79..         MOV     R1,#?V0 + 4
   \   0000AD   12....       LCALL   ?FLT_MUL
   \   0000B0   7409         MOV     A,#0x9
   \   0000B2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_TO_X
   3000          		q1 = quat[1] / q30;
   \   0000BA   741F         MOV     A,#0x1f
   \   0000BC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BF   78..         MOV     R0,#?V0 + 4
   \   0000C1   12....       LCALL   ?L_MOV_X
   \   0000C4   78..         MOV     R0,#?V0 + 4
   \   0000C6   12....       LCALL   ?L_TO_FLT
   \   0000C9   90....       MOV     DPTR,#__Constant_30800000
   \   0000CC   78..         MOV     R0,#?V0 + 0
   \   0000CE   12....       LCALL   ?L_MOV_X
   \   0000D1   78..         MOV     R0,#?V0 + 4
   \   0000D3   79..         MOV     R1,#?V0 + 0
   \   0000D5   12....       LCALL   ?FLT_MUL
   3001          		q2 = quat[2] / q30;
   \   0000D8   7423         MOV     A,#0x23
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   78..         MOV     R0,#?V0 + 0
   \   0000DF   12....       LCALL   ?L_MOV_X
   \   0000E2   78..         MOV     R0,#?V0 + 0
   \   0000E4   12....       LCALL   ?L_TO_FLT
   \   0000E7   90....       MOV     DPTR,#__Constant_30800000
   \   0000EA   78..         MOV     R0,#?V0 + 8
   \   0000EC   12....       LCALL   ?L_MOV_X
   \   0000EF   78..         MOV     R0,#?V0 + 0
   \   0000F1   79..         MOV     R1,#?V0 + 8
   \   0000F3   12....       LCALL   ?FLT_MUL
   \   0000F6   85..82       MOV     DPL,?XSP + 0
   \   0000F9   85..83       MOV     DPH,?XSP + 1
   \   0000FC   78..         MOV     R0,#?V0 + 0
   \   0000FE   12....       LCALL   ?L_MOV_TO_X
   3002          		q3 = quat[3] / q30; 
   \   000101   7427         MOV     A,#0x27
   \   000103   12....       LCALL   ?XSTACK_DISP0_8
   \   000106   78..         MOV     R0,#?V0 + 0
   \   000108   12....       LCALL   ?L_MOV_X
   \   00010B   78..         MOV     R0,#?V0 + 0
   \   00010D   12....       LCALL   ?L_TO_FLT
   \   000110   90....       MOV     DPTR,#__Constant_30800000
   \   000113   78..         MOV     R0,#?V0 + 8
   \   000115   12....       LCALL   ?L_MOV_X
   \   000118   78..         MOV     R0,#?V0 + 0
   \   00011A   79..         MOV     R1,#?V0 + 8
   \   00011C   12....       LCALL   ?FLT_MUL
   \   00011F   7405         MOV     A,#0x5
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   78..         MOV     R0,#?V0 + 0
   \   000126   12....       LCALL   ?L_MOV_TO_X
   3003          		//计算得到俯仰角/横滚角/航向角
   3004          		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
   \   000129   7409         MOV     A,#0x9
   \   00012B   12....       LCALL   ?XSTACK_DISP0_8
   \   00012E   78..         MOV     R0,#?V0 + 0
   \   000130   12....       LCALL   ?L_MOV_X
   \   000133   90....       MOV     DPTR,#__Constant_40000000
   \   000136   78..         MOV     R0,#?V0 + 8
   \   000138   12....       LCALL   ?L_MOV_X
   \   00013B   78..         MOV     R0,#?V0 + 0
   \   00013D   79..         MOV     R1,#?V0 + 8
   \   00013F   12....       LCALL   ?FLT_MUL
   \   000142   7413         MOV     A,#0x13
   \   000144   12....       LCALL   ?XSTACK_DISP0_8
   \   000147   78..         MOV     R0,#?V0 + 0
   \   000149   12....       LCALL   ?L_MOV_TO_X
   \   00014C   85....       MOV     ?V0 + 0,?V0 + 4
   \   00014F   85....       MOV     ?V0 + 1,?V0 + 5
   \   000152   85....       MOV     ?V0 + 2,?V0 + 6
   \   000155   85....       MOV     ?V0 + 3,?V0 + 7
   \   000158   90....       MOV     DPTR,#__Constant_c0000000
   \   00015B   78..         MOV     R0,#?V0 + 8
   \   00015D   12....       LCALL   ?L_MOV_X
   \   000160   78..         MOV     R0,#?V0 + 0
   \   000162   79..         MOV     R1,#?V0 + 8
   \   000164   12....       LCALL   ?FLT_MUL
   \   000167                ; Setup parameters for call to function asin
   \   000167   85....       MOV     ?V0 + 8,?V0 + 0
   \   00016A   85....       MOV     ?V0 + 9,?V0 + 1
   \   00016D   85....       MOV     ?V0 + 10,?V0 + 2
   \   000170   85....       MOV     ?V0 + 11,?V0 + 3
   \   000173   7405         MOV     A,#0x5
   \   000175   12....       LCALL   ?XSTACK_DISP0_8
   \   000178   78..         MOV     R0,#?V0 + 12
   \   00017A   12....       LCALL   ?L_MOV_X
   \   00017D   78..         MOV     R0,#?V0 + 8
   \   00017F   79..         MOV     R1,#?V0 + 12
   \   000181   12....       LCALL   ?FLT_MUL
   \   000184   C0..         PUSH    ?V0 + 8
   \   000186   C0..         PUSH    ?V0 + 9
   \   000188   C0..         PUSH    ?V0 + 10
   \   00018A   C0..         PUSH    ?V0 + 11
   \   00018C   7413         MOV     A,#0x13
   \   00018E   12....       LCALL   ?XSTACK_DISP0_8
   \   000191   78..         MOV     R0,#?V0 + 12
   \   000193   12....       LCALL   ?L_MOV_X
   \   000196   85..82       MOV     DPL,?XSP + 0
   \   000199   85..83       MOV     DPH,?XSP + 1
   \   00019C   78..         MOV     R0,#?V0 + 8
   \   00019E   12....       LCALL   ?L_MOV_X
   \   0001A1   78..         MOV     R0,#?V0 + 12
   \   0001A3   79..         MOV     R1,#?V0 + 8
   \   0001A5   12....       LCALL   ?FLT_MUL
   \   0001A8   D0..         POP     ?V0 + 11
   \   0001AA   D0..         POP     ?V0 + 10
   \   0001AC   D0..         POP     ?V0 + 9
   \   0001AE   D0..         POP     ?V0 + 8
   \   0001B0   78..         MOV     R0,#?V0 + 8
   \   0001B2   79..         MOV     R1,#?V0 + 12
   \   0001B4   12....       LCALL   ?FLT_ADD
   \   0001B7   AA..         MOV     R2,?V0 + 8
   \   0001B9   AB..         MOV     R3,?V0 + 9
   \   0001BB   AC..         MOV     R4,?V0 + 10
   \   0001BD   AD..         MOV     R5,?V0 + 11
   \   0001BF   12....       LCALL   ??asin?relay
   \   0001C2   8A..         MOV     ?V0 + 8,R2
   \   0001C4   8B..         MOV     ?V0 + 9,R3
   \   0001C6   8C..         MOV     ?V0 + 10,R4
   \   0001C8   8D..         MOV     ?V0 + 11,R5
   \   0001CA   90....       MOV     DPTR,#__Constant_42653333
   \   0001CD   78..         MOV     R0,#?V0 + 12
   \   0001CF   12....       LCALL   ?L_MOV_X
   \   0001D2   78..         MOV     R0,#?V0 + 8
   \   0001D4   79..         MOV     R1,#?V0 + 12
   \   0001D6   12....       LCALL   ?FLT_MUL
   \   0001D9   7411         MOV     A,#0x11
   \   0001DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0001DE   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_324:
   \   0001E1   78..         MOV     R0,#?V0 + 8
   \   0001E3   12....       LCALL   ?L_MOV_TO_X
   3005          		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
   \   0001E6   85..82       MOV     DPL,?XSP + 0
   \   0001E9   85..83       MOV     DPH,?XSP + 1
   \   0001EC   78..         MOV     R0,#?V0 + 8
   \   0001EE   12....       LCALL   ?L_MOV_X
   \   0001F1   90....       MOV     DPTR,#__Constant_40000000
   \   0001F4   78..         MOV     R0,#?V0 + 12
   \   0001F6   12....       LCALL   ?L_MOV_X
   \   0001F9   78..         MOV     R0,#?V0 + 8
   \   0001FB   79..         MOV     R1,#?V0 + 12
   \   0001FD   12....       LCALL   ?FLT_MUL
   \   000200                ; Setup parameters for call to function atan2
   \   000200   78..         MOV     R0,#?V0 + 0
   \   000202   79..         MOV     R1,#?V0 + 4
   \   000204   12....       LCALL   ?FLT_MUL
   \   000207   C0..         PUSH    ?V0 + 0
   \   000209   C0..         PUSH    ?V0 + 1
   \   00020B   C0..         PUSH    ?V0 + 2
   \   00020D   C0..         PUSH    ?V0 + 3
   \   00020F   85....       MOV     ?V0 + 0,?V0 + 8
   \   000212   85....       MOV     ?V0 + 1,?V0 + 9
   \   000215   85....       MOV     ?V0 + 2,?V0 + 10
   \   000218   85....       MOV     ?V0 + 3,?V0 + 11
   \   00021B   85..82       MOV     DPL,?XSP + 0
   \   00021E   85..83       MOV     DPH,?XSP + 1
   \   000221   78..         MOV     R0,#?V0 + 12
   \   000223   12....       LCALL   ?L_MOV_X
   \   000226   78..         MOV     R0,#?V0 + 0
   \   000228   79..         MOV     R1,#?V0 + 12
   \   00022A   12....       LCALL   ?FLT_MUL
   \   00022D   D0..         POP     ?V0 + 15
   \   00022F   D0..         POP     ?V0 + 14
   \   000231   D0..         POP     ?V0 + 13
   \   000233   D0..         POP     ?V0 + 12
   \   000235   78..         MOV     R0,#?V0 + 12
   \   000237   79..         MOV     R1,#?V0 + 0
   \   000239   12....       LCALL   ?FLT_SUB
   \   00023C   90....       MOV     DPTR,#__Constant_3f800000
   \   00023F   78..         MOV     R0,#?V0 + 0
   \   000241   12....       LCALL   ?L_MOV_X
   \   000244   78..         MOV     R0,#?V0 + 12
   \   000246   79..         MOV     R1,#?V0 + 0
   \   000248   12....       LCALL   ?FLT_ADD
   \   00024B   78..         MOV     R0,#?V0 + 12
   \   00024D   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   000250   7409         MOV     A,#0x9
   \   000252   12....       LCALL   ?XSTACK_DISP0_8
   \   000255   78..         MOV     R0,#?V0 + 0
   \   000257   12....       LCALL   ?L_MOV_X
   \   00025A   78..         MOV     R0,#?V0 + 8
   \   00025C   79..         MOV     R1,#?V0 + 0
   \   00025E   12....       LCALL   ?FLT_MUL
   \   000261   7417         MOV     A,#0x17
   \   000263   12....       LCALL   ?XSTACK_DISP0_8
   \   000266   78..         MOV     R0,#?V0 + 0
   \   000268   12....       LCALL   ?L_MOV_X
   \   00026B   78..         MOV     R0,#?V0 + 0
   \   00026D   79..         MOV     R1,#?V0 + 4
   \   00026F   12....       LCALL   ?FLT_MUL
   \   000272   78..         MOV     R0,#?V0 + 8
   \   000274   79..         MOV     R1,#?V0 + 0
   \   000276   12....       LCALL   ?FLT_ADD
   \   000279   AA..         MOV     R2,?V0 + 8
   \   00027B   AB..         MOV     R3,?V0 + 9
   \   00027D   AC..         MOV     R4,?V0 + 10
   \   00027F   AD..         MOV     R5,?V0 + 11
   \   000281   12....       LCALL   ??atan2?relay
   \   000284   7404         MOV     A,#0x4
   \   000286   12....       LCALL   ?DEALLOC_XSTACK8
   \   000289   8A..         MOV     ?V0 + 0,R2
   \   00028B   8B..         MOV     ?V0 + 1,R3
   \   00028D   8C..         MOV     ?V0 + 2,R4
   \   00028F   8D..         MOV     ?V0 + 3,R5
   \   000291   90....       MOV     DPTR,#__Constant_42653333
   \   000294   78..         MOV     R0,#?V0 + 8
   \   000296   12....       LCALL   ?L_MOV_X
   \   000299   78..         MOV     R0,#?V0 + 0
   \   00029B   79..         MOV     R1,#?V0 + 8
   \   00029D   12....       LCALL   ?FLT_MUL
   \   0002A0   740F         MOV     A,#0xf
   \   0002A2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002A5   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_325:
   \   0002A8   78..         MOV     R0,#?V0 + 0
   \   0002AA   12....       LCALL   ?L_MOV_TO_X
   3006          		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
   \   0002AD                ; Setup parameters for call to function atan2
   \   0002AD   7409         MOV     A,#0x9
   \   0002AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B2   78..         MOV     R0,#?V0 + 8
   \   0002B4   12....       LCALL   ?L_MOV_X
   \   0002B7   7409         MOV     A,#0x9
   \   0002B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BC   78..         MOV     R0,#?V0 + 0
   \   0002BE   12....       LCALL   ?L_MOV_X
   \   0002C1   78..         MOV     R0,#?V0 + 8
   \   0002C3   79..         MOV     R1,#?V0 + 0
   \   0002C5   12....       LCALL   ?FLT_MUL
   \   0002C8   85....       MOV     ?V0 + 0,?V0 + 4
   \   0002CB   85....       MOV     ?V0 + 1,?V0 + 5
   \   0002CE   85....       MOV     ?V0 + 2,?V0 + 6
   \   0002D1   85....       MOV     ?V0 + 3,?V0 + 7
   \   0002D4   78..         MOV     R0,#?V0 + 0
   \   0002D6   79..         MOV     R1,#?V0 + 4
   \   0002D8   12....       LCALL   ?FLT_MUL
   \   0002DB   78..         MOV     R0,#?V0 + 8
   \   0002DD   79..         MOV     R1,#?V0 + 0
   \   0002DF   12....       LCALL   ?FLT_ADD
   \   0002E2   85..82       MOV     DPL,?XSP + 0
   \   0002E5   85..83       MOV     DPH,?XSP + 1
   \   0002E8   78..         MOV     R0,#?V0 + 0
   \   0002EA   12....       LCALL   ?L_MOV_X
   \   0002ED   85..82       MOV     DPL,?XSP + 0
   \   0002F0   85..83       MOV     DPH,?XSP + 1
   \   0002F3   78..         MOV     R0,#?V0 + 12
   \   0002F5   12....       LCALL   ?L_MOV_X
   \   0002F8   78..         MOV     R0,#?V0 + 0
   \   0002FA   79..         MOV     R1,#?V0 + 12
   \   0002FC   12....       LCALL   ?FLT_MUL
   \   0002FF   78..         MOV     R0,#?V0 + 8
   \   000301   79..         MOV     R1,#?V0 + 0
   \   000303   12....       LCALL   ?FLT_SUB
   \   000306   7405         MOV     A,#0x5
   \   000308   12....       LCALL   ?XSTACK_DISP0_8
   \   00030B   78..         MOV     R0,#?V0 + 0
   \   00030D   12....       LCALL   ?L_MOV_X
   \   000310   7405         MOV     A,#0x5
   \   000312   12....       LCALL   ?XSTACK_DISP0_8
   \   000315   78..         MOV     R0,#?V0 + 12
   \   000317   12....       LCALL   ?L_MOV_X
   \   00031A   78..         MOV     R0,#?V0 + 0
   \   00031C   79..         MOV     R1,#?V0 + 12
   \   00031E   12....       LCALL   ?FLT_MUL
   \   000321   78..         MOV     R0,#?V0 + 8
   \   000323   79..         MOV     R1,#?V0 + 0
   \   000325   12....       LCALL   ?FLT_SUB
   \   000328   78..         MOV     R0,#?V0 + 8
   \   00032A   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   00032D   85....       MOV     ?V0 + 0,?V0 + 4
   \   000330   85....       MOV     ?V0 + 1,?V0 + 5
   \   000333   85....       MOV     ?V0 + 2,?V0 + 6
   \   000336   85....       MOV     ?V0 + 3,?V0 + 7
   \   000339   7404         MOV     A,#0x4
   \   00033B   12....       LCALL   ?XSTACK_DISP0_8
   \   00033E   78..         MOV     R0,#?V0 + 8
   \   000340   12....       LCALL   ?L_MOV_X
   \   000343   78..         MOV     R0,#?V0 + 0
   \   000345   79..         MOV     R1,#?V0 + 8
   \   000347   12....       LCALL   ?FLT_MUL
   \   00034A   740D         MOV     A,#0xd
   \   00034C   12....       LCALL   ?XSTACK_DISP0_8
   \   00034F   78..         MOV     R0,#?V0 + 8
   \   000351   12....       LCALL   ?L_MOV_X
   \   000354   7409         MOV     A,#0x9
   \   000356   12....       LCALL   ?XSTACK_DISP0_8
   \   000359   78..         MOV     R0,#?V0 + 12
   \   00035B   12....       LCALL   ?L_MOV_X
   \   00035E   78..         MOV     R0,#?V0 + 8
   \   000360   79..         MOV     R1,#?V0 + 12
   \   000362   12....       LCALL   ?FLT_MUL
   \   000365   78..         MOV     R0,#?V0 + 0
   \   000367   79..         MOV     R1,#?V0 + 8
   \   000369   12....       LCALL   ?FLT_ADD
   \   00036C   90....       MOV     DPTR,#__Constant_40000000
   \   00036F   78..         MOV     R0,#?V0 + 8
   \   000371   12....       LCALL   ?L_MOV_X
   \   000374   78..         MOV     R0,#?V0 + 0
   \   000376   79..         MOV     R1,#?V0 + 8
   \   000378   12....       LCALL   ?FLT_MUL
   \   00037B   AA..         MOV     R2,?V0 + 0
   \   00037D   AB..         MOV     R3,?V0 + 1
   \   00037F   AC..         MOV     R4,?V0 + 2
   \   000381   AD..         MOV     R5,?V0 + 3
   \   000383   12....       LCALL   ??atan2?relay
   \   000386   7404         MOV     A,#0x4
   \   000388   12....       LCALL   ?DEALLOC_XSTACK8
   \   00038B   8A..         MOV     ?V0 + 0,R2
   \   00038D   8B..         MOV     ?V0 + 1,R3
   \   00038F   8C..         MOV     ?V0 + 2,R4
   \   000391   8D..         MOV     ?V0 + 3,R5
   \   000393   90....       MOV     DPTR,#__Constant_42653333
   \   000396   78..         MOV     R0,#?V0 + 8
   \   000398   12....       LCALL   ?L_MOV_X
   \   00039B   78..         MOV     R0,#?V0 + 0
   \   00039D   79..         MOV     R1,#?V0 + 8
   \   00039F   12....       LCALL   ?FLT_MUL
   \   0003A2   74B3         MOV     A,#-0x4d
   \   0003A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0003A7   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_326:
   \   0003AA   78..         MOV     R0,#?V0 + 0
   \   0003AC   12....       LCALL   ?L_MOV_TO_X
   3007          
   3008          
   3009              {
   3010                extern u16 HalUARTWrite(u8 port, u8 *buf, u16 len);
   3011                u8 buff[100]={0};
   \   0003AF   7437         MOV     A,#0x37
   \   0003B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0003B4   AC82         MOV     R4,DPL
   \   0003B6   AD83         MOV     R5,DPH
   \   0003B8   7583..       MOV     DPH,#(`?<Constant {0}>` >> 8) & 0xff
   \   0003BB   7582..       MOV     DPL,#`?<Constant {0}>` & 0xff
   \   0003BE   7464         MOV     A,#0x64
   \   0003C0   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3012                sprintf(buff, "%f,%f,%f,%f:%f,%f,%f.\r\n",q0,q1,q2,q3,*pitch,*roll,*yaw);
                               ^
Warning[Pe167]: argument of type "u8 *" is incompatible with parameter of type
          "char *"
   \   0003C3                ; Setup parameters for call to function sprintf
   \   0003C3   74B3         MOV     A,#-0x4d
   \   0003C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0003C8   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_327:
   \   0003CB   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003CE   7413         MOV     A,#0x13
   \   0003D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0003D3   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_328:
   \   0003D6   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003D9   7419         MOV     A,#0x19
   \   0003DB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003DE   12....       LCALL   ??Subroutine141_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_329:
   \   0003E1   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003E4   7411         MOV     A,#0x11
   \   0003E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0003E9   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003EC   7410         MOV     A,#0x10
   \   0003EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0003F1   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   0003F4   78..         MOV     R0,#?V0 + 4
   \   0003F6   12....       LCALL   ?PUSH_XSTACK_I_FOUR
   \   0003F9   7421         MOV     A,#0x21
   \   0003FB   12....       LCALL   ?XSTACK_DISP0_8
   \   0003FE   12....       LCALL   ?PUSH_XSTACK8_X_FOUR
   \   000401   7C..         MOV     R4,#`?<Constant "%f,%f,%f,%f:%f,%f,%f.\\r\\n">` & 0xff
   \   000403   7D..         MOV     R5,#(`?<Constant "%f,%f,%f,%f:%f,%f,%f.\\r\\n">` >> 8) & 0xff
   \   000405   7453         MOV     A,#0x53
   \   000407   12....       LCALL   ?XSTACK_DISP0_8
   \   00040A   AA82         MOV     R2,DPL
   \   00040C   AB83         MOV     R3,DPH
   \   00040E   12....       LCALL   ??sprintf?relay
   \   000411   741C         MOV     A,#0x1c
   \   000413   12....       LCALL   ?DEALLOC_XSTACK8
   3013                HalUARTWrite(0, buff, osal_strlen(buff));
                                                         ^
Warning[Pe167]: argument of type "u8 *" is incompatible with parameter of type
          "char *"
   \   000416                ; Setup parameters for call to function HalUARTWrite
   \   000416                ; Setup parameters for call to function osal_strlen
   \   000416   7437         MOV     A,#0x37
   \   000418   12....       LCALL   ?XSTACK_DISP0_8
   \   00041B   AA82         MOV     R2,DPL
   \   00041D   AB83         MOV     R3,DPH
   \   00041F   12....       LCALL   ??osal_strlen?relay
   \   000422   EA           MOV     A,R2
   \   000423   FC           MOV     R4,A
   \   000424   EB           MOV     A,R3
   \   000425   FD           MOV     R5,A
   \   000426   7437         MOV     A,#0x37
   \   000428   12....       LCALL   ?XSTACK_DISP0_8
   \   00042B   AA82         MOV     R2,DPL
   \   00042D   AB83         MOV     R3,DPH
   \   00042F   7900         MOV     R1,#0x0
   \   000431   12....       LCALL   ??HalUARTWrite?relay
   3014              }
   3015              
   3016          	}else return 2;
   3017          	return 0;
   \   000434   7900         MOV     R1,#0x0
   \   000436   8002         SJMP    ??mpu_dmp_get_data_1
   \                     ??mpu_dmp_get_data_2:
   \   000438   7902         MOV     R1,#0x2
   \                     ??mpu_dmp_get_data_1:
   \   00043A   749B         MOV     A,#-0x65
   \   00043C   02....       LJMP    ?Subroutine6 & 0xFFFF
   3018          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for st>`:
   \   000000   ....         DW reg
   \   000002   ....         DW hw
   \   000004   00           DB 0
   \   000005   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00000D   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000015   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001D   00000000     DB 0, 0, 0, 0
   \   000021   ....         DW test

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for gyro_orientation>`:
   \   000000   01           DB 1
   \   000001   00           DB 0
   \   000002   00           DB 0
   \   000003   00           DB 0
   \   000004   01           DB 1
   \   000005   00           DB 0
   \   000006   00           DB 0
   \   000007   00           DB 0
   \   000008   01           DB 1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??set_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    set_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reg_dump?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reg_dump

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_accel_mode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_accel_mode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_temperature?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_temperature

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_bias?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_bias

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_reset_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_reset_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_gyro_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_gyro_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_accel_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_accel_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_lpf?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_lpf

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_compass_sample_rate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_compass_sample_rate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_gyro_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_gyro_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_accel_sens?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_accel_sens

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_fifo_config?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_fifo_config

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_configure_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_configure_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_power_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_power_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_sensors?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_sensors

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_int_status?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_int_status

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_fifo_stream?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_fifo_stream

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_bypass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_bypass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_level?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_level

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_int_latched?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_int_latched

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_accel_prod_shift?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_accel_prod_shift

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??accel_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    accel_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??gyro_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gyro_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??get_st_biases?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    get_st_biases

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_write_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_write_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_read_mem?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_read_mem

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_load_firmware?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_load_firmware

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_set_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_set_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_dmp_state?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_dmp_state

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??setup_compass?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    setup_compass

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_reg?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_reg

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_get_compass_fsr?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_get_compass_fsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_lp_motion_interrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_lp_motion_interrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??run_self_test?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    run_self_test

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_orientation_matrix_to_scalar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_orientation_matrix_to_scalar

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??inv_row_2_scale?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    inv_row_2_scale

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mget_ms?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mget_ms

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??mpu_dmp_get_data?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mpu_dmp_get_data

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%#5x: %#5x\\r\\n">`:
   \   000000   25233578     DB "%#5x: %#5x\015\012"
   \            3A202523
   \            35780D0A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Unsupported software ...">`:
   \   000000   556E7375     DB "Unsupported software product rev %d.\012"
   \            70706F72
   \            74656420
   \            736F6674
   \            77617265
   \            2070726F
   \            64756374
   \            20726576
   \            2025642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Product ID read as 0 ...">`:
   \   000000   50726F64     DB 50H, 72H, 6FH, 64H, 75H, 63H, 74H, 20H
   \            75637420
   \   000008   49442072     DB 49H, 44H, 20H, 72H, 65H, 61H, 64H, 20H
   \            65616420
   \   000010   61732030     DB 61H, 73H, 20H, 30H, 20H, 69H, 6EH, 64H
   \            20696E64
   \   000018   69636174     DB 69H, 63H, 61H, 74H, 65H, 73H, 20H, 64H
   \            65732064
   \   000020   65766963     DB 65H, 76H, 69H, 63H, 65H, 20H, 69H, 73H
   \            65206973
   \   000028   20656974     DB 20H, 65H, 69H, 74H, 68H, 65H, 72H, 20H
   \            68657220
   \   000030   696E636F     DB 69H, 6EH, 63H, 6FH, 6DH, 70H, 61H, 74H
   \            6D706174
   \   000038   69626C65     DB 69H, 62H, 6CH, 65H, 20H, 6FH, 72H, 20H
   \            206F7220
   \   000040   616E204D     DB 61H, 6EH, 20H, 4DH, 50H, 55H, 33H, 30H
   \            50553330
   \   000048   35302E0A     DB 35H, 30H, 2EH, 0AH, 0
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Half sensitivity part...">`:
   \   000000   48616C66     DB "Half sensitivity part found.\012"
   \            2073656E
   \            73697469
   \            76697479
   \            20706172
   \            7420666F
   \            756E642E
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0}>`:
   \   000000   00           DB 0
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000009   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000011   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000019   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000021   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000029   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000031   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000039   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000041   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000049   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000051   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000059   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000061   000000       DB 0, 0, 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "%f,%f,%f,%f:%f,%f,%f.\\r\\n">`:
   \   000000   25662C25     DB "%f,%f,%f,%f:%f,%f,%f.\015\012"
   \            662C2566
   \            2C25663A
   \            25662C25
   \            662C2566
   \            2E0D0A00

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_420c0000:
   \   000000   00000C42     DD 420C0000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_47800000:
   \   000000   00008047     DD 47800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_43030000:
   \   000000   00000343     DD 43030000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42830000:
   \   000000   00008342     DD 42830000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42033333:
   \   000000   33330342     DD 42033333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41833333:
   \   000000   33338341     DD 41833333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3eae147b:
   \   000000   7B14AE3E     DD 3EAE147BH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f845a1d:
   \   000000   1D5A843F     DD 3F845A1DH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_37800000:
   \   000000   00008037     DD 37800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_bf800000:
   \   000000   000080BF     DD 0BF800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e99999a:
   \   000000   9A99993E     DD 3E99999AH

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f733334:
   \   000000   3433733F     DD 3F733334H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41c80000:
   \   000000   0000C841     DD 41C80000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f85e354:
   \   000000   54E3853F     DD 3F85E354H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_41200000:
   \   000000   00002041     DD 41200000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42d20001:
   \   000000   0100D242     DD 42D20001H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_83:
   \   000000   83000000     DD 131

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffff0000:
   \   000000   0000FFFF     DD -65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10000:
   \   000000   00000100     DD 65536

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_30800000:
   \   000000   00008030     DD 30800000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_40000000:
   \   000000   00000040     DD 40000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c0000000:
   \   000000   000000C0     DD 0C0000000H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_42653333:
   \   000000   33336542     DD 42653333H

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3f800000:
   \   000000   0000803F     DD 3F800000H
   3019          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     accel_self_test                    0      0     86
       -> get_accel_prod_shift          0      0     76
       -> labs                          0      0     76
       -> fabsf                         0      0     76
     get_accel_prod_shift               1      0     63
       -> MPU_Read_Len                  0      0     50
     get_st_biases                      2      0     95
       -> MPU_Write_Len                 0      0     94
       -> delay_ms                      0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> delay_ms                      0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> delay_ms                      0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Write_Len                 0      0     94
       -> delay_ms                      0      0     94
       -> MPU_Write_Len                 0      0     94
       -> MPU_Read_Len                  0      0     94
       -> MPU_Read_Len                  0      0     94
     gyro_self_test                     0      0     77
       -> MPU_Read_Len                  0      0     58
       -> labs                          0      0     58
       -> fabsf                         0      0     58
     inv_orientation_matrix_to_scalar
                                        0      0     24
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
       -> inv_row_2_scale               0      0     28
     inv_row_2_scale                    2      0     14
     mget_ms                            0      0      0
     mpu_configure_fifo                 0      0     60
       -> set_int_enable                0      0     24
       -> set_int_enable                0      0     24
       -> mpu_reset_fifo                0      0     24
     mpu_dmp_get_data                   4      0    209
       -> dmp_read_fifo                 0      0    374
       -> asin                          0      0    358
       -> atan2                         0      0    366
       -> atan2                         0      0    366
       -> sprintf                       0      0    414
       -> osal_strlen                   0      0    358
       -> HalUARTWrite                  0      0    358
     mpu_dmp_init                       0      0     10
       -> MPU_IIC_Init                  0      0     20
       -> mpu_init                      0      0     20
       -> mpu_set_sensors               0      0     20
       -> mpu_configure_fifo            0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> dmp_load_motion_driver_firmware
                                        0      0     20
       -> inv_orientation_matrix_to_scalar
                                        0      0     20
       -> dmp_set_orientation           0      0     20
       -> dmp_enable_feature            0      0     20
       -> dmp_set_fifo_rate             0      0     20
       -> mpu_set_dmp_state             0      0     20
     mpu_get_accel_fsr                  3      0     48
     mpu_get_accel_reg                  0      0     15
       -> MPU_Read_Len                  0      0     30
     mpu_get_accel_sens                 2      0     46
     mpu_get_compass_fsr                0      0      0
     mpu_get_compass_reg                0      0      0
     mpu_get_compass_sample_rate        2      0      0
     mpu_get_dmp_state                  3      0      0
     mpu_get_fifo_config                3      0     48
     mpu_get_gyro_fsr                   2      0     48
     mpu_get_gyro_reg                   0      0     15
       -> MPU_Read_Len                  0      0     30
     mpu_get_gyro_sens                  0      0     55
     mpu_get_int_status                 0      0     11
       -> MPU_Read_Len                  0      0     22
     mpu_get_lpf                        2      0     48
     mpu_get_power_state                2      0      0
     mpu_get_sample_rate                2      0     48
     mpu_get_temperature                0      0     18
       -> MPU_Read_Len                  0      0     36
     mpu_init                           0      0     28
       -> MPU_Write_Len                 0      0     32
       -> delay_ms                      0      0     32
       -> MPU_Write_Len                 0      0     32
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     36
       -> MPU_Read_Len                  0      0     32
       -> printf                        0      0     32
       -> printf                        0      0     32
       -> memset                        0      0     36
       -> mpu_set_gyro_fsr              0      0     32
       -> mpu_set_accel_fsr             0      0     32
       -> mpu_set_lpf                   0      0     32
       -> mpu_set_sample_rate           0      0     32
       -> mpu_configure_fifo            0      0     32
       -> mpu_set_bypass                0      0     32
       -> mpu_set_sensors               0      0     32
     mpu_load_firmware                  1      0     44
       -> mpu_write_mem                 0      0     80
       -> mpu_read_mem                  0      0     80
       -> memcmp                        0      0     80
       -> MPU_Write_Len                 0      0     76
     mpu_lp_accel_mode                  1      0     24
       -> mpu_set_int_latched           0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_set_int_latched           0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> mpu_set_lpf                   0      0     22
       -> MPU_Write_Len                 0      0     22
       -> mpu_configure_fifo            0      0     22
     mpu_lp_motion_interrupt            1      0     13
       -> mpu_set_dmp_state             0      0     26
       -> mpu_get_gyro_fsr              0      0     26
       -> mpu_get_accel_fsr             0      0     26
       -> mpu_get_lpf                   0      0     26
       -> mpu_get_sample_rate           0      0     26
       -> mpu_get_fifo_config           0      0     26
       -> set_int_enable                0      0     26
       -> mpu_lp_accel_mode             0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> delay_ms                      0      0     26
       -> MPU_Write_Len                 0      0     26
       -> MPU_Write_Len                 0      0     26
       -> mpu_set_sensors               0      0     26
       -> mpu_set_gyro_fsr              0      0     26
       -> mpu_set_accel_fsr             0      0     26
       -> mpu_set_lpf                   0      0     26
       -> mpu_set_sample_rate           0      0     26
       -> mpu_configure_fifo            0      0     26
       -> mpu_set_dmp_state             0      0     26
     mpu_read_fifo                      1      0     40
       -> MPU_Read_Len                  0      0     68
       -> MPU_Read_Len                  0      0     68
       -> mpu_reset_fifo                0      0     68
       -> MPU_Read_Len                  0      0     68
     mpu_read_fifo_stream               1      0     18
       -> MPU_Read_Len                  0      0     32
       -> MPU_Read_Len                  0      0     32
       -> mpu_reset_fifo                0      0     32
       -> MPU_Read_Len                  0      0     32
     mpu_read_mem                       2      0     52
       -> MPU_Write_Len                 0      0     24
       -> MPU_Read_Len                  0      0     24
     mpu_read_reg                       0      0      9
       -> MPU_Read_Len                  0      0     18
     mpu_reg_dump                       0      0     15
       -> printf                        0      0     30
       -> MPU_Read_Len                  0      0     22
     mpu_reset_fifo                     2      0     35
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
       -> delay_ms                      4      0      2
       -> MPU_Write_Len                 4      0      2
       -> MPU_Write_Len                 4      0      2
     mpu_run_self_test                  0      0     94
       -> mpu_set_dmp_state             0      0     96
       -> mpu_get_gyro_fsr              0      0     96
       -> mpu_get_accel_fsr             0      0     96
       -> mpu_get_lpf                   0      0     96
       -> mpu_get_sample_rate           0      0     96
       -> mpu_get_fifo_config           0      0     96
       -> get_st_biases                 0      0     96
       -> get_st_biases                 0      0     96
       -> accel_self_test               0      0     96
       -> gyro_self_test                0      0     96
       -> mpu_set_gyro_fsr              0      0     96
       -> mpu_set_accel_fsr             0      0     96
       -> mpu_set_lpf                   0      0     96
       -> mpu_set_sample_rate           0      0     96
       -> mpu_set_sensors               0      0     96
       -> mpu_configure_fifo            0      0     96
       -> mpu_set_dmp_state             0      0     96
     mpu_set_accel_bias                 1      0     40
       -> MPU_Read_Len                  0      0     80
       -> MPU_Read_Len                  0      0     80
       -> MPU_Write_Len                 0      0     80
     mpu_set_accel_fsr                  0      0     58
       -> MPU_Write_Len                 0      0     20
     mpu_set_bypass                     0      0     26
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
       -> MPU_Read_Len                  0      0     20
       -> MPU_Write_Len                 0      0     20
       -> delay_ms                      0      0     20
       -> MPU_Write_Len                 0      0     20
     mpu_set_compass_sample_rate        0      0      0
     mpu_set_dmp_state                  1      0     58
       -> set_int_enable                0      0     20
       -> mpu_set_bypass                0      0     20
       -> mpu_set_sample_rate           0      0     20
       -> MPU_Write_Len                 0      0     20
       -> set_int_enable                0      0     20
       -> mpu_reset_fifo                0      0     20
       -> set_int_enable                0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_reset_fifo                0      0     20
     mpu_set_gyro_fsr                   0      0     59
       -> MPU_Write_Len                 0      0     22
     mpu_set_int_latched                0      0     21
       -> MPU_Write_Len                 0      0     20
     mpu_set_int_level                  2      0      0
     mpu_set_lpf                        2      0     49
       -> MPU_Write_Len                 4      0      2
     mpu_set_sample_rate                1      0     58
       -> mpu_lp_accel_mode             0      0     20
       -> mpu_lp_accel_mode             0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_lpf                   0      0     20
     mpu_set_sensors                    0      0     58
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
       -> mpu_set_int_latched           0      0     20
       -> delay_ms                      0      0     20
     mpu_write_mem                      2      0     52
       -> MPU_Write_Len                 0      0     24
       -> MPU_Write_Len                 0      0     24
     run_self_test                      0      0     46
       -> mpu_run_self_test             0      0     92
       -> mpu_get_gyro_sens             0      0     92
       -> dmp_set_gyro_bias             0      0     92
       -> mpu_get_accel_sens            0      0     92
       -> dmp_set_accel_bias            0      0     92
     set_int_enable                     0      0     23
       -> MPU_Write_Len                 0      0     20
       -> MPU_Write_Len                 0      0     20
     setup_compass                      0      0      0


   Segment part sizes:

     Function/Label                           Bytes
     --------------                           -----
     reg                                        27
     hw                                         10
     test                                       39
     st                                         35
     set_int_enable                            106
     ??Subroutine108_0                           3
     ??Subroutine109_0                           8
     ?Subroutine0                                2
     ??Subroutine111_0                           3
     ??Subroutine112_0                           5
     ?Subroutine89                               4
     ?Subroutine101                             11
     ?Subroutine75                               6
     ?Subroutine93                               8
     ?Subroutine99                               9
     ??Subroutine138_0                          10
     ?Subroutine104                              4
     ?Subroutine105                              9
     mpu_reg_dump                              104
     ?Subroutine25                              12
     ?Subroutine16                               6
     ??Subroutine110_0                           5
     ?Subroutine78                               4
     ?Subroutine98                               4
     ?Subroutine103                              7
     ??Subroutine125_0                           8
     ?Subroutine83                               5
     ?Subroutine1                                2
     ??Subroutine135_0                           3
     ??Subroutine136_0                           5
     ?Subroutine82                               4
     mpu_read_reg                               59
     ?Subroutine34                               3
     ??Subroutine141_0                           4
     ?Subroutine100                              4
     ??Subroutine107_0                           6
     mpu_init                                  397
     ??Subroutine113_0                           3
     ??Subroutine114_0                           8
     ?Subroutine60                              12
     ?Subroutine33                               5
     ?Subroutine50                               4
     ?Subroutine79                               9
     ??Subroutine132_0                           5
     ?Subroutine91                              14
     ?Subroutine11                               8
     ??Subroutine106_0                           3
     mpu_lp_accel_mode                         163
     ?Subroutine8                                4
     ?Subroutine65                              10
     ?Subroutine90                               6
     ?Subroutine102                             12
     mpu_get_gyro_reg                           86
     ?Subroutine9                                4
     ?Subroutine41                               9
     ?Subroutine36                               9
     ?Subroutine24                              13
     ?Subroutine86                               6
     ?Subroutine39                              11
     ?Subroutine92                               2
     ??Subroutine119_0                           5
     mpu_get_accel_reg                          89
     mpu_get_temperature                       192
     ?Subroutine80                               8
     ??Subroutine126_0                           8
     ?Subroutine15                               7
     ?Subroutine2                                8
     mpu_set_accel_bias                        525
     ?Subroutine63                              16
     ?Subroutine61                               9
     ?Subroutine55                              10
     ?Subroutine54                               1
     ??Subroutine115_0                           6
     ?Subroutine51                               8
     ?Subroutine38                              12
     ?Subroutine37                               9
     ?Subroutine87                               6
     mpu_reset_fifo                            234
     ?Subroutine10                               8
     ?Subroutine32                               6
     ??Subroutine116_0                           9
     ??Subroutine117_0                           5
     ?Subroutine23                               3
     ??Subroutine121_0                           8
     ??Subroutine124_0                           7
     ?Subroutine31                               7
     ??Subroutine128_0                           1
     ??Subroutine129_0                           4
     ??Subroutine130_0                           4
     ?Subroutine77                              11
     ?Subroutine46                               7
     mpu_get_gyro_fsr                           78
     ??Subroutine122_0                           3
     ??Subroutine123_0                           2
     mpu_set_gyro_fsr                          121
     ?Subroutine88                               6
     ??Subroutine118_0                           7
     ?Subroutine22                              14
     ?Subroutine85                              10
     ?Subroutine30                               9
     mpu_get_accel_fsr                          79
     mpu_set_accel_fsr                         111
     ??Subroutine131_0                          13
     ?Subroutine76                               4
     ?Subroutine97                               8
     mpu_get_lpf                                89
     mpu_set_lpf                               155
     mpu_get_sample_rate                        35
     ?Subroutine53                               3
     ??Subroutine137_0                           6
     mpu_set_sample_rate                       177
     mpu_get_compass_sample_rate                19
     mpu_set_compass_sample_rate                 3
     ?Subroutine4                                7
     mpu_get_gyro_sens                          67
     mpu_get_accel_sens                         98
     ?Subroutine84                              10
     mpu_get_fifo_config                        10
     ?Subroutine3                                5
     mpu_configure_fifo                        119
     mpu_get_power_state                        22
     mpu_set_sensors                           169
     mpu_get_int_status                         64
     ?Subroutine12                              18
     mpu_read_fifo                             426
     ?Subroutine48                               2
     ??Subroutine120_0                          11
     ?Subroutine44                              10
     ?Subroutine40                              20
     ?Subroutine81                              13
     ?Subroutine21                              11
     ?Subroutine18                              19
     ?Subroutine74                               7
     mpu_read_fifo_stream                      160
     ?Subroutine5                                5
     mpu_set_bypass                            250
     mpu_set_int_level                          10
     mpu_set_int_latched                       107
     get_accel_prod_shift                      254
     ?Subroutine70                              13
     ?Subroutine69                              20
     ?Subroutine27                               7
     ?Subroutine13                               2
     accel_self_test                           267
     ?Subroutine6                                8
     ?Subroutine71                              13
     ?Subroutine72                              13
     ?Subroutine68                              14
     ?Subroutine67                              20
     ?Subroutine57                               9
     ?Subroutine52                              16
     ?Subroutine96                              11
     ?Subroutine94                               1
     ??Subroutine133_0                           8
     gyro_self_test                            285
     ?Subroutine66                              18
     get_st_biases                            1160
     ?Subroutine64                              12
     ?Subroutine95                               2
     ?Subroutine62                              14
     ?Subroutine56                               3
     ??Subroutine127_0                          10
     ?Subroutine20                               1
     ?Subroutine17                               5
     ?Subroutine14                              20
     mpu_run_self_test                         301
     ?Subroutine73                               9
     ?Subroutine58                               9
     ?Subroutine35                               7
     ?Subroutine47                              23
     ?Subroutine43                               7
     ?Subroutine42                               7
     mpu_write_mem                             124
     ?Subroutine7                                4
     ?Subroutine19                               5
     ??Subroutine134_0                           5
     ?Subroutine45                               9
     mpu_read_mem                              127
     mpu_load_firmware                         304
     ?Subroutine49                               7
     mpu_set_dmp_state                          95
     ?Subroutine26                              15
     mpu_get_dmp_state                          10
     setup_compass                               2
     mpu_get_compass_reg                         0
     mpu_get_compass_fsr                         2
     mpu_lp_motion_interrupt                   439
     gyro_orientation                            9
     run_self_test                             345
     inv_orientation_matrix_to_scalar
                                                67
     ?Subroutine59                              13
     inv_row_2_scale                            81
     ?Subroutine29                               1
     ??Subroutine139_0                           6
     ?Subroutine28                               1
     ??Subroutine140_0                          10
     mget_ms                                     3
     mpu_dmp_init                              132
     mpu_dmp_get_data                         1087
     ?<Initializer for st>                      35
     ?<Initializer for gyro_orientation>         9
     ??set_int_enable?relay                      6
     ??mpu_reg_dump?relay                        6
     ??mpu_read_reg?relay                        6
     ??mpu_init?relay                            6
     ??mpu_lp_accel_mode?relay                   6
     ??mpu_get_gyro_reg?relay                    6
     ??mpu_get_accel_reg?relay                   6
     ??mpu_get_temperature?relay                 6
     ??mpu_set_accel_bias?relay                  6
     ??mpu_reset_fifo?relay                      6
     ??mpu_get_gyro_fsr?relay                    6
     ??mpu_set_gyro_fsr?relay                    6
     ??mpu_get_accel_fsr?relay                   6
     ??mpu_set_accel_fsr?relay                   6
     ??mpu_get_lpf?relay                         6
     ??mpu_set_lpf?relay                         6
     ??mpu_get_sample_rate?relay                 6
     ??mpu_set_sample_rate?relay                 6
     ??mpu_get_compass_sample_rate?relay         6
     ??mpu_set_compass_sample_rate?relay         6
     ??mpu_get_gyro_sens?relay                   6
     ??mpu_get_accel_sens?relay                  6
     ??mpu_get_fifo_config?relay                 6
     ??mpu_configure_fifo?relay                  6
     ??mpu_get_power_state?relay                 6
     ??mpu_set_sensors?relay                     6
     ??mpu_get_int_status?relay                  6
     ??mpu_read_fifo?relay                       6
     ??mpu_read_fifo_stream?relay                6
     ??mpu_set_bypass?relay                      6
     ??mpu_set_int_level?relay                   6
     ??mpu_set_int_latched?relay                 6
     ??get_accel_prod_shift?relay                6
     ??accel_self_test?relay                     6
     ??gyro_self_test?relay                      6
     ??get_st_biases?relay                       6
     ??mpu_run_self_test?relay                   6
     ??mpu_write_mem?relay                       6
     ??mpu_read_mem?relay                        6
     ??mpu_load_firmware?relay                   6
     ??mpu_set_dmp_state?relay                   6
     ??mpu_get_dmp_state?relay                   6
     ??setup_compass?relay                       6
     ??mpu_get_compass_reg?relay                 6
     ??mpu_get_compass_fsr?relay                 6
     ??mpu_lp_motion_interrupt?relay             6
     ??run_self_test?relay                       6
     ??inv_orientation_matrix_to_scalar?relay    6
     ??inv_row_2_scale?relay                     6
     ??mget_ms?relay                             6
     ??mpu_dmp_init?relay                        6
     ??mpu_dmp_get_data?relay                    6
     ?<Constant "%#5x: %#5x\r\n">               13
     ?<Constant "Unsupported software ...">     38
     ?<Constant "Product ID read as 0 ...">     77
     ?<Constant "Half sensitivity part...">     30
     ?<Constant {0}>                           100
     ?<Constant "%f,%f,%f,%f:%f,%f,%f.\r\n">    24
     __Constant_420c0000                         4
     __Constant_47800000                         4
     __Constant_43030000                         4
     __Constant_42830000                         4
     __Constant_42033333                         4
     __Constant_41833333                         4
     __Constant_0                                4
     __Constant_3eae147b                         4
     __Constant_3f845a1d                         4
     __Constant_37800000                         4
     __Constant_bf800000                         4
     __Constant_3e99999a                         4
     __Constant_3f733334                         4
     __Constant_41c80000                         4
     __Constant_3f85e354                         4
     __Constant_41200000                         4
     __Constant_42d20001                         4
     __Constant_83                               4
     __Constant_1                                4
     __Constant_ffff0000                         4
     __Constant_10000                            4
     __Constant_30800000                         4
     __Constant_40000000                         4
     __Constant_c0000000                         4
     __Constant_42653333                         4
     __Constant_3f800000                         4

 
 10 524 bytes in segment BANKED_CODE
    312 bytes in segment BANK_RELAYS
     44 bytes in segment XDATA_I
     44 bytes in segment XDATA_ID
    462 bytes in segment XDATA_ROM_C
 
 10 880 bytes of CODE  memory
    358 bytes of CONST memory (+ 104 bytes shared)
     44 bytes of XDATA memory

Errors: none
Warnings: 4
